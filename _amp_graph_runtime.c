#define _CFFI_

/* We try to define Py_LIMITED_API before including Python.h.

   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
   the same works for the other two macros.  Py_DEBUG implies them,
   but not the other way around.

   The implementation is messy (issue #350): on Windows, with _MSC_VER,
   we have to define Py_LIMITED_API even before including pyconfig.h.
   In that case, we guess what pyconfig.h will do to the macros above,
   and check our guess after the #include.

   Note that on Windows, with CPython 3.x, you need >= 3.5 and virtualenv
   version >= 16.0.0.  With older versions of either, you don't get a
   copy of PYTHON3.DLL in the virtualenv.  We can't check the version of
   CPython *before* we even include pyconfig.h.  ffi.set_source() puts
   a ``#define _CFFI_NO_LIMITED_API'' at the start of this file if it is
   running on Windows < 3.5, as an attempt at fixing it, but that's
   arguably wrong because it may not be the target version of Python.
   Still better than nothing I guess.  As another workaround, you can
   remove the definition of Py_LIMITED_API here.

   See also 'py_limited_api' in cffi/setuptools_ext.py.
*/
#if !defined(_CFFI_USE_EMBEDDING) && !defined(Py_LIMITED_API)
#  ifdef _MSC_VER
#    if !defined(_DEBUG) && !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#    include <pyconfig.h>
     /* sanity-check: Py_LIMITED_API will cause crashes if any of these
        are also defined.  Normally, the Python file PC/pyconfig.h does not
        cause any of these to be defined, with the exception that _DEBUG
        causes Py_DEBUG.  Double-check that. */
#    ifdef Py_LIMITED_API
#      if defined(Py_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_DEBUG, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_TRACE_REFS)
#        error "pyconfig.h unexpectedly defines Py_TRACE_REFS, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_REF_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_REF_DEBUG, but Py_LIMITED_API is set"
#      endif
#    endif
#  else
#    include <pyconfig.h>
#    if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#  endif
#endif

#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47
#define _CFFI_PRIM_FLOATCOMPLEX 48
#define _CFFI_PRIM_DOUBLECOMPLEX 49
#define _CFFI_PRIM_CHAR16       50
#define _CFFI_PRIM_CHAR32       51

#define _CFFI__NUM_PRIM         52
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
# define _cffi_float_complex_t   _Fcomplex    /* include <complex.h> for it */
# define _cffi_double_complex_t  _Dcomplex    /* include <complex.h> for it */
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
# define _cffi_float_complex_t   float _Complex
# define _cffi_double_complex_t  double _Complex
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong
#define _cffi_from_c__Bool PyBool_FromLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((_cffi_wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(_cffi_wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
                    PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _cffi_to_c_wchar3216_t                                           \
    ((int(*)(PyObject *))_cffi_exports[26])
#define _cffi_from_c_wchar3216_t                                         \
    ((PyObject *(*)(int))_cffi_exports[27])
#define _CFFI_NUM_EXPORTS 28

struct _cffi_ctypedescr;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (struct _cffi_ctypedescr *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}


#ifdef HAVE_WCHAR_H
typedef wchar_t _cffi_wchar_t;
#else
typedef uint16_t _cffi_wchar_t;   /* same random pick as _cffi_backend.c */
#endif

_CFFI_UNUSED_FN static uint16_t _cffi_to_c_char16_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return (uint16_t)_cffi_to_c_wchar_t(o);
    else
        return (uint16_t)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char16_t(uint16_t x)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

_CFFI_UNUSED_FN static int _cffi_to_c_char32_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return (int)_cffi_to_c_wchar_t(o);
    else
        return (int)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char32_t(unsigned int x)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

union _cffi_union_alignment_u {
    unsigned char m_char;
    unsigned short m_short;
    unsigned int m_int;
    unsigned long m_long;
    unsigned long long m_longlong;
    float m_float;
    double m_double;
    long double m_longdouble;
};

struct _cffi_freeme_s {
    struct _cffi_freeme_s *next;
    union _cffi_union_alignment_u alignment;
};

_CFFI_UNUSED_FN static int
_cffi_convert_array_argument(struct _cffi_ctypedescr *ctptr, PyObject *arg,
                             char **output_data, Py_ssize_t datasize,
                             struct _cffi_freeme_s **freeme)
{
    char *p;
    if (datasize < 0)
        return -1;

    p = *output_data;
    if (p == NULL) {
        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc(
            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize);
        if (fp == NULL)
            return -1;
        fp->next = *freeme;
        *freeme = fp;
        p = *output_data = (char *)&fp->alignment;
    }
    memset((void *)p, 0, (size_t)datasize);
    return _cffi_convert_array_from_object(p, ctptr, arg);
}

_CFFI_UNUSED_FN static void
_cffi_free_array_arguments(struct _cffi_freeme_s *freeme)
{
    do {
        void *p = (void *)freeme;
        freeme = freeme->next;
        PyObject_Free(p);
    } while (freeme != NULL);
}

/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

/************************************************************/


#include <ctype.h>
#include <float.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(_WIN32) || defined(_WIN64)
#define AMP_CAPI __declspec(dllexport)
#else
#define AMP_CAPI
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

typedef struct {
    int *boundaries;
    int *trig_indices;
    int8_t *gate_bool;
    int8_t *drone_bool;
    size_t boundary_cap;
    size_t trig_cap;
    size_t bool_cap;
} envelope_scratch_t;

static envelope_scratch_t envelope_scratch = { NULL, NULL, NULL, NULL, 0, 0, 0 };
/* Debug: track last allocation element count for diagnostics. */
static size_t amp_last_alloc_count = 0;

AMP_CAPI size_t amp_last_alloc_count_get(void) {
    return amp_last_alloc_count;
}

/*
 * Edge runner contract (mirrors `_EDGE_RUNNER_CDEF` in Python).
 *
 * The runtime passes node descriptors/inputs to `amp_run_node`, which may
 * allocate per-node state (returned via `state`) and a heap-owned audio buffer
 * (`out_buffer`).
 *
 * Return codes:
 *   0   -> success
 *  -1   -> allocation failure / invalid contract usage
 *  -3   -> unsupported node kind (caller should fall back to Python)
 */
typedef struct {
    uint32_t has_audio;
    uint32_t batches;
    uint32_t channels;
    uint32_t frames;
    const double *data;
} EdgeRunnerAudioView;

typedef struct {
    const char *name;
    uint32_t batches;
    uint32_t channels;
    uint32_t frames;
    const double *data;
} EdgeRunnerParamView;

typedef struct {
    uint32_t count;
    EdgeRunnerParamView *items;
} EdgeRunnerParamSet;

typedef struct {
    EdgeRunnerAudioView audio;
    EdgeRunnerParamSet params;
} EdgeRunnerNodeInputs;

typedef struct {
    const char *name;
    size_t name_len;
    const char *type_name;
    size_t type_len;
    const char *params_json;
    size_t params_len;
} EdgeRunnerNodeDescriptor;

typedef struct {
    char *name;
    uint32_t name_len;
    uint32_t offset;
    uint32_t span;
} EdgeRunnerCompiledParam;

typedef struct {
    char *name;
    uint32_t name_len;
    uint32_t function_id;
    uint32_t audio_offset;
    uint32_t audio_span;
    uint32_t param_count;
    EdgeRunnerCompiledParam *params;
} EdgeRunnerCompiledNode;

typedef struct {
    uint32_t version;
    uint32_t node_count;
    EdgeRunnerCompiledNode *nodes;
} EdgeRunnerCompiledPlan;

typedef struct {
    char *name;
    uint32_t name_len;
    double *values;
    uint32_t value_count;
    double timestamp;
} EdgeRunnerControlCurve;

typedef struct {
    uint32_t frames_hint;
    uint32_t curve_count;
    EdgeRunnerControlCurve *curves;
} EdgeRunnerControlHistory;

static void destroy_compiled_plan(EdgeRunnerCompiledPlan *plan) {
    if (plan == NULL) {
        return;
    }
    if (plan->nodes != NULL) {
        for (uint32_t i = 0; i < plan->node_count; ++i) {
            EdgeRunnerCompiledNode *node = &plan->nodes[i];
            if (node->params != NULL) {
                for (uint32_t j = 0; j < node->param_count; ++j) {
                    EdgeRunnerCompiledParam *param = &node->params[j];
                    if (param->name != NULL) {
                        free(param->name);
                        param->name = NULL;
                    }
                }
                free(node->params);
                node->params = NULL;
            }
            if (node->name != NULL) {
                free(node->name);
                node->name = NULL;
            }
        }
        free(plan->nodes);
        plan->nodes = NULL;
    }
    free(plan);
}

static int read_u32_le(const uint8_t **cursor, size_t *remaining, uint32_t *out_value) {
    if (cursor == NULL || remaining == NULL || out_value == NULL) {
        return 0;
    }
    if (*remaining < 4) {
        return 0;
    }
    const uint8_t *ptr = *cursor;
    *out_value = (uint32_t)ptr[0]
        | ((uint32_t)ptr[1] << 8)
        | ((uint32_t)ptr[2] << 16)
        | ((uint32_t)ptr[3] << 24);
    *cursor += 4;
    *remaining -= 4;
    return 1;
}

AMP_CAPI EdgeRunnerCompiledPlan *amp_load_compiled_plan(
    const uint8_t *descriptor_blob,
    size_t descriptor_len,
    const uint8_t *plan_blob,
    size_t plan_len
) {
    _log_native_call("amp_load_compiled_plan", descriptor_len, plan_len);
    if (descriptor_blob == NULL || plan_blob == NULL) {
        return NULL;
    }
    if (descriptor_len < 4 || plan_len < 12) {
        return NULL;
    }

    const uint8_t *descriptor_cursor = descriptor_blob;
    size_t descriptor_remaining = descriptor_len;
    uint32_t descriptor_count = 0;
    if (!read_u32_le(&descriptor_cursor, &descriptor_remaining, &descriptor_count)) {
        return NULL;
    }

    const uint8_t *cursor = plan_blob;
    size_t remaining = plan_len;
    if (remaining < 4) {
        return NULL;
    }
    if (cursor[0] != 'A' || cursor[1] != 'M' || cursor[2] != 'P' || cursor[3] != 'L') {
        return NULL;
    }
    cursor += 4;
    remaining -= 4;

    uint32_t version = 0;
    uint32_t node_count = 0;
    if (!read_u32_le(&cursor, &remaining, &version) || !read_u32_le(&cursor, &remaining, &node_count)) {
        return NULL;
    }
    if (descriptor_count != node_count) {
        return NULL;
    }

    EdgeRunnerCompiledPlan *plan = (EdgeRunnerCompiledPlan *)calloc(1, sizeof(EdgeRunnerCompiledPlan));
    if (plan == NULL) {
        return NULL;
    }
    plan->version = version;
    plan->node_count = node_count;

    if (node_count == 0) {
        if (remaining != 0) {
            destroy_compiled_plan(plan);
            return NULL;
        }
        return plan;
    }

    plan->nodes = (EdgeRunnerCompiledNode *)calloc(node_count, sizeof(EdgeRunnerCompiledNode));
    if (plan->nodes == NULL) {
        destroy_compiled_plan(plan);
        return NULL;
    }

    for (uint32_t idx = 0; idx < node_count; ++idx) {
        EdgeRunnerCompiledNode *node = &plan->nodes[idx];
        uint32_t function_id = 0;
        uint32_t name_len = 0;
        uint32_t audio_offset = 0;
        uint32_t audio_span = 0;
        uint32_t param_count = 0;
        if (!read_u32_le(&cursor, &remaining, &function_id)
            || !read_u32_le(&cursor, &remaining, &name_len)
            || !read_u32_le(&cursor, &remaining, &audio_offset)
            || !read_u32_le(&cursor, &remaining, &audio_span)
            || !read_u32_le(&cursor, &remaining, &param_count)) {
            destroy_compiled_plan(plan);
            return NULL;
        }
        if (remaining < name_len) {
            destroy_compiled_plan(plan);
            return NULL;
        }
        node->name = (char *)malloc((size_t)name_len + 1);
        if (node->name == NULL) {
            destroy_compiled_plan(plan);
            return NULL;
        }
        memcpy(node->name, cursor, name_len);
        node->name[name_len] = '\0';
        node->name_len = name_len;
        cursor += name_len;
        remaining -= name_len;
        node->function_id = function_id;
        node->audio_offset = audio_offset;
        node->audio_span = audio_span;
        node->param_count = param_count;
        if (param_count > 0) {
            node->params = (EdgeRunnerCompiledParam *)calloc(param_count, sizeof(EdgeRunnerCompiledParam));
            if (node->params == NULL) {
                destroy_compiled_plan(plan);
                return NULL;
            }
        }
        for (uint32_t param_idx = 0; param_idx < param_count; ++param_idx) {
            EdgeRunnerCompiledParam *param = &node->params[param_idx];
            uint32_t param_name_len = 0;
            uint32_t param_offset = 0;
            uint32_t param_span = 0;
            if (!read_u32_le(&cursor, &remaining, &param_name_len)
                || !read_u32_le(&cursor, &remaining, &param_offset)
                || !read_u32_le(&cursor, &remaining, &param_span)) {
                destroy_compiled_plan(plan);
                return NULL;
            }
            if (remaining < param_name_len) {
                destroy_compiled_plan(plan);
                return NULL;
            }
            param->name = (char *)malloc((size_t)param_name_len + 1);
            if (param->name == NULL) {
                destroy_compiled_plan(plan);
                return NULL;
            }
            memcpy(param->name, cursor, param_name_len);
            param->name[param_name_len] = '\0';
            param->name_len = param_name_len;
            param->offset = param_offset;
            param->span = param_span;
            cursor += param_name_len;
            remaining -= param_name_len;
        }
    }

    if (remaining != 0) {
        destroy_compiled_plan(plan);
        return NULL;
    }

    return plan;
}

AMP_CAPI void amp_release_compiled_plan(EdgeRunnerCompiledPlan *plan) {
    _log_native_call("amp_release_compiled_plan", (size_t)(plan != NULL), 0);
    destroy_compiled_plan(plan);
}

static void destroy_control_history(EdgeRunnerControlHistory *history) {
    if (history == NULL) {
        return;
    }
    if (history->curves != NULL) {
        for (uint32_t i = 0; i < history->curve_count; ++i) {
            EdgeRunnerControlCurve *curve = &history->curves[i];
            if (curve->name != NULL) {
                free(curve->name);
                curve->name = NULL;
            }
            if (curve->values != NULL) {
                free(curve->values);
                curve->values = NULL;
            }
            curve->value_count = 0;
        }
        free(history->curves);
        history->curves = NULL;
    }
    free(history);
}

static const EdgeRunnerControlCurve *find_history_curve(
    const EdgeRunnerControlHistory *history,
    const char *name,
    size_t name_len
) {
    if (history == NULL || name == NULL || name_len == 0) {
        return NULL;
    }
    for (uint32_t i = 0; i < history->curve_count; ++i) {
        const EdgeRunnerControlCurve *curve = &history->curves[i];
        if (curve->name_len == name_len && curve->name != NULL && strncmp(curve->name, name, name_len) == 0) {
            return curve;
        }
    }
    return NULL;
}

static void apply_history_curve(
    double *dest,
    int batches,
    int frames,
    const EdgeRunnerControlCurve *curve
) {
    if (dest == NULL || curve == NULL || curve->values == NULL || curve->value_count == 0) {
        return;
    }
    int count = (int)curve->value_count;
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    for (int b = 0; b < batches; ++b) {
        for (int f = 0; f < frames; ++f) {
            double value = 0.0;
            if (count >= frames) {
                if (f < count) {
                    value = curve->values[f];
                } else {
                    value = curve->values[count - 1];
                }
            } else if (count == 1) {
                value = curve->values[0];
            } else {
                if (f < count) {
                    value = curve->values[f];
                } else {
                    value = curve->values[count - 1];
                }
            }
            dest[((size_t)b * (size_t)frames) + (size_t)f] = value;
        }
    }
}

AMP_CAPI EdgeRunnerControlHistory *amp_load_control_history(
    const uint8_t *blob,
    size_t blob_len,
    int frames_hint
) {
    _log_native_call("amp_load_control_history", blob_len, (size_t)frames_hint);
    if (blob == NULL || blob_len < 8) {
        return NULL;
    }
    const uint8_t *cursor = blob;
    size_t remaining = blob_len;
    uint32_t event_count = 0;
    uint32_t key_count = 0;
    if (!read_u32_le(&cursor, &remaining, &event_count) || !read_u32_le(&cursor, &remaining, &key_count)) {
        return NULL;
    }
    EdgeRunnerControlHistory *history = (EdgeRunnerControlHistory *)calloc(1, sizeof(EdgeRunnerControlHistory));
    if (history == NULL) {
        return NULL;
    }
    history->frames_hint = frames_hint > 0 ? (uint32_t)frames_hint : 0U;
    history->curve_count = key_count;
    if (key_count > 0) {
        history->curves = (EdgeRunnerControlCurve *)calloc(key_count, sizeof(EdgeRunnerControlCurve));
        if (history->curves == NULL) {
            destroy_control_history(history);
            return NULL;
        }
    }
    if (key_count == 0) {
        return history;
    }
    uint32_t *name_lengths = (uint32_t *)calloc(key_count, sizeof(uint32_t));
    if (name_lengths == NULL) {
        destroy_control_history(history);
        return NULL;
    }
    for (uint32_t i = 0; i < key_count; ++i) {
        if (!read_u32_le(&cursor, &remaining, &name_lengths[i])) {
            free(name_lengths);
            destroy_control_history(history);
            return NULL;
        }
    }
    for (uint32_t i = 0; i < key_count; ++i) {
        uint32_t name_len = name_lengths[i];
        if (remaining < name_len) {
            free(name_lengths);
            destroy_control_history(history);
            return NULL;
        }
        EdgeRunnerControlCurve *curve = &history->curves[i];
        curve->name = (char *)malloc((size_t)name_len + 1);
        if (curve->name == NULL) {
            free(name_lengths);
            destroy_control_history(history);
            return NULL;
        }
        memcpy(curve->name, cursor, name_len);
        curve->name[name_len] = '\0';
        curve->name_len = name_len;
        curve->value_count = 0;
        curve->values = NULL;
        curve->timestamp = -DBL_MAX;
        cursor += name_len;
        remaining -= name_len;
    }
    free(name_lengths);
    for (uint32_t event_idx = 0; event_idx < event_count; ++event_idx) {
        if (remaining < sizeof(double)) {
            destroy_control_history(history);
            return NULL;
        }
        double timestamp = 0.0;
        memcpy(&timestamp, cursor, sizeof(double));
        cursor += sizeof(double);
        remaining -= sizeof(double);
        for (uint32_t key_idx = 0; key_idx < key_count; ++key_idx) {
            uint32_t value_count = 0;
            if (!read_u32_le(&cursor, &remaining, &value_count)) {
                destroy_control_history(history);
                return NULL;
            }
            double *values_copy = NULL;
            if (value_count > 0) {
                size_t bytes = (size_t)value_count * sizeof(double);
                if (remaining < bytes) {
                    destroy_control_history(history);
                    return NULL;
                }
                values_copy = (double *)malloc(bytes);
                if (values_copy == NULL) {
                    destroy_control_history(history);
                    return NULL;
                }
                memcpy(values_copy, cursor, bytes);
                cursor += bytes;
                remaining -= bytes;
            }
            EdgeRunnerControlCurve *curve = &history->curves[key_idx];
            if (value_count > 0 && (curve->values == NULL || timestamp >= curve->timestamp)) {
                if (curve->values != NULL) {
                    free(curve->values);
                }
                curve->values = values_copy;
                curve->value_count = value_count;
                curve->timestamp = timestamp;
                values_copy = NULL;
            }
            if (values_copy != NULL) {
                free(values_copy);
            }
        }
    }
    return history;
}

AMP_CAPI void amp_release_control_history(EdgeRunnerControlHistory *history) {
    destroy_control_history(history);
}

static int envelope_reserve_scratch(int F) {
    size_t needed_boundaries = (size_t)(4 * F + 4);
    size_t needed_trig = (size_t)(F > 0 ? F : 1);
    size_t needed_bool = (size_t)(F > 0 ? F : 1);

    if (envelope_scratch.boundary_cap < needed_boundaries) {
        int *new_boundaries = (int *)realloc(envelope_scratch.boundaries, needed_boundaries * sizeof(int));
        if (new_boundaries == NULL) {
            return 0;
        }
        envelope_scratch.boundaries = new_boundaries;
        envelope_scratch.boundary_cap = needed_boundaries;
    }

    if (envelope_scratch.trig_cap < needed_trig) {
        int *new_trig = (int *)realloc(envelope_scratch.trig_indices, needed_trig * sizeof(int));
        if (new_trig == NULL) {
            return 0;
        }
        envelope_scratch.trig_indices = new_trig;
        envelope_scratch.trig_cap = needed_trig;
    }

    if (envelope_scratch.bool_cap < needed_bool) {
        int8_t *gate_ptr = envelope_scratch.gate_bool;
        int8_t *drone_ptr = envelope_scratch.drone_bool;
        int8_t *new_gate = (int8_t *)realloc(gate_ptr, needed_bool * sizeof(int8_t));
        int8_t *new_drone = (int8_t *)realloc(drone_ptr, needed_bool * sizeof(int8_t));
        if (new_gate == NULL || new_drone == NULL) {
            if (new_gate != NULL) {
                envelope_scratch.gate_bool = new_gate;
            }
            if (new_drone != NULL) {
                envelope_scratch.drone_bool = new_drone;
            }
            return 0;
        }
        envelope_scratch.gate_bool = new_gate;
        envelope_scratch.drone_bool = new_drone;
        envelope_scratch.bool_cap = needed_bool;
    }

    return 1;
}

void lfo_slew(const double* x, double* out, int B, int F, double r, double alpha, double* z0) {
    for (int b = 0; b < B; ++b) {
        double state = 0.0;
        if (z0 != NULL) state = z0[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            double xi = x[base + i];
            state = r * state + alpha * xi;
            out[base + i] = state;
        }
        if (z0 != NULL) z0[b] = state;
    }
}

void safety_filter(const double* x, double* y, int B, int C, int F, double a, double* prev_in, double* prev_dc) {
    for (int b = 0; b < B; ++b) {
        for (int c = 0; c < C; ++c) {
            int chan = b * C + c;
            double pi = 0.0;
            double pd = 0.0;
            if (prev_in != NULL) pi = prev_in[chan];
            if (prev_dc != NULL) pd = prev_dc[chan];
            int base = chan * F;
            for (int i = 0; i < F; ++i) {
                double xin = x[base + i];
                double diff;
                if (i == 0) diff = xin - pi;
                else diff = xin - x[base + i - 1];
                pd = a * pd + diff;
                y[base + i] = pd;
            }
            if (prev_in != NULL) prev_in[chan] = x[base + F - 1];
            if (prev_dc != NULL) prev_dc[chan] = y[base + F - 1];
        }
    }
}

void dc_block(const double* x, double* out, int B, int C, int F, double a, double* state) {
    for (int b = 0; b < B; ++b) {
        for (int c = 0; c < C; ++c) {
            int chan = b * C + c;
            double dc = 0.0;
            if (state != NULL) dc = state[chan];
            int base = chan * F;
            for (int i = 0; i < F; ++i) {
                double xin = x[base + i];
                dc = a * dc + (1.0 - a) * xin;
                out[base + i] = xin - dc;
            }
            if (state != NULL) state[chan] = dc;
        }
    }
}

void subharmonic_process(
    const double* x,
    double* y,
    int B,
    int C,
    int F,
    double a_hp_in,
    double a_lp_in,
    double a_sub2,
    int use_div4,
    double a_sub4,
    double a_env_attack,
    double a_env_release,
    double a_hp_out,
    double drive,
    double mix,
    double* hp_y,
    double* lp_y,
    double* prev,
    int8_t* sign,
    int8_t* ff2,
    int8_t* ff4,
    int32_t* ff4_count,
    double* sub2_lp,
    double* sub4_lp,
    double* env,
    double* hp_out_y,
    double* hp_out_x
) {
    // Layout: arrays are flattened per-channel: index = (b*C + c) * F + t
    for (int t = 0; t < F; ++t) {
        for (int b = 0; b < B; ++b) {
            for (int c = 0; c < C; ++c) {
                int chan = b * C + c;
                int base = chan * F;
                double xt = x[base + t];

                // Bandpass driver: simple HP then LP
                double hp_y_val = hp_y[chan];
                double prev_val = prev[chan];
                double lp_y_val = lp_y[chan];
                double hp_in = a_hp_in * (hp_y_val + xt - prev_val);
                hp_y[chan] = hp_in;
                prev[chan] = xt;
                double bp = lp_y_val + a_lp_in * (hp_in - lp_y_val);
                lp_y[chan] = bp;

                // env
                double abs_bp = fabs(bp);
                double env_val = env[chan];
                if (abs_bp > env_val) env_val = env_val + a_env_attack * (abs_bp - env_val);
                else env_val = env_val + a_env_release * (abs_bp - env_val);
                env[chan] = env_val;

                // sign and flip-flops
                int8_t prev_sign = sign[chan];
                int8_t sign_now = (bp > 0.0) ? 1 : -1;
                int pos_zc = (prev_sign < 0) && (sign_now > 0);
                sign[chan] = sign_now;

                if (pos_zc) ff2[chan] = -ff2[chan];

                if (use_div4) {
                    if (pos_zc) ff4_count[chan] = ff4_count[chan] + 1;
                    int toggle4 = (pos_zc && (ff4_count[chan] >= 2));
                    if (toggle4) ff4[chan] = -ff4[chan];
                    if (toggle4) ff4_count[chan] = 0;
                }

                double sq2 = (double) ff2[chan];
                double sub2_lp_val = sub2_lp[chan];
                sub2_lp_val = sub2_lp_val + a_sub2 * (sq2 - sub2_lp_val);
                sub2_lp[chan] = sub2_lp_val;
                double sub_val = sub2_lp_val;

                if (use_div4) {
                    double sq4 = (double) ff4[chan];
                    double sub4_lp_val = sub4_lp[chan];
                    sub4_lp_val = sub4_lp_val + a_sub4 * (sq4 - sub4_lp_val);
                    sub4_lp[chan] = sub4_lp_val;
                    sub_val = sub_val + 0.6 * sub4_lp_val;
                }

                double sub = tanh(drive * sub_val) * (env_val + 1e-6);

                double dry = xt;
                double wet = sub;
                double out_t = (1.0 - mix) * dry + mix * wet;

                double y_prev = hp_out_y[chan];
                double x_prev = hp_out_x[chan];
                double hp = a_hp_out * (y_prev + out_t - x_prev);
                hp_out_y[chan] = hp;
                hp_out_x[chan] = out_t;
                y[base + t] = hp;
            }
        }
    }
}

static void envelope_start_attack(
    int index,
    const double* velocity,
    int send_resets,
    double* reset_line,
    int* stage,
    double* timer,
    double* value,
    double* vel_state,
    double* release_start,
    int64_t* activations
) {
    double vel = velocity[index];
    if (vel < 0.0) vel = 0.0;
    *stage = 1;
    *timer = 0.0;
    *value = 0.0;
    *vel_state = vel;
    *release_start = vel;
    *activations += 1;
    if (send_resets && reset_line != NULL) {
        reset_line[index] = 1.0;
    }
}

static void envelope_process_simple(
    const double* trigger,
    const double* gate,
    const double* drone,
    const double* velocity,
    int B,
    int F,
    int atk_frames,
    int hold_frames,
    int dec_frames,
    int sus_frames,
    int rel_frames,
    double sustain_level,
    int send_resets,
    int* stage,
    double* value,
    double* timer,
    double* vel_state,
    int64_t* activations,
    double* release_start,
    double* amp_out,
    double* reset_out
) {
    for (int b = 0; b < B; ++b) {
        int st = stage[b];
        double val = value[b];
        double tim = timer[b];
        double vel = vel_state[b];
        int64_t acts = activations[b];
        double rel_start = release_start[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            int idx = base + i;
            int trig = trigger[idx] > 0.5 ? 1 : 0;
            int gate_on = gate[idx] > 0.5 ? 1 : 0;
            int drone_on = drone[idx] > 0.5 ? 1 : 0;

            if (trig) {
                envelope_start_attack(i, velocity + base, send_resets, reset_out != NULL ? reset_out + base : NULL, &st, &tim, &val, &vel, &rel_start, &acts);
            } else if (st == 0 && (gate_on || drone_on)) {
                envelope_start_attack(i, velocity + base, send_resets, reset_out != NULL ? reset_out + base : NULL, &st, &tim, &val, &vel, &rel_start, &acts);
            }

            if (st == 1) {
                if (atk_frames <= 0) {
                    val = vel;
                    if (hold_frames > 0) st = 2;
                    else if (dec_frames > 0) st = 3;
                    else st = 4;
                    tim = 0.0;
                } else {
                    val += vel / (double)(atk_frames > 0 ? atk_frames : 1);
                    if (val > vel) val = vel;
                    tim += 1.0;
                    if (tim >= atk_frames) {
                        val = vel;
                        if (hold_frames > 0) st = 2;
                        else if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                    }
                }
            } else if (st == 2) {
                val = vel;
                if (hold_frames <= 0) {
                    if (dec_frames > 0) st = 3;
                    else st = 4;
                    tim = 0.0;
                } else {
                    tim += 1.0;
                    if (tim >= hold_frames) {
                        if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                    }
                }
            } else if (st == 3) {
                double target = vel * sustain_level;
                if (dec_frames <= 0) {
                    val = target;
                    st = 4;
                    tim = 0.0;
                } else {
                    double delta = (vel - target) / (double)(dec_frames > 0 ? dec_frames : 1);
                    double candidate = val - delta;
                    if (candidate < target) candidate = target;
                    val = candidate;
                    tim += 1.0;
                    if (tim >= dec_frames) {
                        val = target;
                        st = 4;
                        tim = 0.0;
                    }
                }
            } else if (st == 4) {
                val = vel * sustain_level;
                if (sus_frames > 0) {
                    tim += 1.0;
                    if (tim >= sus_frames) {
                        st = 5;
                        rel_start = val;
                        tim = 0.0;
                    }
                } else if (!gate_on && !drone_on) {
                    st = 5;
                    rel_start = val;
                    tim = 0.0;
                }
            } else if (st == 5) {
                if (rel_frames <= 0) {
                    val = 0.0;
                    st = 0;
                    tim = 0.0;
                } else {
                    double step = rel_start / (double)(rel_frames > 0 ? rel_frames : 1);
                    double candidate = val - step;
                    if (candidate < 0.0) candidate = 0.0;
                    val = candidate;
                    tim += 1.0;
                    if (tim >= rel_frames) {
                        val = 0.0;
                        st = 0;
                        tim = 0.0;
                    }
                }
                if (gate_on || drone_on) {
                    envelope_start_attack(i, velocity + base, send_resets, reset_out != NULL ? reset_out + base : NULL, &st, &tim, &val, &vel, &rel_start, &acts);
                }
            }

            if (val < 0.0) val = 0.0;
            amp_out[idx] = val;
        }
        stage[b] = st;
        value[b] = val;
        timer[b] = tim;
        vel_state[b] = vel;
        activations[b] = acts;
        release_start[b] = rel_start;
    }
}

void envelope_process(
    const double* trigger,
    const double* gate,
    const double* drone,
    const double* velocity,
    int B,
    int F,
    int atk_frames,
    int hold_frames,
    int dec_frames,
    int sus_frames,
    int rel_frames,
    double sustain_level,
    int send_resets,
    int* stage,
    double* value,
    double* timer,
    double* vel_state,
    int64_t* activations,
    double* release_start,
    double* amp_out,
    double* reset_out
) {
    if (reset_out != NULL) {
        size_t total = (size_t)B * (size_t)F;
        memset(reset_out, 0, total * sizeof(double));
    }
    if (B <= 0 || F <= 0) {
        return;
    }

    if (!envelope_reserve_scratch(F)) {
        envelope_process_simple(
            trigger,
            gate,
            drone,
            velocity,
            B,
            F,
            atk_frames,
            hold_frames,
            dec_frames,
            sus_frames,
            rel_frames,
            sustain_level,
            send_resets,
            stage,
            value,
            timer,
            vel_state,
            activations,
            release_start,
            amp_out,
            reset_out
        );
        return;
    }

    int* boundaries = envelope_scratch.boundaries;
    int* trig_indices = envelope_scratch.trig_indices;
    int8_t* gate_bool = envelope_scratch.gate_bool;
    int8_t* drone_bool = envelope_scratch.drone_bool;

    for (int b = 0; b < B; ++b) {
        int st = stage[b];
        double val = value[b];
        double tim = timer[b];
        double vel = vel_state[b];
        int64_t acts = activations[b];
        double rel_start = release_start[b];

        const double* trig_line = trigger + b * F;
        const double* gate_line = gate + b * F;
        const double* drone_line = drone + b * F;
        const double* vel_line = velocity + b * F;
        double* amp_line = amp_out + b * F;
        double* reset_line = reset_out != NULL ? reset_out + b * F : NULL;

        int trig_count = 0;
        for (int i = 0; i < F; ++i) {
            if (trig_line[i] > 0.5) {
                trig_indices[trig_count++] = i;
            }
            gate_bool[i] = gate_line[i] > 0.5 ? 1 : 0;
            drone_bool[i] = drone_line[i] > 0.5 ? 1 : 0;
        }

        int boundary_count = 0;
        boundaries[boundary_count++] = 0;
        boundaries[boundary_count++] = F;
        for (int i = 0; i < trig_count; ++i) {
            boundaries[boundary_count++] = trig_indices[i];
        }
        for (int i = 1; i < F; ++i) {
            if (gate_bool[i] != gate_bool[i - 1]) {
                boundaries[boundary_count++] = i;
            }
            if (drone_bool[i] != drone_bool[i - 1]) {
                boundaries[boundary_count++] = i;
            }
        }

        for (int i = 1; i < boundary_count; ++i) {
            int key = boundaries[i];
            int j = i - 1;
            while (j >= 0 && boundaries[j] > key) {
                boundaries[j + 1] = boundaries[j];
                --j;
            }
            boundaries[j + 1] = key;
        }

        int unique_count = 0;
        for (int i = 0; i < boundary_count; ++i) {
            int val_b = boundaries[i];
            if (val_b < 0) val_b = 0;
            if (val_b > F) val_b = F;
            if (unique_count == 0 || boundaries[unique_count - 1] != val_b) {
                boundaries[unique_count++] = val_b;
            }
        }
        if (unique_count < 2) {
            boundaries[0] = 0;
            boundaries[1] = F;
            unique_count = 2;
        }

        int trig_ptr = 0;
        for (int seg = 0; seg < unique_count - 1; ++seg) {
            int start = boundaries[seg];
            int stop = boundaries[seg + 1];
            if (start >= F) {
                break;
            }
            if (stop > F) {
                stop = F;
            }
            if (stop <= start) {
                continue;
            }

            while (trig_ptr < trig_count && trig_indices[trig_ptr] == start) {
                envelope_start_attack(
                    start,
                    vel_line,
                    send_resets,
                    reset_line,
                    &st,
                    &tim,
                    &val,
                    &vel,
                    &rel_start,
                    &acts
                );
                trig_ptr++;
            }

            int t = start;
            while (t < stop) {
                int gate_on = (gate_bool[t] != 0) || (drone_bool[t] != 0);

                int changed = 1;
                while (changed) {
                    changed = 0;
                    if (st == 1 && atk_frames <= 0) {
                        val = vel;
                        if (hold_frames > 0) st = 2;
                        else if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                        changed = 1;
                        continue;
                    }
                    if (st == 2 && hold_frames <= 0) {
                        if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                        changed = 1;
                        continue;
                    }
                    if (st == 3 && dec_frames <= 0) {
                        val = vel * sustain_level;
                        st = 4;
                        tim = 0.0;
                        changed = 1;
                        continue;
                    }
                    if (st == 5 && rel_frames <= 0) {
                        val = 0.0;
                        st = 0;
                        tim = 0.0;
                        changed = 1;
                        continue;
                    }
                }

                if (st == 0) {
                    if (gate_on) {
                        envelope_start_attack(
                            t,
                            vel_line,
                            send_resets,
                            reset_line,
                            &st,
                            &tim,
                            &val,
                            &vel,
                            &rel_start,
                            &acts
                        );
                        continue;
                    }
                    int seg_len = stop - t;
                    for (int k = 0; k < seg_len; ++k) {
                        amp_line[t + k] = 0.0;
                    }
                    val = 0.0;
                    tim = 0.0;
                    t = stop;
                    continue;
                }

                if (st == 1) {
                    if (atk_frames <= 0) {
                        continue;
                    }
                    int remaining = atk_frames - (int)tim;
                    if (remaining <= 0) remaining = 1;
                    int seg_len = stop - t;
                    if (seg_len > remaining) seg_len = remaining;
                    if (seg_len <= 0) {
                        t = stop;
                        continue;
                    }
                    double step = vel / (atk_frames > 0 ? (double)atk_frames : 1.0);
                    for (int k = 0; k < seg_len; ++k) {
                        double sample = val + step * (double)(k + 1);
                        if (vel >= 0.0 && sample > vel) sample = vel;
                        if (sample < 0.0) sample = 0.0;
                        amp_line[t + k] = sample;
                    }
                    val = amp_line[t + seg_len - 1];
                    tim += (double)seg_len;
                    if (atk_frames > 0 && tim >= atk_frames) {
                        val = vel;
                        if (hold_frames > 0) st = 2;
                        else if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                    }
                    t += seg_len;
                    continue;
                }

                if (st == 2) {
                    if (hold_frames <= 0) {
                        continue;
                    }
                    int remaining = hold_frames - (int)tim;
                    if (remaining <= 0) remaining = 1;
                    int seg_len = stop - t;
                    if (seg_len > remaining) seg_len = remaining;
                    if (seg_len <= 0) {
                        t = stop;
                        continue;
                    }
                    for (int k = 0; k < seg_len; ++k) {
                        amp_line[t + k] = vel;
                    }
                    val = vel;
                    tim += (double)seg_len;
                    if (tim >= hold_frames) {
                        if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                    }
                    t += seg_len;
                    continue;
                }

                if (st == 3) {
                    if (dec_frames <= 0) {
                        continue;
                    }
                    int remaining = dec_frames - (int)tim;
                    if (remaining <= 0) remaining = 1;
                    int seg_len = stop - t;
                    if (seg_len > remaining) seg_len = remaining;
                    if (seg_len <= 0) {
                        t = stop;
                        continue;
                    }
                    double target = vel * sustain_level;
                    double delta = (vel - target) / (dec_frames > 0 ? (double)dec_frames : 1.0);
                    for (int k = 0; k < seg_len; ++k) {
                        double sample = val - delta * (double)(k + 1);
                        if (sample < target) sample = target;
                        if (sample < 0.0) sample = 0.0;
                        amp_line[t + k] = sample;
                    }
                    val = amp_line[t + seg_len - 1];
                    tim += (double)seg_len;
                    if (tim >= dec_frames) {
                        val = target;
                        st = 4;
                        tim = 0.0;
                    }
                    t += seg_len;
                    continue;
                }

                if (st == 4) {
                    double sustain_val = vel * sustain_level;
                    if (sus_frames > 0) {
                        int remaining = sus_frames - (int)tim;
                        if (remaining <= 0) remaining = 1;
                        int seg_len = stop - t;
                        if (seg_len > remaining) seg_len = remaining;
                        if (seg_len <= 0) {
                            t = stop;
                            continue;
                        }
                        for (int k = 0; k < seg_len; ++k) {
                            amp_line[t + k] = sustain_val;
                        }
                        val = sustain_val;
                        tim += (double)seg_len;
                        if (tim >= sus_frames) {
                            st = 5;
                            rel_start = val;
                            tim = 0.0;
                        }
                        t += seg_len;
                        continue;
                    } else {
                        int seg_len = stop - t;
                        if (!gate_on && seg_len > 1) {
                            seg_len = 1;
                        }
                        if (seg_len <= 0) {
                            seg_len = 1;
                            if (t + seg_len > stop) seg_len = stop - t;
                        }
                        if (seg_len <= 0) {
                            break;
                        }
                        for (int k = 0; k < seg_len; ++k) {
                            amp_line[t + k] = sustain_val;
                        }
                        val = sustain_val;
                        if (!gate_on) {
                            st = 5;
                            rel_start = val;
                            tim = 0.0;
                        } else {
                            tim = 0.0;
                        }
                        t += seg_len;
                        continue;
                    }
                }

                if (st == 5) {
                    if (gate_on) {
                        amp_line[t] = 0.0;
                        envelope_start_attack(
                            t,
                            vel_line,
                            send_resets,
                            reset_line,
                            &st,
                            &tim,
                            &val,
                            &vel,
                            &rel_start,
                            &acts
                        );
                        t += 1;
                        continue;
                    }
                    if (rel_frames <= 0) {
                        continue;
                    }
                    int remaining = rel_frames - (int)tim;
                    if (remaining <= 0) remaining = 1;
                    int seg_len = stop - t;
                    if (seg_len > remaining) seg_len = remaining;
                    if (seg_len <= 0) {
                        seg_len = remaining;
                        if (seg_len <= 0) seg_len = 1;
                        if (t + seg_len > stop) seg_len = stop - t;
                        if (seg_len <= 0) {
                            break;
                        }
                    }
                    double step = rel_start / (rel_frames > 0 ? (double)rel_frames : 1.0);
                    for (int k = 0; k < seg_len; ++k) {
                        double sample = val - step * (double)(k + 1);
                        if (sample < 0.0) sample = 0.0;
                        amp_line[t + k] = sample;
                    }
                    val = amp_line[t + seg_len - 1];
                    tim += (double)seg_len;
                    if (tim >= rel_frames) {
                        val = 0.0;
                        st = 0;
                        tim = 0.0;
                    }
                    t += seg_len;
                    continue;
                }

                // Unknown stage -> silence and exit segment.
                for (int k = t; k < stop; ++k) {
                    amp_line[k] = 0.0;
                }
                val = 0.0;
                tim = 0.0;
                st = 0;
                t = stop;
            }
        }

        if (val < 0.0) val = 0.0;
        stage[b] = st;
        value[b] = val;
        timer[b] = tim;
        vel_state[b] = vel;
        activations[b] = acts;
        release_start[b] = rel_start;
    }
}

// Advance phase per frame with optional reset line. dphi and phase_state are arrays of length B*F and B respectively
void phase_advance(const double* dphi, double* phase_out, int B, int F, double* phase_state, const double* reset) {
    for (int b = 0; b < B; ++b) {
        double cur = 0.0;
        if (phase_state != NULL) cur = phase_state[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            if (reset != NULL && reset[base + i] > 0.5) cur = 0.0;
            cur = cur + dphi[base + i];
            // wrap into [0,1)
            cur = cur - floor(cur);
            phase_out[base + i] = cur;
        }
        if (phase_state != NULL) phase_state[b] = cur;
    }
}

// Portamento smoothing: per-frame smoothing with alpha derived from slide_time and slide_damp
void portamento_smooth(const double* freq_target, const double* port_mask, const double* slide_time, const double* slide_damp, int B, int F, int sr, double* freq_state, double* out) {
    for (int b = 0; b < B; ++b) {
        double cur = 0.0;
        if (freq_state != NULL) cur = freq_state[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            double target = freq_target[base + i];
            int active = port_mask != NULL && port_mask[base + i] > 0.5 ? 1 : 0;
            double frames_const = slide_time != NULL ? slide_time[base + i] * (double)sr : 1.0;
            if (frames_const < 1.0) frames_const = 1.0;
            double alpha = exp(-1.0 / frames_const);
            if (slide_damp != NULL) alpha = pow(alpha, 1.0 + fmax(0.0, slide_damp[base + i]));
            if (active) cur = alpha * cur + (1.0 - alpha) * target;
            else cur = target;
            out[base + i] = cur;
        }
        if (freq_state != NULL) freq_state[b] = cur;
    }
}

// Arp advance: write offsets per frame, update step/timer states
void arp_advance(const double* seq, int seq_len, double* offsets_out, int B, int F, int* step_state, int* timer_state, int fps) {
    for (int b = 0; b < B; ++b) {
        int step = 0;
        int timer = 0;
        if (step_state != NULL) step = step_state[b];
        if (timer_state != NULL) timer = timer_state[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            int idx = step % (seq_len > 0 ? seq_len : 1);
            offsets_out[base + i] = seq[idx];
            timer += 1;
            if (timer >= fps) {
                timer = 0;
                step = (step + 1) % (seq_len > 0 ? seq_len : 1);
            }
        }
        if (step_state != NULL) step_state[b] = step;
        if (timer_state != NULL) timer_state[b] = timer;
    }
}

void polyblep_arr(const double* t, const double* dt, double* out, int N) {
    for (int i = 0; i < N; ++i) {
        out[i] = 0.0;
    }
    for (int i = 0; i < N; ++i) {
        double ti = t[i];
        double dti = dt[i];
        if (ti < dti) {
            double x = ti / (dti > 0.0 ? dti : 1e-20);
            out[i] = x + x - x * x - 1.0;
        } else if (ti > 1.0 - dti) {
            double x = (ti - 1.0) / (dti > 0.0 ? dti : 1e-20);
            out[i] = x * x + x + x + 1.0;
        } else {
            out[i] = 0.0;
        }
    }
}

void osc_saw_blep_c(const double* ph, const double* dphi, double* out, int B, int F) {
    int N = B * F;
    for (int i = 0; i < N; ++i) {
        double t = ph[i];
        double y = 2.0 * t - 1.0;
        double pb = 0.0;
        double dti = dphi[i];
        if (t < dti) {
            double x = t / (dti > 0.0 ? dti : 1e-20);
            pb = x + x - x * x - 1.0;
        } else if (t > 1.0 - dti) {
            double x = (t - 1.0) / (dti > 0.0 ? dti : 1e-20);
            pb = x * x + x + x + 1.0;
        }
        out[i] = y - pb;
    }
}

void osc_square_blep_c(const double* ph, const double* dphi, double pw, double* out, int B, int F) {
    int N = B * F;
    for (int i = 0; i < N; ++i) {
        double t = ph[i];
        double y = (t < pw) ? 1.0 : -1.0;
        // subtract polyblep at rising edge
        double pb1 = 0.0;
        double dti = dphi[i];
        if (t < dti) {
            double x = t / (dti > 0.0 ? dti : 1e-20);
            pb1 = x + x - x * x - 1.0;
        } else if (t > 1.0 - dti) {
            double x = (t - 1.0) / (dti > 0.0 ? dti : 1e-20);
            pb1 = x * x + x + x + 1.0;
        }
        // add polyblep at falling edge (t + (1-pw))%1
        double t2 = t + (1.0 - pw);
        if (t2 >= 1.0) t2 -= 1.0;
        double pb2 = 0.0;
        if (t2 < dti) {
            double x = t2 / (dti > 0.0 ? dti : 1e-20);
            pb2 = x + x - x * x - 1.0;
        } else if (t2 > 1.0 - dti) {
            double x = (t2 - 1.0) / (dti > 0.0 ? dti : 1e-20);
            pb2 = x * x + x + x + 1.0;
        }
        out[i] = y - pb1 + pb2;
    }
}

void osc_triangle_blep_c(const double* ph, const double* dphi, double* out, int B, int F, double* tri_state) {
    int N = B * F;
    // Use square -> leaky integrator per-batch sequence
    for (int b = 0; b < B; ++b) {
        double s = 0.0;
        if (tri_state != NULL) s = tri_state[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            double t = ph[base + i];
            // square
            double y = (t < 0.5) ? 1.0 : -1.0;
            // blep corrections around edges
            double dti = dphi[base + i];
            double pb1 = 0.0;
            if (t < dti) {
                double x = t / (dti > 0.0 ? dti : 1e-20);
                pb1 = x + x - x * x - 1.0;
            } else if (t > 1.0 - dti) {
                double x = (t - 1.0) / (dti > 0.0 ? dti : 1e-20);
                pb1 = x * x + x + x + 1.0;
            }
            double t2 = t + 0.5; if (t2 >= 1.0) t2 -= 1.0;
            double pb2 = 0.0;
            if (t2 < dti) {
                double x = t2 / (dti > 0.0 ? dti : 1e-20);
                pb2 = x + x - x * x - 1.0;
            } else if (t2 > 1.0 - dti) {
                double x = (t2 - 1.0) / (dti > 0.0 ? dti : 1e-20);
                pb2 = x * x + x + x + 1.0;
            }
            double sq = y - pb1 + pb2;
            double leak = 0.9995;
            s = leak * s + (1.0 - leak) * sq;
            out[base + i] = s;
        }
        if (tri_state != NULL) tri_state[b] = s;
    }
}

typedef enum {
    NODE_KIND_UNKNOWN = 0,
    NODE_KIND_CONSTANT,
    NODE_KIND_GAIN,
    NODE_KIND_MIX,
    NODE_KIND_SAFETY,
    NODE_KIND_SINE_OSC,
    NODE_KIND_CONTROLLER,
    NODE_KIND_LFO,
    NODE_KIND_ENVELOPE,
    NODE_KIND_PITCH,
    NODE_KIND_OSC,
    NODE_KIND_SUBHARM,
} node_kind_t;

typedef struct {
    node_kind_t kind;
    union {
        struct {
            double value;
            int channels;
        } constant;
        struct {
            int out_channels;
        } mix;
        struct {
            double *state;
            int batches;
            int channels;
            double alpha;
        } safety;
        struct {
            double *phase;
            int batches;
            int channels;
            double base_phase;
        } sine;
        struct {
            double *phase;
            double *phase_buffer;
            double *wave_buffer;
            double *dphi_buffer;
            double *tri_state;
            int batches;
            int channels;
            double base_phase;
            int stereo;
        } osc;
        struct {
            double *slew_state;
            int batches;
            double phase;
        } lfo;
        struct {
            int *stage;
            double *value;
            double *timer;
            double *velocity;
            int64_t *activations;
            double *release_start;
            int batches;
        } envelope;
        struct {
            double *last_freq;
            int batches;
        } pitch;
        struct {
            double *hp_y;
            double *lp_y;
            double *prev;
            int8_t *sign;
            int8_t *ff2;
            int8_t *ff4;
            int32_t *ff4_count;
            double *sub2_lp;
            double *sub4_lp;
            double *env;
            double *hp_out_y;
            double *hp_out_x;
            int batches;
            int channels;
            int use_div4;
        } subharm;
    } u;
} node_state_t;

static void release_node_state(node_state_t *state) {
    if (state == NULL) {
        return;
    }
    if (state->kind == NODE_KIND_SAFETY && state->u.safety.state != NULL) {
        free(state->u.safety.state);
        state->u.safety.state = NULL;
        state->u.safety.batches = 0;
        state->u.safety.channels = 0;
        state->u.safety.alpha = 0.0;
    }
    if (state->kind == NODE_KIND_SINE_OSC && state->u.sine.phase != NULL) {
        free(state->u.sine.phase);
        state->u.sine.phase = NULL;
        state->u.sine.batches = 0;
        state->u.sine.channels = 0;
        state->u.sine.base_phase = 0.0;
    }
    if (state->kind == NODE_KIND_OSC) {
        free(state->u.osc.phase);
        free(state->u.osc.phase_buffer);
        free(state->u.osc.wave_buffer);
        free(state->u.osc.dphi_buffer);
        free(state->u.osc.tri_state);
        state->u.osc.phase = NULL;
        state->u.osc.phase_buffer = NULL;
        state->u.osc.wave_buffer = NULL;
        state->u.osc.dphi_buffer = NULL;
        state->u.osc.tri_state = NULL;
        state->u.osc.batches = 0;
        state->u.osc.channels = 0;
        state->u.osc.stereo = 0;
    }
    if (state->kind == NODE_KIND_LFO) {
        free(state->u.lfo.slew_state);
        state->u.lfo.slew_state = NULL;
        state->u.lfo.batches = 0;
        state->u.lfo.phase = 0.0;
    }
    if (state->kind == NODE_KIND_ENVELOPE) {
        free(state->u.envelope.stage);
        free(state->u.envelope.value);
        free(state->u.envelope.timer);
        free(state->u.envelope.velocity);
        free(state->u.envelope.activations);
        free(state->u.envelope.release_start);
        state->u.envelope.stage = NULL;
        state->u.envelope.value = NULL;
        state->u.envelope.timer = NULL;
        state->u.envelope.velocity = NULL;
        state->u.envelope.activations = NULL;
        state->u.envelope.release_start = NULL;
        state->u.envelope.batches = 0;
    }
    if (state->kind == NODE_KIND_PITCH) {
        free(state->u.pitch.last_freq);
        state->u.pitch.last_freq = NULL;
        state->u.pitch.batches = 0;
    }
    if (state->kind == NODE_KIND_SUBHARM) {
        free(state->u.subharm.hp_y);
        free(state->u.subharm.lp_y);
        free(state->u.subharm.prev);
        free(state->u.subharm.sign);
        free(state->u.subharm.ff2);
        free(state->u.subharm.ff4);
        free(state->u.subharm.ff4_count);
        free(state->u.subharm.sub2_lp);
        free(state->u.subharm.sub4_lp);
        free(state->u.subharm.env);
        free(state->u.subharm.hp_out_y);
        free(state->u.subharm.hp_out_x);
        state->u.subharm.hp_y = NULL;
        state->u.subharm.lp_y = NULL;
        state->u.subharm.prev = NULL;
        state->u.subharm.sign = NULL;
        state->u.subharm.ff2 = NULL;
        state->u.subharm.ff4 = NULL;
        state->u.subharm.ff4_count = NULL;
        state->u.subharm.sub2_lp = NULL;
        state->u.subharm.sub4_lp = NULL;
        state->u.subharm.env = NULL;
        state->u.subharm.hp_out_y = NULL;
        state->u.subharm.hp_out_x = NULL;
        state->u.subharm.batches = 0;
        state->u.subharm.channels = 0;
        state->u.subharm.use_div4 = 0;
    }
    free(state);
}

static node_kind_t determine_node_kind(const EdgeRunnerNodeDescriptor *descriptor) {
    if (descriptor == NULL || descriptor->type_name == NULL) {
        return NODE_KIND_UNKNOWN;
    }
    if (strcmp(descriptor->type_name, "ConstantNode") == 0) {
        return NODE_KIND_CONSTANT;
    }
    if (strcmp(descriptor->type_name, "GainNode") == 0) {
        return NODE_KIND_GAIN;
    }
    if (strcmp(descriptor->type_name, "MixNode") == 0) {
        return NODE_KIND_MIX;
    }
    if (strcmp(descriptor->type_name, "SafetyNode") == 0) {
        return NODE_KIND_SAFETY;
    }
    if (strcmp(descriptor->type_name, "SineOscillatorNode") == 0) {
        return NODE_KIND_SINE_OSC;
    }
    if (strcmp(descriptor->type_name, "ControllerNode") == 0) {
        return NODE_KIND_CONTROLLER;
    }
    if (strcmp(descriptor->type_name, "LFONode") == 0) {
        return NODE_KIND_LFO;
    }
    if (strcmp(descriptor->type_name, "EnvelopeModulatorNode") == 0) {
        return NODE_KIND_ENVELOPE;
    }
    if (strcmp(descriptor->type_name, "PitchQuantizerNode") == 0) {
        return NODE_KIND_PITCH;
    }
    if (strcmp(descriptor->type_name, "OscNode") == 0) {
        return NODE_KIND_OSC;
    }
    if (strcmp(descriptor->type_name, "SubharmonicLowLifterNode") == 0) {
        return NODE_KIND_SUBHARM;
    }
    return NODE_KIND_UNKNOWN;
}

static double json_get_double(const char *json, size_t json_len, const char *key, double default_value) {
    (void)json_len;
    if (json == NULL || key == NULL) {
        return default_value;
    }
    size_t key_len = strlen(key);
    if (key_len == 0) {
        return default_value;
    }
    char pattern[128];
    if (key_len + 3 >= sizeof(pattern)) {
        return default_value;
    }
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    const char *cursor = json;
    size_t pattern_len = strlen(pattern);
    while ((cursor = strstr(cursor, pattern)) != NULL) {
        cursor += pattern_len;
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\r' || *cursor == '\n') {
            cursor++;
        }
        if (*cursor != ':') {
            continue;
        }
        cursor++;
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\r' || *cursor == '\n') {
            cursor++;
        }
        if (*cursor == '\0') {
            break;
        }
        char *endptr = NULL;
        double value = strtod(cursor, &endptr);
        if (endptr == cursor) {
            cursor = endptr;
            continue;
        }
        return value;
    }
    return default_value;
}

static int json_get_int(const char *json, size_t json_len, const char *key, int default_value) {
    double value = json_get_double(json, json_len, key, (double)default_value);
    if (value >= 0.0) {
        return (int)(value + 0.5);
    }
    return (int)(value - 0.5);
}

static int json_get_bool(const char *json, size_t json_len, const char *key, int default_value) {
    double value = json_get_double(json, json_len, key, default_value ? 1.0 : 0.0);
    return value >= 0.5 ? 1 : 0;
}

static int json_copy_string(const char *json, size_t json_len, const char *key, char *out, size_t out_len) {
    (void)json_len;
    if (out == NULL || out_len == 0) {
        return 0;
    }
    out[0] = '\0';
    if (json == NULL || key == NULL) {
        return 0;
    }
    size_t key_len = strlen(key);
    if (key_len == 0) {
        return 0;
    }
    char pattern[128];
    if (key_len + 3 >= sizeof(pattern)) {
        return 0;
    }
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    const char *cursor = json;
    size_t pattern_len = strlen(pattern);
    while ((cursor = strstr(cursor, pattern)) != NULL) {
        cursor += pattern_len;
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\r' || *cursor == '\n') {
            cursor++;
        }
        if (*cursor != ':') {
            continue;
        }
        cursor++;
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\r' || *cursor == '\n') {
            cursor++;
        }
        if (*cursor != '"') {
            continue;
        }
        cursor++;
        const char *start = cursor;
        while (*cursor != '\0' && *cursor != '"') {
            cursor++;
        }
        size_t length = (size_t)(cursor - start);
        if (length >= out_len) {
            length = out_len - 1;
        }
        memcpy(out, start, length);
        out[length] = '\0';
        return 1;
    }
    return 0;
}

static const EdgeRunnerParamView *find_param(const EdgeRunnerNodeInputs *inputs, const char *name) {
    if (inputs == NULL || name == NULL) {
        return NULL;
    }
    uint32_t count = inputs->params.count;
    EdgeRunnerParamView *items = inputs->params.items;
    for (uint32_t i = 0; i < count; ++i) {
        const EdgeRunnerParamView *view = &items[i];
        if (view->name != NULL && strcmp(view->name, name) == 0) {
            return view;
        }
    }
    return NULL;
}

typedef struct {
    char output[64];
    char source[64];
} controller_source_t;

static int parse_csv_tokens(const char *csv, char tokens[][64], int max_tokens) {
    if (csv == NULL || tokens == NULL || max_tokens <= 0) {
        return 0;
    }
    int count = 0;
    const char *cursor = csv;
    while (*cursor != '\0' && count < max_tokens) {
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\n' || *cursor == ',') {
            cursor++;
        }
        if (*cursor == '\0') {
            break;
        }
        const char *start = cursor;
        while (*cursor != '\0' && *cursor != ',') {
            cursor++;
        }
        size_t len = (size_t)(cursor - start);
        if (len >= 63) {
            len = 63;
        }
        memcpy(tokens[count], start, len);
        tokens[count][len] = '\0';
        count++;
    }
    return count;
}

static int parse_controller_sources(const char *csv, controller_source_t *items, int max_items) {
    if (csv == NULL || items == NULL || max_items <= 0) {
        return 0;
    }
    int count = 0;
    const char *cursor = csv;
    while (*cursor != '\0' && count < max_items) {
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\n' || *cursor == ',') {
            cursor++;
        }
        if (*cursor == '\0') {
            break;
        }
        const char *eq = strchr(cursor, '=');
        if (eq == NULL) {
            break;
        }
        size_t key_len = (size_t)(eq - cursor);
        if (key_len >= sizeof(items[count].output)) {
            key_len = sizeof(items[count].output) - 1;
        }
        memcpy(items[count].output, cursor, key_len);
        items[count].output[key_len] = '\0';
        cursor = eq + 1;
        const char *end = strchr(cursor, ',');
        if (end == NULL) {
            end = cursor + strlen(cursor);
        }
        size_t value_len = (size_t)(end - cursor);
        if (value_len >= sizeof(items[count].source)) {
            value_len = sizeof(items[count].source) - 1;
        }
        memcpy(items[count].source, cursor, value_len);
        items[count].source[value_len] = '\0';
        cursor = end;
        count++;
    }
    return count;
}

static int parse_csv_doubles(const char *csv, double *values, int max_values) {
    if (csv == NULL || values == NULL || max_values <= 0) {
        return 0;
    }
    int count = 0;
    const char *cursor = csv;
    while (*cursor != '\0' && count < max_values) {
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\n' || *cursor == ',') {
            cursor++;
        }
        if (*cursor == '\0') {
            break;
        }
        char *endptr = NULL;
        double value = strtod(cursor, &endptr);
        if (endptr == cursor) {
            break;
        }
        values[count++] = value;
        cursor = endptr;
    }
    return count;
}

static const double *ensure_param_plane(
    const EdgeRunnerParamView *view,
    int batches,
    int frames,
    double default_value,
    double **owned_out
) {
    if (owned_out != NULL) {
        *owned_out = NULL;
    }
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    size_t total = (size_t)batches * (size_t)frames;
    if (view == NULL || view->data == NULL) {
        if (owned_out == NULL) {
            return NULL;
        }
        double *buf = (double *)malloc(total * sizeof(double));
        if (buf == NULL) {
            return NULL;
        }
        for (size_t i = 0; i < total; ++i) {
            buf[i] = default_value;
        }
        *owned_out = buf;
        return buf;
    }
    int vb = view->batches > 0 ? (int)view->batches : batches;
    int vc = view->channels > 0 ? (int)view->channels : 1;
    int vf = view->frames > 0 ? (int)view->frames : frames;
    if (vb == batches && vc == 1 && vf == frames) {
        return view->data;
    }
    if (owned_out == NULL) {
        return NULL;
    }
    double *buf = (double *)malloc(total * sizeof(double));
    amp_last_alloc_count = total;
    amp_last_alloc_count = total;
    if (buf == NULL) {
        return NULL;
    }
    for (int b = 0; b < batches; ++b) {
        for (int f = 0; f < frames; ++f) {
            size_t idx = (size_t)b * (size_t)frames + (size_t)f;
            double value = default_value;
            if (b < vb && f < vf) {
                size_t src_idx = ((size_t)b * (size_t)vc) * (size_t)vf + (size_t)f;
                if (vc > 0) {
                    src_idx = ((size_t)b * (size_t)vc + 0) * (size_t)vf + (size_t)f;
                }
                size_t span = (size_t)vb * (size_t)vc * (size_t)vf;
                if (src_idx < span) {
                    value = view->data[src_idx];
                }
            }
            buf[idx] = value;
        }
    }
    *owned_out = buf;
    return buf;
}

static double read_scalar_param(const EdgeRunnerParamView *view, double default_value) {
    if (view == NULL || view->data == NULL) {
        return default_value;
    }
    size_t total = (size_t)(view->batches ? view->batches : 1)
        * (size_t)(view->channels ? view->channels : 1)
        * (size_t)(view->frames ? view->frames : 1);
    if (total == 0) {
        return default_value;
    }
    return view->data[total - 1];
}

static int compare_double(const void *a, const void *b) {
    double da = *(const double *)a;
    double db = *(const double *)b;
    if (da < db) {
        return -1;
    }
    if (da > db) {
        return 1;
    }
    return 0;
}

static int build_sorted_grid(const double *values, int count, double *sorted, double *ext) {
    if (values == NULL || sorted == NULL || ext == NULL || count <= 0) {
        return 0;
    }
    int n = count;
    if (n < 2) {
        n = 12;
        for (int i = 0; i < n; ++i) {
            sorted[i] = (double)i * 100.0;
        }
    } else {
        memcpy(sorted, values, (size_t)n * sizeof(double));
        qsort(sorted, (size_t)n, sizeof(double), compare_double);
    }
    for (int i = 0; i < n; ++i) {
        ext[i] = sorted[i];
    }
    ext[n] = sorted[0] + 1200.0;
    return n;
}

static double grid_warp_forward_value(double cents, const double *grid, const double *grid_ext, int N) {
    double octs = floor(cents / 1200.0);
    double c_mod = fmod(cents, 1200.0);
    if (c_mod < 0.0) {
        c_mod += 1200.0;
    }
    int idx = 0;
    for (int i = 0; i < N; ++i) {
        if (c_mod >= grid_ext[i] && c_mod < grid_ext[i + 1]) {
            idx = i;
            break;
        }
        if (i == N - 1) {
            idx = N - 1;
        }
    }
    double lower = grid_ext[idx];
    double upper = grid_ext[idx + 1];
    double denom = upper - lower;
    if (fabs(denom) < 1e-9) {
        denom = 1e-9;
    }
    double t = (c_mod - lower) / denom;
    double u_mod = (double)idx + t;
    return octs * (double)N + u_mod;
}

static double grid_warp_inverse_value(double u, const double *grid, const double *grid_ext, int N) {
    double octs = floor(u / (double)N);
    double u_mod = u - octs * (double)N;
    int idx = (int)floor(u_mod);
    if (idx < 0) {
        idx = 0;
    }
    if (idx >= N) {
        idx = N - 1;
    }
    double frac = u_mod - (double)idx;
    double lower = grid_ext[idx];
    double upper = grid_ext[idx + 1];
    double cents = lower + frac * (upper - lower);
    return octs * 1200.0 + cents;
}

static int run_constant_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    int batches,
    int frames,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    int channels = json_get_int(descriptor->params_json, descriptor->params_len, "channels", 1);
    if (channels <= 0) {
        channels = 1;
    }
    double value = json_get_double(descriptor->params_json, descriptor->params_len, "value", 0.0);
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    amp_last_alloc_count = total;
    if (buffer == NULL) {
        return -1;
    }
    for (size_t i = 0; i < total; ++i) {
        buffer[i] = value;
    }
    if (state != NULL) {
        state->u.constant.value = value;
        state->u.constant.channels = channels;
    }
    *out_buffer = buffer;
    *out_channels = channels;
    return 0;
}

static double render_lfo_wave(const char *wave, double phase) {
    if (wave != NULL) {
        if (strcmp(wave, "square") == 0) {
            return phase < 0.5 ? 1.0 : -1.0;
        }
        if (strcmp(wave, "saw") == 0) {
            double t = phase - floor(phase);
            return 2.0 * t - 1.0;
        }
        if (strcmp(wave, "triangle") == 0) {
            double t = phase - floor(phase);
            return 2.0 * fabs(2.0 * t - 1.0) - 1.0;
        }
    }
    return sin(phase * 2.0 * M_PI);
}

static int run_controller_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double **out_buffer,
    int *out_channels,
    const EdgeRunnerControlHistory *history
) {
    if (out_buffer == NULL || out_channels == NULL) {
        return -1;
    }
    char outputs_csv[256];
    char sources_csv[512];
    char output_names[32][64];
    controller_source_t mappings[32];
    int output_count = 0;
    if (json_copy_string(descriptor->params_json, descriptor->params_len, "__controller_outputs__", outputs_csv, sizeof(outputs_csv))) {
        output_count = parse_csv_tokens(outputs_csv, output_names, 32);
    }
    if (output_count <= 0 && inputs != NULL) {
        uint32_t count = inputs->params.count;
        EdgeRunnerParamView *items = inputs->params.items;
        for (uint32_t i = 0; i < count && i < 32U; ++i) {
            if (items[i].name != NULL) {
                strncpy(output_names[output_count], items[i].name, sizeof(output_names[output_count]) - 1);
                output_names[output_count][sizeof(output_names[output_count]) - 1] = '\0';
                output_count++;
            }
        }
    }
    if (output_count <= 0) {
        return -1;
    }
    int mapping_count = 0;
    if (json_copy_string(descriptor->params_json, descriptor->params_len, "__controller_sources__", sources_csv, sizeof(sources_csv))) {
        mapping_count = parse_controller_sources(sources_csv, mappings, 32);
    }
    int resolved_channels = output_count;
    if (inputs != NULL && inputs->params.count > 0) {
        const EdgeRunnerParamView *view = &inputs->params.items[0];
        if (batches <= 0 && view->batches > 0) {
            batches = (int)view->batches;
        }
        if (frames <= 0 && view->frames > 0) {
            frames = (int)view->frames;
        }
    }
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    size_t total = (size_t)batches * (size_t)resolved_channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    amp_last_alloc_count = total;
    if (buffer == NULL) {
        return -1;
    }
    for (int c = 0; c < resolved_channels; ++c) {
        const char *source_name = output_names[c];
        for (int m = 0; m < mapping_count; ++m) {
            if (strcmp(mappings[m].output, output_names[c]) == 0) {
                source_name = mappings[m].source;
                break;
            }
        }
        const EdgeRunnerParamView *view = find_param(inputs, source_name);
        int view_missing = (view == NULL || view->data == NULL);
        double *owned = NULL;
        const double *data = ensure_param_plane(view, batches, frames, 0.0, &owned);
        if (data == NULL) {
            free(buffer);
            return -1;
        }
        if (view_missing && owned != NULL && history != NULL) {
            const EdgeRunnerControlCurve *curve = find_history_curve(history, source_name, strlen(source_name));
            if (curve != NULL) {
                apply_history_curve(owned, batches, frames, curve);
            }
            data = owned;
        }
        for (int b = 0; b < batches; ++b) {
            for (int f = 0; f < frames; ++f) {
                size_t src_idx = (size_t)b * (size_t)frames + (size_t)f;
                size_t dst_idx = ((size_t)b * (size_t)resolved_channels + (size_t)c) * (size_t)frames + (size_t)f;
                buffer[dst_idx] = data[src_idx];
            }
        }
        if (owned != NULL) {
            free(owned);
        }
    }
    *out_buffer = buffer;
    *out_channels = resolved_channels;
    return 0;
}

static int run_lfo_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (out_buffer == NULL || out_channels == NULL) {
        return -1;
    }
    char wave_buf[32];
    if (!json_copy_string(descriptor->params_json, descriptor->params_len, "wave", wave_buf, sizeof(wave_buf))) {
        strcpy(wave_buf, "sine");
    }
    double rate_hz = json_get_double(descriptor->params_json, descriptor->params_len, "rate_hz", 1.0);
    double depth = json_get_double(descriptor->params_json, descriptor->params_len, "depth", 0.5);
    double slew_ms = json_get_double(descriptor->params_json, descriptor->params_len, "slew_ms", 0.0);
    int use_input = json_get_bool(descriptor->params_json, descriptor->params_len, "use_input", 0);
    int B = batches > 0 ? batches : 1;
    int F = frames > 0 ? frames : 1;
    int audio_channels = 0;
    const double *audio_data = NULL;
    if (use_input && inputs != NULL && inputs->audio.has_audio && inputs->audio.data != NULL) {
        B = inputs->audio.batches > 0 ? (int)inputs->audio.batches : B;
        F = inputs->audio.frames > 0 ? (int)inputs->audio.frames : F;
        audio_channels = inputs->audio.channels > 0 ? (int)inputs->audio.channels : 1;
        audio_data = inputs->audio.data;
    }
    size_t total = (size_t)B * (size_t)F;
    double *buffer = (double *)malloc(total * sizeof(double));
    amp_last_alloc_count = total;
    if (buffer == NULL) {
        return -1;
    }
    if (use_input && audio_data != NULL) {
        for (int b = 0; b < B; ++b) {
            double max_abs = 0.0;
            for (int c = 0; c < audio_channels; ++c) {
                for (int f = 0; f < F; ++f) {
                    size_t idx = ((size_t)b * (size_t)audio_channels + (size_t)c) * (size_t)F + (size_t)f;
                    double val = fabs(audio_data[idx]);
                    if (val > max_abs) {
                        max_abs = val;
                    }
                }
            }
            if (max_abs < 1e-12) {
                max_abs = 1.0;
            }
            for (int f = 0; f < F; ++f) {
                size_t src_idx = ((size_t)b * (size_t)audio_channels) * (size_t)F + (size_t)f;
                double sample = audio_data[src_idx];
                buffer[(size_t)b * (size_t)F + (size_t)f] = (sample / max_abs) * depth;
            }
        }
    } else {
        if (sample_rate <= 0.0) {
            sample_rate = 48000.0;
        }
        double step = rate_hz / sample_rate;
        double phase = 0.0;
        if (state != NULL) {
            phase = state->u.lfo.phase;
        }
        for (int b = 0; b < B; ++b) {
            double local_phase = phase;
            for (int f = 0; f < F; ++f) {
                double value = render_lfo_wave(wave_buf, local_phase) * depth;
                buffer[(size_t)b * (size_t)F + (size_t)f] = value;
                local_phase += step;
                local_phase -= floor(local_phase);
            }
            if (state != NULL) {
                phase = local_phase;
            }
        }
        if (state != NULL) {
            state->u.lfo.phase = phase;
        }
    }
    if (slew_ms > 0.0 && state != NULL) {
        if (sample_rate <= 0.0) {
            sample_rate = 48000.0;
        }
        double alpha = 1.0 - exp(-1.0 / (sample_rate * (slew_ms / 1000.0)));
        if (alpha < 1.0 - 1e-15) {
            double r = 1.0 - alpha;
            if (state->u.lfo.slew_state == NULL || state->u.lfo.batches != B) {
                free(state->u.lfo.slew_state);
                state->u.lfo.slew_state = (double *)calloc((size_t)B, sizeof(double));
                state->u.lfo.batches = B;
            }
            if (state->u.lfo.slew_state != NULL) {
                lfo_slew(buffer, buffer, B, F, r, alpha, state->u.lfo.slew_state);
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = 1;
    return 0;
}

static int run_envelope_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (out_buffer == NULL || out_channels == NULL) {
        return -1;
    }
    if (sample_rate <= 0.0) {
        sample_rate = 48000.0;
    }
    int B = batches > 0 ? batches : 1;
    int F = frames > 0 ? frames : 1;
    const EdgeRunnerParamView *trigger_view = find_param(inputs, "trigger");
    const EdgeRunnerParamView *gate_view = find_param(inputs, "gate");
    const EdgeRunnerParamView *drone_view = find_param(inputs, "drone");
    const EdgeRunnerParamView *velocity_view = find_param(inputs, "velocity");
    const EdgeRunnerParamView *send_reset_view = find_param(inputs, "send_reset");
    if (trigger_view != NULL && trigger_view->batches > 0) {
        B = (int)trigger_view->batches;
    }
    if (trigger_view != NULL && trigger_view->frames > 0) {
        F = (int)trigger_view->frames;
    }
    if (B <= 0) {
        B = 1;
    }
    if (F <= 0) {
        F = 1;
    }
    double attack_ms = json_get_double(descriptor->params_json, descriptor->params_len, "attack_ms", 12.0);
    double hold_ms = json_get_double(descriptor->params_json, descriptor->params_len, "hold_ms", 8.0);
    double decay_ms = json_get_double(descriptor->params_json, descriptor->params_len, "decay_ms", 90.0);
    double sustain_level = json_get_double(descriptor->params_json, descriptor->params_len, "sustain_level", 0.7);
    double sustain_ms = json_get_double(descriptor->params_json, descriptor->params_len, "sustain_ms", 0.0);
    double release_ms = json_get_double(descriptor->params_json, descriptor->params_len, "release_ms", 220.0);
    int send_resets_default = json_get_bool(descriptor->params_json, descriptor->params_len, "send_resets", 1);
    int atk_frames = (int)lrint((attack_ms / 1000.0) * sample_rate);
    int hold_frames = (int)lrint((hold_ms / 1000.0) * sample_rate);
    int dec_frames = (int)lrint((decay_ms / 1000.0) * sample_rate);
    int sus_frames = (int)lrint((sustain_ms / 1000.0) * sample_rate);
    int rel_frames = (int)lrint((release_ms / 1000.0) * sample_rate);
    if (atk_frames < 0) atk_frames = 0;
    if (hold_frames < 0) hold_frames = 0;
    if (dec_frames < 0) dec_frames = 0;
    if (sus_frames < 0) sus_frames = 0;
    if (rel_frames < 0) rel_frames = 0;
    double *owned_trigger = NULL;
    double *owned_gate = NULL;
    double *owned_drone = NULL;
    double *owned_velocity = NULL;
    const double *trigger = ensure_param_plane(trigger_view, B, F, 0.0, &owned_trigger);
    const double *gate = ensure_param_plane(gate_view, B, F, 0.0, &owned_gate);
    const double *drone = ensure_param_plane(drone_view, B, F, 0.0, &owned_drone);
    const double *velocity = ensure_param_plane(velocity_view, B, F, 1.0, &owned_velocity);
    if (trigger == NULL || gate == NULL || drone == NULL || velocity == NULL) {
        free(owned_trigger);
        free(owned_gate);
        free(owned_drone);
        free(owned_velocity);
        return -1;
    }
    double send_reset_value = read_scalar_param(send_reset_view, (double)send_resets_default);
    int send_reset_flag = send_reset_value >= 0.5 ? 1 : 0;
    size_t total = (size_t)B * (size_t)F * 2;
    double *buffer = (double *)malloc(total * sizeof(double));
    amp_last_alloc_count = total;
    if (buffer == NULL) {
        free(owned_trigger);
        free(owned_gate);
        free(owned_drone);
        free(owned_velocity);
        return -1;
    }
    double *amp_plane = buffer;
    double *reset_plane = buffer + (size_t)B * (size_t)F;
    if (state == NULL) {
        free(buffer);
        free(owned_trigger);
        free(owned_gate);
        free(owned_drone);
        free(owned_velocity);
        return -1;
    }
    if (state->u.envelope.stage == NULL || state->u.envelope.batches != B) {
        free(state->u.envelope.stage);
        free(state->u.envelope.value);
        free(state->u.envelope.timer);
        free(state->u.envelope.velocity);
        free(state->u.envelope.activations);
        free(state->u.envelope.release_start);
        state->u.envelope.stage = (int *)calloc((size_t)B, sizeof(int));
        state->u.envelope.value = (double *)calloc((size_t)B, sizeof(double));
        state->u.envelope.timer = (double *)calloc((size_t)B, sizeof(double));
        state->u.envelope.velocity = (double *)calloc((size_t)B, sizeof(double));
        state->u.envelope.activations = (int64_t *)calloc((size_t)B, sizeof(int64_t));
        state->u.envelope.release_start = (double *)calloc((size_t)B, sizeof(double));
        state->u.envelope.batches = B;
    }
    if (state->u.envelope.stage == NULL || state->u.envelope.value == NULL || state->u.envelope.timer == NULL) {
        free(buffer);
        free(owned_trigger);
        free(owned_gate);
        free(owned_drone);
        free(owned_velocity);
        return -1;
    }
    envelope_process(
        trigger,
        gate,
        drone,
        velocity,
        B,
        F,
        atk_frames,
        hold_frames,
        dec_frames,
        sus_frames,
        rel_frames,
        sustain_level,
        send_reset_flag,
        state->u.envelope.stage,
        state->u.envelope.value,
        state->u.envelope.timer,
        state->u.envelope.velocity,
        state->u.envelope.activations,
        state->u.envelope.release_start,
        amp_plane,
        reset_plane
    );
    free(owned_trigger);
    free(owned_gate);
    free(owned_drone);
    free(owned_velocity);
    *out_buffer = buffer;
    *out_channels = 2;
    return 0;
}

static int run_pitch_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    (void)sample_rate;
    if (out_buffer == NULL || out_channels == NULL || state == NULL) {
        return -1;
    }
    char grid_csv[1024];
    double grid_values[256];
    double grid_sorted_vals[256];
    double grid_ext[257];
    int grid_count = 0;
    if (json_copy_string(descriptor->params_json, descriptor->params_len, "grid_cents", grid_csv, sizeof(grid_csv))) {
        grid_count = parse_csv_doubles(grid_csv, grid_values, 256);
    }
    if (grid_count <= 0) {
        for (int i = 0; i < 12; ++i) {
            grid_values[i] = (double)i * 100.0;
        }
        grid_count = 12;
    }
    int grid_size = build_sorted_grid(grid_values, grid_count, grid_sorted_vals, grid_ext);
    int is_free_mode = json_get_bool(descriptor->params_json, descriptor->params_len, "is_free_mode", 0);
    char variant_buf[32];
    if (!json_copy_string(descriptor->params_json, descriptor->params_len, "free_variant", variant_buf, sizeof(variant_buf))) {
        strcpy(variant_buf, "continuous");
    }
    double span_default = json_get_double(descriptor->params_json, descriptor->params_len, "span_default", 2.0);
    int slew_enabled = json_get_bool(descriptor->params_json, descriptor->params_len, "slew", 1);
    const EdgeRunnerParamView *input_view = find_param(inputs, "input");
    const EdgeRunnerParamView *root_view = find_param(inputs, "root_midi");
    const EdgeRunnerParamView *span_view = find_param(inputs, "span_oct");
    int B = batches > 0 ? batches : 1;
    int F = frames > 0 ? frames : 1;
    if (input_view != NULL && input_view->batches > 0) {
        B = (int)input_view->batches;
    }
    if (input_view != NULL && input_view->frames > 0) {
        F = (int)input_view->frames;
    }
    if (B <= 0) B = 1;
    if (F <= 0) F = 1;
    double *owned_input = NULL;
    double *owned_root = NULL;
    double *owned_span = NULL;
    const double *ctrl = ensure_param_plane(input_view, B, F, 0.0, &owned_input);
    const double *root = ensure_param_plane(root_view, B, F, 60.0, &owned_root);
    const double *span = ensure_param_plane(span_view, B, F, span_default, &owned_span);
    if (ctrl == NULL || root == NULL || span == NULL) {
        free(owned_input);
        free(owned_root);
        free(owned_span);
        return -1;
    }
    size_t total = (size_t)B * (size_t)F;
    double *freq_target = (double *)malloc(total * sizeof(double));
    amp_last_alloc_count = total;
    if (freq_target == NULL) {
        free(owned_input);
        free(owned_root);
        free(owned_span);
        return -1;
    }
    for (int b = 0; b < B; ++b) {
        for (int f = 0; f < F; ++f) {
            size_t idx = (size_t)b * (size_t)F + (size_t)f;
            double ctrl_scaled = ctrl[idx] * span[idx];
            double root_midi = root[idx];
            double root_freq = 440.0 * pow(2.0, (root_midi - 69.0) / 12.0);
            double cents = 0.0;
            if (is_free_mode) {
                if (strcmp(variant_buf, "weighted") == 0) {
                    double u = ctrl_scaled * (double)grid_size;
                    cents = grid_warp_inverse_value(u, grid_sorted_vals, grid_ext, grid_size);
                } else if (strcmp(variant_buf, "stepped") == 0) {
                    double u = round(ctrl_scaled * (double)grid_size);
                    cents = grid_warp_inverse_value(u, grid_sorted_vals, grid_ext, grid_size);
                } else {
                    cents = ctrl_scaled * 1200.0;
                }
            } else {
                double cents_unq = ctrl_scaled * 1200.0;
                double u = grid_warp_forward_value(cents_unq, grid_sorted_vals, grid_ext, grid_size);
                double u_round = round(u);
                cents = grid_warp_inverse_value(u_round, grid_sorted_vals, grid_ext, grid_size);
            }
            freq_target[idx] = root_freq * pow(2.0, cents / 1200.0);
        }
    }
    free(owned_input);
    free(owned_root);
    free(owned_span);
    double *output = (double *)malloc(total * sizeof(double));
    amp_last_alloc_count = total;
    if (output == NULL) {
        free(freq_target);
        return -1;
    }
    if (slew_enabled) {
        if (state->u.pitch.last_freq == NULL || state->u.pitch.batches != B) {
            free(state->u.pitch.last_freq);
            state->u.pitch.last_freq = (double *)calloc((size_t)B, sizeof(double));
            state->u.pitch.batches = B;
        }
        if (state->u.pitch.last_freq == NULL) {
            free(freq_target);
            free(output);
            return -1;
        }
        for (int b = 0; b < B; ++b) {
            double y0 = state->u.pitch.last_freq[b];
            double y1 = freq_target[(size_t)b * (size_t)F + (size_t)(F - 1)];
            for (int f = 0; f < F; ++f) {
                double t = (double)f / (double)F;
                double ramp = 3.0 * t * t - 2.0 * t * t * t;
                output[(size_t)b * (size_t)F + (size_t)f] = y0 + (y1 - y0) * ramp;
            }
            state->u.pitch.last_freq[b] = y1;
        }
    } else {
        memcpy(output, freq_target, total * sizeof(double));
    }
    free(freq_target);
    *out_buffer = output;
    *out_channels = 1;
    return 0;
}

static double alpha_lp(double fc, double sr) {
    if (fc < 1.0) {
        fc = 1.0;
    }
    return 1.0 - exp(-2.0 * M_PI * fc / sr);
}

static double alpha_hp(double fc, double sr) {
    if (fc < 1.0) {
        fc = 1.0;
    }
    double rc = 1.0 / (2.0 * M_PI * fc);
    return rc / (rc + 1.0 / sr);
}

static int run_subharm_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (out_buffer == NULL || out_channels == NULL || state == NULL) {
        return -1;
    }
    if (inputs == NULL || !inputs->audio.has_audio || inputs->audio.data == NULL) {
        return -1;
    }
    int B = inputs->audio.batches > 0 ? (int)inputs->audio.batches : (batches > 0 ? batches : 1);
    int C = inputs->audio.channels > 0 ? (int)inputs->audio.channels : 1;
    int F = inputs->audio.frames > 0 ? (int)inputs->audio.frames : (frames > 0 ? frames : 1);
    if (sample_rate <= 0.0) {
        sample_rate = 48000.0;
    }
    const double *audio = inputs->audio.data;
    double band_lo = json_get_double(descriptor->params_json, descriptor->params_len, "band_lo", 70.0);
    double band_hi = json_get_double(descriptor->params_json, descriptor->params_len, "band_hi", 160.0);
    double mix = json_get_double(descriptor->params_json, descriptor->params_len, "mix", 0.5);
    double drive = json_get_double(descriptor->params_json, descriptor->params_len, "drive", 1.0);
    double out_hp = json_get_double(descriptor->params_json, descriptor->params_len, "out_hp", 25.0);
    int use_div4 = json_get_bool(descriptor->params_json, descriptor->params_len, "use_div4", 0);
    double a_hp_in = alpha_hp(band_lo, sample_rate);
    double a_lp_in = alpha_lp(band_hi, sample_rate);
    double a_sub2 = alpha_lp(fmax(band_hi / 3.0, 30.0), sample_rate);
    double a_sub4 = use_div4 ? alpha_lp(fmax(band_hi / 5.0, 20.0), sample_rate) : 0.0;
    double a_env_attack = alpha_lp(100.0, sample_rate);
    double a_env_release = alpha_lp(5.0, sample_rate);
    double a_hp_out = alpha_hp(out_hp, sample_rate);
    size_t total = (size_t)B * (size_t)C * (size_t)F;
    double *buffer = (double *)malloc(total * sizeof(double));
    amp_last_alloc_count = total;
    if (buffer == NULL) {
        return -1;
    }
    int need_resize = state->u.subharm.batches != B || state->u.subharm.channels != C || state->u.subharm.use_div4 != use_div4;
    if (need_resize) {
        free(state->u.subharm.hp_y);
        free(state->u.subharm.lp_y);
        free(state->u.subharm.prev);
        free(state->u.subharm.sign);
        free(state->u.subharm.ff2);
        free(state->u.subharm.ff4);
        free(state->u.subharm.ff4_count);
        free(state->u.subharm.sub2_lp);
        free(state->u.subharm.sub4_lp);
        free(state->u.subharm.env);
        free(state->u.subharm.hp_out_y);
        free(state->u.subharm.hp_out_x);
        state->u.subharm.hp_y = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.lp_y = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.prev = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.sign = (int8_t *)calloc((size_t)B * (size_t)C, sizeof(int8_t));
        state->u.subharm.ff2 = (int8_t *)calloc((size_t)B * (size_t)C, sizeof(int8_t));
        state->u.subharm.sub2_lp = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.env = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.hp_out_y = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.hp_out_x = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        if (use_div4) {
            state->u.subharm.ff4 = (int8_t *)calloc((size_t)B * (size_t)C, sizeof(int8_t));
            state->u.subharm.ff4_count = (int32_t *)calloc((size_t)B * (size_t)C, sizeof(int32_t));
            state->u.subharm.sub4_lp = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        } else {
            free(state->u.subharm.ff4);
            free(state->u.subharm.ff4_count);
            free(state->u.subharm.sub4_lp);
            state->u.subharm.ff4 = NULL;
            state->u.subharm.ff4_count = NULL;
            state->u.subharm.sub4_lp = NULL;
        }
        state->u.subharm.batches = B;
        state->u.subharm.channels = C;
        state->u.subharm.use_div4 = use_div4;
    }
    if (state->u.subharm.hp_y == NULL || state->u.subharm.lp_y == NULL || state->u.subharm.prev == NULL || state->u.subharm.sign == NULL || state->u.subharm.ff2 == NULL || state->u.subharm.sub2_lp == NULL || state->u.subharm.env == NULL || state->u.subharm.hp_out_y == NULL || state->u.subharm.hp_out_x == NULL) {
        free(buffer);
        return -1;
    }
    subharmonic_process(
        audio,
        buffer,
        B,
        C,
        F,
        a_hp_in,
        a_lp_in,
        a_sub2,
        use_div4,
        a_sub4,
        a_env_attack,
        a_env_release,
        a_hp_out,
        drive,
        mix,
        state->u.subharm.hp_y,
        state->u.subharm.lp_y,
        state->u.subharm.prev,
        state->u.subharm.sign,
        state->u.subharm.ff2,
        state->u.subharm.ff4,
        state->u.subharm.ff4_count,
        state->u.subharm.sub2_lp,
        state->u.subharm.sub4_lp,
        state->u.subharm.env,
        state->u.subharm.hp_out_y,
        state->u.subharm.hp_out_x
    );
    *out_buffer = buffer;
    *out_channels = C;
    return 0;
}

static int run_osc_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (out_buffer == NULL || out_channels == NULL || state == NULL) {
        return -1;
    }
    if (sample_rate <= 0.0) {
        sample_rate = 48000.0;
    }
    char wave_buf[32];
    if (!json_copy_string(descriptor->params_json, descriptor->params_len, "wave", wave_buf, sizeof(wave_buf))) {
        strcpy(wave_buf, "sine");
    }
    int accept_reset = json_get_bool(descriptor->params_json, descriptor->params_len, "accept_reset", 1);
    const EdgeRunnerParamView *freq_view = find_param(inputs, "freq");
    const EdgeRunnerParamView *amp_view = find_param(inputs, "amp");
    const EdgeRunnerParamView *pan_view = find_param(inputs, "pan");
    const EdgeRunnerParamView *reset_view = accept_reset ? find_param(inputs, "reset") : NULL;
    int B = batches > 0 ? batches : 1;
    int F = frames > 0 ? frames : 1;
    if (freq_view != NULL && freq_view->batches > 0) {
        B = (int)freq_view->batches;
    }
    if (freq_view != NULL && freq_view->frames > 0) {
        F = (int)freq_view->frames;
    }
    if (B <= 0) B = 1;
    if (F <= 0) F = 1;
    double *owned_freq = NULL;
    double *owned_amp = NULL;
    double *owned_pan = NULL;
    double *owned_reset = NULL;
    const double *freq = ensure_param_plane(freq_view, B, F, 0.0, &owned_freq);
    const double *amp = ensure_param_plane(amp_view, B, F, 1.0, &owned_amp);
    const double *pan = ensure_param_plane(pan_view, B, F, 0.0, &owned_pan);
    const double *reset = ensure_param_plane(reset_view, B, F, 0.0, &owned_reset);
    if (freq == NULL || amp == NULL) {
        free(owned_freq);
        free(owned_amp);
        free(owned_pan);
        free(owned_reset);
        return -1;
    }
    size_t total = (size_t)B * (size_t)F;
    if (state->u.osc.phase == NULL || state->u.osc.batches != B) {
        free(state->u.osc.phase);
        state->u.osc.phase = (double *)calloc((size_t)B, sizeof(double));
        state->u.osc.batches = B;
    }
    if (state->u.osc.phase_buffer == NULL || state->u.osc.batches != B || state->u.osc.channels != 1) {
        free(state->u.osc.phase_buffer);
        state->u.osc.phase_buffer = (double *)malloc(total * sizeof(double));
    }
    if (state->u.osc.wave_buffer == NULL || state->u.osc.batches != B || state->u.osc.channels != 1) {
        free(state->u.osc.wave_buffer);
        state->u.osc.wave_buffer = (double *)malloc(total * sizeof(double));
    }
    if (state->u.osc.dphi_buffer == NULL || state->u.osc.batches != B || state->u.osc.channels != 1) {
        free(state->u.osc.dphi_buffer);
        state->u.osc.dphi_buffer = (double *)malloc(total * sizeof(double));
    }
    if (strcmp(wave_buf, "triangle") == 0) {
        if (state->u.osc.tri_state == NULL || state->u.osc.batches != B) {
            free(state->u.osc.tri_state);
            state->u.osc.tri_state = (double *)calloc((size_t)B, sizeof(double));
        }
    }
    if (state->u.osc.phase == NULL || state->u.osc.phase_buffer == NULL || state->u.osc.wave_buffer == NULL || state->u.osc.dphi_buffer == NULL) {
        free(owned_freq);
        free(owned_amp);
        free(owned_pan);
        free(owned_reset);
        return -1;
    }
    for (int b = 0; b < B; ++b) {
        for (int f = 0; f < F; ++f) {
            size_t idx = (size_t)b * (size_t)F + (size_t)f;
            state->u.osc.dphi_buffer[idx] = freq[idx] / sample_rate;
        }
    }
    const double *reset_ptr = accept_reset ? reset : NULL;
    phase_advance(state->u.osc.dphi_buffer, state->u.osc.phase_buffer, B, F, state->u.osc.phase, reset_ptr);
    if (strcmp(wave_buf, "saw") == 0) {
        osc_saw_blep_c(state->u.osc.phase_buffer, state->u.osc.dphi_buffer, state->u.osc.wave_buffer, B, F);
    } else if (strcmp(wave_buf, "square") == 0) {
        osc_square_blep_c(state->u.osc.phase_buffer, state->u.osc.dphi_buffer, 0.5, state->u.osc.wave_buffer, B, F);
    } else if (strcmp(wave_buf, "triangle") == 0) {
        osc_triangle_blep_c(state->u.osc.phase_buffer, state->u.osc.dphi_buffer, state->u.osc.wave_buffer, B, F, state->u.osc.tri_state);
    } else {
        for (int b = 0; b < B; ++b) {
            for (int f = 0; f < F; ++f) {
                size_t idx = (size_t)b * (size_t)F + (size_t)f;
                state->u.osc.wave_buffer[idx] = sin(state->u.osc.phase_buffer[idx] * 2.0 * M_PI);
            }
        }
    }
    int stereo = (pan_view != NULL && pan_view->data != NULL) ? 1 : 0;
    int channels = stereo ? 2 : 1;
    size_t total_out = (size_t)B * (size_t)channels * (size_t)F;
    double *buffer = (double *)malloc(total_out * sizeof(double));
    if (buffer == NULL) {
        free(owned_freq);
        free(owned_amp);
        free(owned_pan);
        free(owned_reset);
        return -1;
    }
    for (int b = 0; b < B; ++b) {
        for (int f = 0; f < F; ++f) {
            size_t idx = (size_t)b * (size_t)F + (size_t)f;
            double sample = state->u.osc.wave_buffer[idx] * amp[idx];
            if (stereo) {
                double pan_val = pan[idx];
                if (pan_val < -1.0) pan_val = -1.0;
                if (pan_val > 1.0) pan_val = 1.0;
                double angle = (pan_val + 1.0) * (M_PI / 4.0);
                double left = sample * cos(angle);
                double right = sample * sin(angle);
                buffer[((size_t)b * 2) * (size_t)F + (size_t)f] = left;
                buffer[((size_t)b * 2 + 1) * (size_t)F + (size_t)f] = right;
            } else {
                buffer[(size_t)b * (size_t)F + (size_t)f] = sample;
            }
        }
    }
    free(owned_freq);
    free(owned_amp);
    free(owned_pan);
    free(owned_reset);
    state->u.osc.channels = 1;
    state->u.osc.stereo = stereo;
    *out_buffer = buffer;
    *out_channels = stereo ? 2 : 1;
    return 0;
}

static int run_gain_node(
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double **out_buffer,
    int *out_channels
) {
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    int channels = (int)inputs->audio.channels;
    if (!inputs->audio.has_audio || inputs->audio.data == NULL || channels <= 0) {
        channels = channels > 0 ? channels : 1;
        size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
        double *buffer = (double *)calloc(total, sizeof(double));
        if (buffer == NULL) {
            return -1;
        }
        *out_buffer = buffer;
        *out_channels = channels;
        return 0;
    }
    if (channels <= 0) {
        channels = 1;
    }
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    amp_last_alloc_count = total;
    if (buffer == NULL) {
        return -1;
    }
    const double *audio = inputs->audio.data;
    const EdgeRunnerParamView *gain_view = find_param(inputs, "gain");
    const double *gain = (gain_view != NULL) ? gain_view->data : NULL;
    for (int b = 0; b < batches; ++b) {
        for (int c = 0; c < channels; ++c) {
            size_t base = ((size_t)b * (size_t)channels + (size_t)c) * (size_t)frames;
            for (int f = 0; f < frames; ++f) {
                double sample = audio[base + (size_t)f];
                double g = gain != NULL ? gain[base + (size_t)f] : 1.0;
                buffer[base + (size_t)f] = sample * g;
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = channels;
    return 0;
}

static int run_mix_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double **out_buffer,
    int *out_channels
) {
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    int target_channels = json_get_int(descriptor->params_json, descriptor->params_len, "channels", 1);
    if (target_channels <= 0) {
        target_channels = 1;
    }
    size_t total = (size_t)batches * (size_t)target_channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    if (!inputs->audio.has_audio || inputs->audio.data == NULL || inputs->audio.channels == 0) {
        memset(buffer, 0, total * sizeof(double));
        *out_buffer = buffer;
        *out_channels = target_channels;
        return 0;
    }
    int in_channels = (int)inputs->audio.channels;
    const double *audio = inputs->audio.data;
    for (int b = 0; b < batches; ++b) {
        for (int f = 0; f < frames; ++f) {
            double sum = 0.0;
            for (int c = 0; c < in_channels; ++c) {
                size_t idx = ((size_t)b * (size_t)in_channels + (size_t)c) * (size_t)frames + (size_t)f;
                sum += audio[idx];
            }
            for (int oc = 0; oc < target_channels; ++oc) {
                size_t out_idx = ((size_t)b * (size_t)target_channels + (size_t)oc) * (size_t)frames + (size_t)f;
                buffer[out_idx] = sum;
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = target_channels;
    return 0;
}

static int run_sine_osc_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    if (sample_rate <= 0.0) {
        sample_rate = 48000.0;
    }
    int channels = json_get_int(descriptor->params_json, descriptor->params_len, "channels", 1);
    if (channels <= 0) {
        channels = 1;
    }
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    double initial_phase = json_get_double(descriptor->params_json, descriptor->params_len, "phase", 0.0);
    double normalized_phase = initial_phase - floor(initial_phase);
    if (state != NULL) {
        if (state->u.sine.phase == NULL || state->u.sine.batches != batches || state->u.sine.channels != channels) {
            free(state->u.sine.phase);
            state->u.sine.phase = (double *)calloc((size_t)batches * (size_t)channels, sizeof(double));
            if (state->u.sine.phase == NULL) {
                free(buffer);
                state->u.sine.batches = 0;
                state->u.sine.channels = 0;
                return -1;
            }
            state->u.sine.batches = batches;
            state->u.sine.channels = channels;
            state->u.sine.base_phase = normalized_phase;
            for (size_t idx = 0; idx < (size_t)batches * (size_t)channels; ++idx) {
                state->u.sine.phase[idx] = normalized_phase;
            }
        }
    }
    double *phase = state != NULL ? state->u.sine.phase : NULL;
    double base_freq = json_get_double(descriptor->params_json, descriptor->params_len, "frequency", 440.0);
    double base_amp = json_get_double(descriptor->params_json, descriptor->params_len, "amplitude", 0.5);
    const EdgeRunnerParamView *freq_view = find_param(inputs, "frequency");
    const EdgeRunnerParamView *amp_view = find_param(inputs, "amplitude");
    const double *freq_data = freq_view != NULL ? freq_view->data : NULL;
    const double *amp_data = amp_view != NULL ? amp_view->data : NULL;
    for (int b = 0; b < batches; ++b) {
        for (int c = 0; c < channels; ++c) {
            size_t bc = (size_t)b * (size_t)channels + (size_t)c;
            double phase_acc = phase != NULL ? phase[bc] : normalized_phase;
            for (int f = 0; f < frames; ++f) {
                size_t idx = bc * (size_t)frames + (size_t)f;
                double freq = freq_data != NULL ? freq_data[idx] : base_freq;
                double amp = amp_data != NULL ? amp_data[idx] : base_amp;
                double step = freq / sample_rate;
                phase_acc += step;
                phase_acc -= floor(phase_acc);
                buffer[idx] = sin(phase_acc * 2.0 * M_PI) * amp;
            }
            if (phase != NULL) {
                phase[bc] = phase_acc;
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = channels;
    return 0;
}

static int run_safety_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    (void)sample_rate;
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    int channels = json_get_int(descriptor->params_json, descriptor->params_len, "channels", (int)inputs->audio.channels);
    if (channels <= 0) {
        channels = (int)inputs->audio.channels;
    }
    if (channels <= 0) {
        channels = 1;
    }
    double alpha = json_get_double(descriptor->params_json, descriptor->params_len, "dc_alpha", 0.995);
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    if (state != NULL) {
        if (state->u.safety.state == NULL || state->u.safety.batches != batches || state->u.safety.channels != channels) {
            free(state->u.safety.state);
            state->u.safety.state = (double *)calloc((size_t)batches * (size_t)channels, sizeof(double));
            if (state->u.safety.state == NULL) {
                free(buffer);
                state->u.safety.batches = 0;
                state->u.safety.channels = 0;
                return -1;
            }
            state->u.safety.batches = batches;
            state->u.safety.channels = channels;
        }
        state->u.safety.alpha = alpha;
    }
    if (!inputs->audio.has_audio || inputs->audio.data == NULL) {
        memset(buffer, 0, total * sizeof(double));
    } else {
        double *dc_state = NULL;
        if (state != NULL) {
            dc_state = state->u.safety.state;
        }
        if (dc_state == NULL) {
            dc_state = (double *)calloc((size_t)batches * (size_t)channels, sizeof(double));
            if (dc_state == NULL) {
                free(buffer);
                return -1;
            }
            if (state != NULL) {
                state->u.safety.state = dc_state;
                state->u.safety.batches = batches;
                state->u.safety.channels = channels;
            }
        }
        dc_block(inputs->audio.data, buffer, batches, channels, frames, alpha, dc_state);
        for (size_t i = 0; i < total; ++i) {
            double v = buffer[i];
            if (v > 1.0) {
                buffer[i] = 1.0;
            } else if (v < -1.0) {
                buffer[i] = -1.0;
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = channels;
    return 0;
}

AMP_CAPI int amp_run_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int channels,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    void **state,
    const EdgeRunnerControlHistory *history
) {
    _log_native_call("amp_run_node", (size_t)batches, (size_t)frames);
    (void)channels;
    if (out_buffer == NULL || out_channels == NULL) {
        return -1;
    }
    node_kind_t kind = determine_node_kind(descriptor);
    if (kind == NODE_KIND_UNKNOWN) {
        return -3;
    }
    node_state_t *node_state = NULL;
    if (state != NULL && *state != NULL) {
        node_state = (node_state_t *)(*state);
    }
    if (node_state != NULL && node_state->kind != kind) {
        release_node_state(node_state);
        node_state = NULL;
        if (state != NULL) {
            *state = NULL;
        }
    }
    if (node_state == NULL) {
        node_state = (node_state_t *)calloc(1, sizeof(node_state_t));
        if (node_state == NULL) {
            return -1;
        }
        node_state->kind = kind;
        if (state != NULL) {
            *state = node_state;
        }
    }

    int rc = 0;
    switch (kind) {
        case NODE_KIND_CONSTANT:
            rc = run_constant_node(descriptor, batches, frames, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_GAIN:
            rc = run_gain_node(inputs, batches, frames, out_buffer, out_channels);
            break;
        case NODE_KIND_MIX:
            rc = run_mix_node(descriptor, inputs, batches, frames, out_buffer, out_channels);
            break;
        case NODE_KIND_SAFETY:
            rc = run_safety_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_SINE_OSC:
            rc = run_sine_osc_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_CONTROLLER:
            rc = run_controller_node(descriptor, inputs, batches, frames, out_buffer, out_channels, history);
            break;
        case NODE_KIND_LFO:
            rc = run_lfo_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_ENVELOPE:
            rc = run_envelope_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_PITCH:
            rc = run_pitch_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_OSC:
            rc = run_osc_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_SUBHARM:
            rc = run_subharm_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        default:
            rc = -3;
            break;
    }
    return rc;
}

AMP_CAPI void amp_free(double *buffer) {
    _log_native_call("amp_free", (size_t)(buffer != NULL), 0);
    if (buffer != NULL) {
        free(buffer);
    }
}

AMP_CAPI void amp_release_state(void *state_ptr) {
    _log_native_call("amp_release_state", (size_t)(state_ptr != NULL), 0);
    if (state_ptr == NULL) {
        return;
    }
    node_state_t *node_state = (node_state_t *)state_ptr;
    release_node_state(node_state);
}

#include <ctype.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#if defined(_WIN32) || defined(_WIN64)
#define AMP_API __declspec(dllexport)
#else
#define AMP_API
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

typedef struct EdgeRunnerControlHistory EdgeRunnerControlHistory;
typedef EdgeRunnerControlHistory AmpGraphControlHistory;
typedef struct EdgeRunnerParamView EdgeRunnerParamView;
typedef struct EdgeRunnerNodeInputs EdgeRunnerNodeInputs;
typedef struct EdgeRunnerNodeDescriptor EdgeRunnerNodeDescriptor;

extern EdgeRunnerControlHistory *amp_load_control_history(const uint8_t *blob, size_t blob_len, int frames_hint);
extern void amp_release_control_history(EdgeRunnerControlHistory *history);
extern int amp_run_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int channels,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    void **state,
    const EdgeRunnerControlHistory *history
);
extern void amp_free(double *buffer);
extern void amp_release_state(void *state);

typedef struct {
    double *data;
    size_t capacity;
    int in_use;
} buffer_pool_entry_t;

typedef struct {
    buffer_pool_entry_t *entries;
    size_t count;
} buffer_pool_t;

typedef struct {
    char *name;
    char *source_name;
    uint32_t source_index;
    double scale;
    int mode;  /* 0 -> add, 1 -> mul */
    int channel;
} mod_connection_t;

typedef struct {
    char *name;
    double *data;
    uint32_t batches;
    uint32_t channels;
    uint32_t frames;
} param_binding_t;

typedef struct {
    char *name;
    size_t name_len;
    char *type_name;
    size_t type_name_len;
    uint32_t type_id;
    char **audio_inputs;
    uint32_t audio_input_count;
    uint32_t *audio_indices;
    mod_connection_t *mod_connections;
    uint32_t mod_connection_count;
    char *params_json;
    size_t params_json_len;
    uint32_t channel_hint;
    param_binding_t *param_bindings;
    size_t param_binding_count;
    void *state;
    double *output;
    uint32_t batches;
    uint32_t channels;
    uint32_t frames;
    EdgeRunnerNodeDescriptor descriptor;
} runtime_node_t;

typedef struct AmpGraphRuntime {
    runtime_node_t *nodes;
    uint32_t node_count;
    uint32_t *execution_order;
    uint32_t sink_index;
    buffer_pool_t pool;
    uint32_t default_batches;
    uint32_t default_frames;
} AmpGraphRuntime;

static char *dup_string(const char *src, size_t length) {
    if (src == NULL || length == 0) {
        return NULL;
    }
    char *dest = (char *)malloc(length + 1);
    if (dest == NULL) {
        return NULL;
    }
    memcpy(dest, src, length);
    dest[length] = '\0';
    return dest;
}

/* Lightweight native-entry logger. Appends one-line records to logs/native_c_calls.log
   Format: <timestamp> <py_thread_state_ptr> <function> <arg1> <arg2>\n
   Keep this function minimal and tolerant of failures (best-effort logging only).
*/
/* If amp_log_native_call_external is provided by the main c_kernels module, use
   it to avoid repeated fopen/fclose. Otherwise fall back to the original
   best-effort fopen-based logging. */
extern void amp_log_native_call_external(const char *fn, size_t a, size_t b);
static void _log_native_call(const char *fn, size_t a, size_t b) {
    /* Prefer the external cached logger when available. We call it unconditionally
        if the symbol isn't resolved at link/load time the loader will fail, so
       to remain defensive we fall back to fopen-based logging below. */
    if (&amp_log_native_call_external) {
        amp_log_native_call_external(fn, a, b);
        return;
    }
    FILE *f = NULL;
    /* Best-effort: create/appends to logs/native_c_calls.log */
    f = fopen("logs/native_c_calls.log", "a");
    if (f == NULL) {
        return;
    }
    /* timestamp in seconds (wall-clock) */
    double t = (double)time(NULL);
    /* log the Python thread-state pointer (unique per Python thread) when available */
    void *py_ts = NULL;
    /* PyThreadState_Get is available because Python.h is included earlier in the file */
    py_ts = (void *)PyThreadState_Get();
    fprintf(f, "%.3f %p %s %zu %zu\n", t, py_ts, fn, a, b);
    fclose(f);
}

static void buffer_pool_destroy(buffer_pool_t *pool) {
    if (pool == NULL) {
        return;
    }
    if (pool->entries != NULL) {
        for (size_t i = 0; i < pool->count; ++i) {
            free(pool->entries[i].data);
            pool->entries[i].data = NULL;
            pool->entries[i].capacity = 0;
            pool->entries[i].in_use = 0;
        }
        free(pool->entries);
        pool->entries = NULL;
        pool->count = 0;
    }
}

static double *buffer_pool_acquire(buffer_pool_t *pool, size_t elements) {
    if (pool == NULL || elements == 0) {
        return NULL;
    }
    for (size_t i = 0; i < pool->count; ++i) {
        buffer_pool_entry_t *entry = &pool->entries[i];
        if (!entry->in_use && entry->capacity >= elements) {
            entry->in_use = 1;
            return entry->data;
        }
    }
    size_t new_index = pool->count;
    buffer_pool_entry_t *new_entries = (buffer_pool_entry_t *)realloc(
        pool->entries,
        (pool->count + 1) * sizeof(buffer_pool_entry_t)
    );
    if (new_entries == NULL) {
        return NULL;
    }
    pool->entries = new_entries;
    buffer_pool_entry_t *entry = &pool->entries[new_index];
    entry->data = (double *)malloc(elements * sizeof(double));
    if (entry->data == NULL) {
        return NULL;
    }
    entry->capacity = elements;
    entry->in_use = 1;
    pool->count += 1;
    return entry->data;
}

static void buffer_pool_reset(buffer_pool_t *pool) {
    if (pool == NULL) {
        return;
    }
    for (size_t i = 0; i < pool->count; ++i) {
        pool->entries[i].in_use = 0;
    }
}

static void buffer_pool_release(buffer_pool_t *pool, double *data) {
    if (pool == NULL || data == NULL) {
        return;
    }
    for (size_t i = 0; i < pool->count; ++i) {
        buffer_pool_entry_t *entry = &pool->entries[i];
        if (entry->data == data) {
            entry->in_use = 0;
            return;
        }
    }
}

static void destroy_runtime_node(runtime_node_t *node) {
    if (node == NULL) {
        return;
    }
    if (node->output != NULL) {
        amp_free(node->output);
        node->output = NULL;
    }
    if (node->state != NULL) {
        amp_release_state(node->state);
        node->state = NULL;
    }
    if (node->audio_inputs != NULL) {
        for (uint32_t i = 0; i < node->audio_input_count; ++i) {
            free(node->audio_inputs[i]);
        }
        free(node->audio_inputs);
    }
    free(node->audio_indices);
    if (node->mod_connections != NULL) {
        for (uint32_t i = 0; i < node->mod_connection_count; ++i) {
            free(node->mod_connections[i].name);
            free(node->mod_connections[i].source_name);
        }
        free(node->mod_connections);
    }
    if (node->param_bindings != NULL) {
        for (size_t i = 0; i < node->param_binding_count; ++i) {
            free(node->param_bindings[i].name);
            free(node->param_bindings[i].data);
        }
        free(node->param_bindings);
    }
    free(node->name);
    free(node->type_name);
    free(node->params_json);
}

static void release_runtime(AmpGraphRuntime *runtime) {
    if (runtime == NULL) {
        return;
    }
    if (runtime->nodes != NULL) {
        for (uint32_t i = 0; i < runtime->node_count; ++i) {
            destroy_runtime_node(&runtime->nodes[i]);
        }
        free(runtime->nodes);
    }
    free(runtime->execution_order);
    buffer_pool_destroy(&runtime->pool);
    free(runtime);
}

static int read_u32(const uint8_t **cursor, size_t *remaining, uint32_t *out) {
    if (cursor == NULL || remaining == NULL || out == NULL) {
        return 0;
    }
    if (*remaining < 4) {
        return 0;
    }
    const uint8_t *ptr = *cursor;
    *out = (uint32_t)ptr[0] | ((uint32_t)ptr[1] << 8) | ((uint32_t)ptr[2] << 16) | ((uint32_t)ptr[3] << 24);
    *cursor += 4;
    *remaining -= 4;
    return 1;
}

static int read_i32(const uint8_t **cursor, size_t *remaining, int32_t *out) {
    uint32_t value = 0;
    if (!read_u32(cursor, remaining, &value)) {
        return 0;
    }
    *out = (int32_t)value;
    return 1;
}

static int read_f32(const uint8_t **cursor, size_t *remaining, float *out) {
    if (cursor == NULL || remaining == NULL || out == NULL) {
        return 0;
    }
    if (*remaining < 4) {
        return 0;
    }
    uint32_t bits = 0;
    memcpy(&bits, *cursor, sizeof(uint32_t));
    float value = 0.0f;
    memcpy(&value, &bits, sizeof(float));
    *cursor += 4;
    *remaining -= 4;
    *out = value;
    return 1;
}

static int json_find_key(const char *json, size_t json_len, const char *key, const char **value) {
    if (json == NULL || key == NULL || value == NULL) {
        return 0;
    }
    size_t key_len = strlen(key);
    const char *cursor = json;
    const char *end = json + json_len;
    while (cursor < end) {
        const char *found = strstr(cursor, key);
        if (found == NULL || found >= end) {
            break;
        }
        const char *colon = strchr(found + key_len, ':');
        if (colon == NULL || colon >= end) {
            break;
        }
        cursor = colon + 1;
        while (cursor < end && isspace((unsigned char)*cursor)) {
            cursor++;
        }
        if (cursor < end) {
            *value = cursor;
            return 1;
        }
    }
    return 0;
}

static double json_get_double(const char *json, size_t json_len, const char *key, double default_value) {
    const char *cursor = NULL;
    if (!json_find_key(json, json_len, key, &cursor)) {
        return default_value;
    }
    char *endptr = NULL;
    double value = strtod(cursor, &endptr);
    if (endptr == cursor) {
        return default_value;
    }
    return value;
}

static int json_get_int(const char *json, size_t json_len, const char *key, int default_value) {
    double value = json_get_double(json, json_len, key, (double)default_value);
    return (int)lrint(value);
}

static int32_t find_node_index(AmpGraphRuntime *runtime, const char *name) {
    if (runtime == NULL || name == NULL) {
        return -1;
    }
    for (uint32_t i = 0; i < runtime->node_count; ++i) {
        if (runtime->nodes[i].name != NULL && strcmp(runtime->nodes[i].name, name) == 0) {
            return (int32_t)i;
        }
    }
    return -1;
}

static runtime_node_t *find_node_by_name(AmpGraphRuntime *runtime, const char *name) {
    int32_t idx = find_node_index(runtime, name);
    if (idx < 0) {
        return NULL;
    }
    return &runtime->nodes[idx];
}

static int resolve_node_references(AmpGraphRuntime *runtime) {
    if (runtime == NULL) {
        return 0;
    }
    for (uint32_t i = 0; i < runtime->node_count; ++i) {
        runtime_node_t *node = &runtime->nodes[i];
        if (node->audio_input_count > 0U) {
            node->audio_indices = (uint32_t *)calloc(node->audio_input_count, sizeof(uint32_t));
            if (node->audio_indices == NULL) {
                return 0;
            }
            for (uint32_t j = 0; j < node->audio_input_count; ++j) {
                int32_t idx = find_node_index(runtime, node->audio_inputs[j]);
                if (idx < 0) {
                    return 0;
                }
                node->audio_indices[j] = (uint32_t)idx;
            }
        }
        for (uint32_t m = 0; m < node->mod_connection_count; ++m) {
            mod_connection_t *conn = &node->mod_connections[m];
            int32_t idx = find_node_index(runtime, conn->source_name);
            if (idx < 0) {
                return 0;
            }
            conn->source_index = (uint32_t)idx;
        }
        node->channel_hint = (uint32_t)json_get_int(node->params_json, node->params_json_len, "channels", 1);
        if (node->channel_hint == 0U) {
            node->channel_hint = 1U;
        }
        node->descriptor.name = node->name;
        node->descriptor.name_len = node->name_len;
        node->descriptor.type_name = node->type_name;
        node->descriptor.type_len = node->type_name_len;
        node->descriptor.params_json = node->params_json;
        node->descriptor.params_len = node->params_json_len;
    }
    return 1;
}

static int parse_node_blob(AmpGraphRuntime *runtime, const uint8_t *blob, size_t blob_len) {
    if (runtime == NULL || blob == NULL) {
        return 0;
    }
    const uint8_t *cursor = blob;
    size_t remaining = blob_len;
    uint32_t node_count = 0;
    if (!read_u32(&cursor, &remaining, &node_count)) {
        return 0;
    }
    runtime->node_count = node_count;
    runtime->nodes = (runtime_node_t *)calloc(node_count, sizeof(runtime_node_t));
    if (runtime->nodes == NULL) {
        return 0;
    }
    for (uint32_t i = 0; i < node_count; ++i) {
        runtime_node_t *node = &runtime->nodes[i];
        uint32_t header[8];
        for (size_t h = 0; h < 8; ++h) {
            if (!read_u32(&cursor, &remaining, &header[h])) {
                return 0;
            }
        }
        uint32_t type_id = header[0];
        uint32_t name_len = header[1];
        uint32_t type_len = header[2];
        uint32_t audio_count = header[3];
        uint32_t mod_count = header[4];
        uint32_t param_buffer_count = header[5];
        uint32_t buffer_shape_count = header[6];
        uint32_t params_json_len = header[7];
        if (remaining < name_len + type_len) {
            return 0;
        }
        node->type_id = type_id;
        node->name = dup_string((const char *)cursor, name_len);
        node->name_len = name_len;
        cursor += name_len;
        remaining -= name_len;
        node->type_name = dup_string((const char *)cursor, type_len);
        node->type_name_len = type_len;
        cursor += type_len;
        remaining -= type_len;
        node->audio_input_count = audio_count;
        if (audio_count > 0U) {
            node->audio_inputs = (char **)calloc(audio_count, sizeof(char *));
            if (node->audio_inputs == NULL) {
                return 0;
            }
            for (uint32_t a = 0; a < audio_count; ++a) {
                uint32_t src_len = 0;
                if (!read_u32(&cursor, &remaining, &src_len)) {
                    return 0;
                }
                if (remaining < src_len) {
                    return 0;
                }
                node->audio_inputs[a] = dup_string((const char *)cursor, src_len);
                cursor += src_len;
                remaining -= src_len;
            }
        }
        node->mod_connection_count = mod_count;
        if (mod_count > 0U) {
            node->mod_connections = (mod_connection_t *)calloc(mod_count, sizeof(mod_connection_t));
            if (node->mod_connections == NULL) {
                return 0;
            }
            for (uint32_t m = 0; m < mod_count; ++m) {
                uint32_t source_len = 0;
                uint32_t param_len = 0;
                uint32_t mode_code = 0;
                float scale = 0.0f;
                int32_t channel = -1;
                if (!read_u32(&cursor, &remaining, &source_len) ||
                    !read_u32(&cursor, &remaining, &param_len) ||
                    !read_u32(&cursor, &remaining, &mode_code) ||
                    !read_f32(&cursor, &remaining, &scale) ||
                    !read_i32(&cursor, &remaining, &channel)) {
                    return 0;
                }
                if (remaining < source_len + param_len) {
                    return 0;
                }
                mod_connection_t *conn = &node->mod_connections[m];
                conn->source_name = dup_string((const char *)cursor, source_len);
                cursor += source_len;
                remaining -= source_len;
                conn->name = dup_string((const char *)cursor, param_len);
                cursor += param_len;
                remaining -= param_len;
                conn->scale = (double)scale;
                conn->mode = (mode_code == 1U) ? 1 : 0;
                conn->channel = (int)channel;
                conn->source_index = 0U;
            }
        }
        for (uint32_t p = 0; p < param_buffer_count; ++p) {
            uint32_t name_size = 0;
            if (!read_u32(&cursor, &remaining, &name_size)) {
                return 0;
            }
            int32_t dims[3];
            int32_t byte_len = 0;
            if (!read_i32(&cursor, &remaining, &dims[0]) ||
                !read_i32(&cursor, &remaining, &dims[1]) ||
                !read_i32(&cursor, &remaining, &dims[2]) ||
                !read_i32(&cursor, &remaining, &byte_len)) {
                return 0;
            }
            if (remaining < name_size + (size_t)byte_len) {
                return 0;
            }
            cursor += name_size + (size_t)byte_len;
            remaining -= name_size + (size_t)byte_len;
        }
        size_t shapes_bytes = (size_t)buffer_shape_count * 3U * sizeof(uint32_t);
        if (remaining < shapes_bytes) {
            return 0;
        }
        cursor += shapes_bytes;
        remaining -= shapes_bytes;
        if (remaining < params_json_len) {
            return 0;
        }
        node->params_json = dup_string((const char *)cursor, params_json_len);
        node->params_json_len = params_json_len;
        cursor += params_json_len;
        remaining -= params_json_len;
    }
    return resolve_node_references(runtime);
}

static int parse_plan_blob(AmpGraphRuntime *runtime, const uint8_t *blob, size_t blob_len) {
    if (runtime == NULL || blob == NULL) {
        return 0;
    }
    if (blob_len < 12) {
        return 0;
    }
    if (memcmp(blob, "AMPL", 4) != 0) {
        return 0;
    }
    const uint8_t *cursor = blob + 4;
    size_t remaining = blob_len - 4;
    uint32_t version = 0;
    uint32_t node_count = 0;
    if (!read_u32(&cursor, &remaining, &version) || !read_u32(&cursor, &remaining, &node_count)) {
        return 0;
    }
    if (node_count != runtime->node_count) {
        return 0;
    }
    runtime->execution_order = (uint32_t *)calloc(node_count, sizeof(uint32_t));
    if (runtime->execution_order == NULL) {
        return 0;
    }
    for (uint32_t i = 0; i < node_count; ++i) {
        uint32_t function_id = 0;
        uint32_t name_len = 0;
        uint32_t audio_offset = 0;
        uint32_t audio_span = 0;
        uint32_t param_count = 0;
        if (!read_u32(&cursor, &remaining, &function_id) ||
            !read_u32(&cursor, &remaining, &name_len) ||
            !read_u32(&cursor, &remaining, &audio_offset) ||
            !read_u32(&cursor, &remaining, &audio_span) ||
            !read_u32(&cursor, &remaining, &param_count)) {
            return 0;
        }
        if (remaining < name_len) {
            return 0;
        }
        char *name = dup_string((const char *)cursor, name_len);
        cursor += name_len;
        remaining -= name_len;
        for (uint32_t p = 0; p < param_count; ++p) {
            uint32_t param_name_len = 0;
            uint32_t offset = 0;
            uint32_t span = 0;
            if (!read_u32(&cursor, &remaining, &param_name_len) ||
                !read_u32(&cursor, &remaining, &offset) ||
                !read_u32(&cursor, &remaining, &span)) {
                free(name);
                return 0;
            }
            if (remaining < param_name_len) {
                free(name);
                return 0;
            }
            cursor += param_name_len;
            remaining -= param_name_len;
        }
        int32_t idx = find_node_index(runtime, name);
        free(name);
        if (idx < 0 || function_id >= node_count) {
            return 0;
        }
        runtime->execution_order[function_id] = (uint32_t)idx;
    }
    runtime->sink_index = runtime->node_count > 0U ? runtime->execution_order[runtime->node_count - 1U] : 0U;
    (void)version;
    return 1;
}

static param_binding_t *find_param_binding(runtime_node_t *node, const char *name) {
    if (node == NULL || name == NULL) {
        return NULL;
    }
    for (size_t i = 0; i < node->param_binding_count; ++i) {
        if (node->param_bindings[i].name != NULL && strcmp(node->param_bindings[i].name, name) == 0) {
            return &node->param_bindings[i];
        }
    }
    return NULL;
}

static double *copy_param_binding(buffer_pool_t *pool, const param_binding_t *binding) {
    if (pool == NULL || binding == NULL) {
        return NULL;
    }
    size_t total = (size_t)binding->batches * (size_t)binding->channels * (size_t)binding->frames;
    if (total == 0) {
        return NULL;
    }
    double *dest = buffer_pool_acquire(pool, total);
    if (dest == NULL) {
        return NULL;
    }
    memcpy(dest, binding->data, total * sizeof(double));
    return dest;
}

static int apply_mod_connections(
    AmpGraphRuntime *runtime,
    runtime_node_t *node,
    const char *param_name,
    double *buffer,
    size_t total,
    uint32_t batches,
    uint32_t channels,
    uint32_t frames
) {
    if (runtime == NULL || node == NULL || param_name == NULL || buffer == NULL) {
        return 0;
    }
    (void)total;
    for (uint32_t i = 0; i < node->mod_connection_count; ++i) {
        mod_connection_t *conn = &node->mod_connections[i];
        if (conn->name == NULL || strcmp(conn->name, param_name) != 0) {
            continue;
        }
        if (conn->source_index >= runtime->node_count) {
            return 0;
        }
        runtime_node_t *source = &runtime->nodes[conn->source_index];
        if (source->output == NULL) {
            return 0;
        }
        uint32_t src_batches = source->batches;
        uint32_t src_channels = source->channels;
        uint32_t src_frames = source->frames;
        if (src_batches != batches || src_frames != frames) {
            return 0;
        }
        const double *src = source->output;
        if (conn->channel >= 0) {
            if ((uint32_t)conn->channel >= src_channels) {
                return 0;
            }
            for (uint32_t b = 0; b < batches; ++b) {
                for (uint32_t c = 0; c < channels; ++c) {
                    for (uint32_t f = 0; f < frames; ++f) {
                        size_t dst_idx = ((size_t)b * (size_t)channels + (size_t)c) * (size_t)frames + (size_t)f;
                        size_t src_idx = ((size_t)b * (size_t)src_channels + (size_t)conn->channel) * (size_t)frames + (size_t)f;
                        if (conn->mode == 0) {
                            buffer[dst_idx] += conn->scale * src[src_idx];
                        } else {
                            buffer[dst_idx] *= 1.0 + conn->scale * src[src_idx];
                        }
                    }
                }
            }
        } else {
            if (src_channels != channels && src_channels != 1U) {
                return 0;
            }
            for (uint32_t b = 0; b < batches; ++b) {
                for (uint32_t c = 0; c < channels; ++c) {
                    uint32_t src_c = src_channels == 1U ? 0U : c;
                    for (uint32_t f = 0; f < frames; ++f) {
                        size_t dst_idx = ((size_t)b * (size_t)channels + (size_t)c) * (size_t)frames + (size_t)f;
                        size_t src_idx = ((size_t)b * (size_t)src_channels + (size_t)src_c) * (size_t)frames + (size_t)f;
                        if (conn->mode == 0) {
                            buffer[dst_idx] += conn->scale * src[src_idx];
                        } else {
                            buffer[dst_idx] *= 1.0 + conn->scale * src[src_idx];
                        }
                    }
                }
            }
        }
    }
    return 1;
}

static int prepare_param_buffer(
    AmpGraphRuntime *runtime,
    runtime_node_t *node,
    const char *param_name,
    buffer_pool_t *pool,
    uint32_t batches,
    uint32_t channels,
    uint32_t frames,
    double default_value,
    double **out_buffer
) {
    if (out_buffer == NULL) {
        return 0;
    }
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    if (total == 0) {
        return 0;
    }
    param_binding_t *binding = find_param_binding(node, param_name);
    double *buffer = NULL;
    if (binding != NULL) {
        if (binding->batches != batches || binding->channels != channels || binding->frames != frames) {
            return 0;
        }
        buffer = copy_param_binding(pool, binding);
    } else {
        buffer = buffer_pool_acquire(pool, total);
        if (buffer != NULL) {
            for (size_t i = 0; i < total; ++i) {
                buffer[i] = default_value;
            }
        }
    }
    if (buffer == NULL) {
        return 0;
    }
    if (!apply_mod_connections(runtime, node, param_name, buffer, total, batches, channels, frames)) {
        buffer_pool_release(pool, buffer);
        return 0;
    }
    *out_buffer = buffer;
    return 1;
}

static int collect_param_names(runtime_node_t *node, const char ***names_out, size_t *count_out) {
    if (node == NULL || names_out == NULL || count_out == NULL) {
        return 0;
    }
    size_t capacity = node->param_binding_count + node->mod_connection_count + 4U;
    if (capacity == 0) {
        *names_out = NULL;
        *count_out = 0;
        return 1;
    }
    const char **names = (const char **)calloc(capacity, sizeof(const char *));
    if (names == NULL) {
        return 0;
    }
    size_t count = 0;
    for (size_t i = 0; i < node->param_binding_count; ++i) {
        const char *name = node->param_bindings[i].name;
        if (name == NULL) {
            continue;
        }
        int seen = 0;
        for (size_t j = 0; j < count; ++j) {
            if (strcmp(names[j], name) == 0) {
                seen = 1;
                break;
            }
        }
        if (!seen) {
            names[count++] = name;
        }
    }
    for (uint32_t i = 0; i < node->mod_connection_count; ++i) {
        const char *name = node->mod_connections[i].name;
        if (name == NULL) {
            continue;
        }
        int seen = 0;
        for (size_t j = 0; j < count; ++j) {
            if (strcmp(names[j], name) == 0) {
                seen = 1;
                break;
            }
        }
        if (!seen) {
            if (count >= capacity) {
                const char **new_names = (const char **)realloc(names, (capacity + 4U) * sizeof(const char *));
                if (new_names == NULL) {
                    free(names);
                    return 0;
                }
                names = new_names;
                capacity += 4U;
            }
            names[count++] = name;
        }
    }
    *names_out = names;
    *count_out = count;
    return 1;
}

static int build_param_views(
    AmpGraphRuntime *runtime,
    runtime_node_t *node,
    uint32_t batches,
    uint32_t channels,
    uint32_t frames,
    EdgeRunnerParamView **views_out,
    uint32_t *count_out,
    double ***owned_buffers_out,
    uint32_t *owned_count_out
) {
    if (runtime == NULL || node == NULL || views_out == NULL || count_out == NULL || owned_buffers_out == NULL || owned_count_out == NULL) {
        return 0;
    }
    const char **names = NULL;
    size_t name_count = 0;
    if (!collect_param_names(node, &names, &name_count)) {
        return 0;
    }
    if (name_count == 0) {
        *views_out = NULL;
        *count_out = 0;
        *owned_buffers_out = NULL;
        *owned_count_out = 0;
        free(names);
        return 1;
    }
    EdgeRunnerParamView *views = (EdgeRunnerParamView *)calloc(name_count, sizeof(EdgeRunnerParamView));
    if (views == NULL) {
        free(names);
        return 0;
    }
    double **owned = (double **)calloc(name_count, sizeof(double *));
    if (owned == NULL) {
        free(views);
        free(names);
        return 0;
    }
    uint32_t owned_count = 0;
    for (size_t i = 0; i < name_count; ++i) {
        const char *param_name = names[i];
        double default_value = json_get_double(node->params_json, node->params_json_len, param_name, 0.0);
        double *buffer = NULL;
        if (!prepare_param_buffer(runtime, node, param_name, &runtime->pool, batches, channels, frames, default_value, &buffer)) {
            free(owned);
            free(views);
            free(names);
            return 0;
        }
        views[i].name = param_name;
        views[i].batches = batches;
        views[i].channels = channels;
        views[i].frames = frames;
        views[i].data = buffer;
        owned[owned_count++] = buffer;
    }
    free(names);
    *views_out = views;
    *count_out = (uint32_t)name_count;
    *owned_buffers_out = owned;
    *owned_count_out = owned_count;
    return 1;
}

static void release_param_views(buffer_pool_t *pool, EdgeRunnerParamView *views, uint32_t count, double **owned, uint32_t owned_count) {
    (void)count;
    if (owned != NULL) {
        for (uint32_t i = 0; i < owned_count; ++i) {
            buffer_pool_release(pool, owned[i]);
        }
        free(owned);
    }
    free(views);
}

static double *merge_audio_inputs(
    AmpGraphRuntime *runtime,
    runtime_node_t *node,
    uint32_t *out_batches,
    uint32_t *out_channels,
    uint32_t *out_frames,
    double ***scratch_buffers,
    uint32_t *scratch_count
) {
    if (runtime == NULL || node == NULL || out_batches == NULL || out_channels == NULL || out_frames == NULL || scratch_buffers == NULL || scratch_count == NULL) {
        return NULL;
    }
    *scratch_buffers = NULL;
    *scratch_count = 0;
    if (node->audio_input_count == 0U) {
        *out_batches = runtime->default_batches > 0U ? runtime->default_batches : 1U;
        *out_channels = node->channel_hint > 0U ? node->channel_hint : 1U;
        *out_frames = runtime->default_frames > 0U ? runtime->default_frames : 1U;
        return NULL;
    }
    double **owned = NULL;
    uint32_t owned_count = 0;
    uint32_t batches = 0;
    uint32_t frames = 0;
    uint32_t total_channels = 0;
    for (uint32_t i = 0; i < node->audio_input_count; ++i) {
        uint32_t src_idx = node->audio_indices[i];
        if (src_idx >= runtime->node_count) {
            free(owned);
            return NULL;
        }
        runtime_node_t *source = &runtime->nodes[src_idx];
        if (source->output == NULL) {
            free(owned);
            return NULL;
        }
        if (i == 0) {
            batches = source->batches;
            frames = source->frames;
        } else {
            if (source->batches != batches || source->frames != frames) {
                free(owned);
                return NULL;
            }
        }
        total_channels += source->channels;
    }
    if (total_channels == 0U) {
        free(owned);
        return NULL;
    }
    if (node->audio_input_count == 1U) {
        runtime_node_t *source = &runtime->nodes[node->audio_indices[0]];
        *out_batches = source->batches;
        *out_channels = source->channels;
        *out_frames = source->frames;
        return source->output;
    }
    size_t total = (size_t)batches * (size_t)total_channels * (size_t)frames;
    double *buffer = buffer_pool_acquire(&runtime->pool, total);
    if (buffer == NULL) {
        free(owned);
        return NULL;
    }
    size_t offset = 0;
    for (uint32_t i = 0; i < node->audio_input_count; ++i) {
        runtime_node_t *source = &runtime->nodes[node->audio_indices[i]];
        size_t block = (size_t)source->batches * (size_t)source->channels * (size_t)source->frames;
        memcpy(buffer + offset, source->output, block * sizeof(double));
        offset += block;
    }
    owned = (double **)calloc(1, sizeof(double *));
    if (owned == NULL) {
        buffer_pool_release(&runtime->pool, buffer);
        return NULL;
    }
    owned[0] = buffer;
    *scratch_buffers = owned;
    *scratch_count = 1U;
    *out_batches = batches;
    *out_channels = total_channels;
    *out_frames = frames;
    return buffer;
}

AMP_API AmpGraphRuntime *amp_graph_runtime_create(
    const uint8_t *descriptor_blob,
    size_t descriptor_len,
    const uint8_t *plan_blob,
    size_t plan_len
) {
    AmpGraphRuntime *runtime = (AmpGraphRuntime *)calloc(1, sizeof(AmpGraphRuntime));
    if (runtime == NULL) {
        return NULL;
    }
    runtime->default_batches = 1U;
    runtime->default_frames = 0U;
    if (!parse_node_blob(runtime, descriptor_blob, descriptor_len)) {
        release_runtime(runtime);
        return NULL;
    }
    if (!parse_plan_blob(runtime, plan_blob, plan_len)) {
        release_runtime(runtime);
        return NULL;
    }
    return runtime;
}

AMP_API void amp_graph_runtime_destroy(AmpGraphRuntime *runtime) {
    release_runtime(runtime);
}

AMP_API int amp_graph_runtime_configure(AmpGraphRuntime *runtime, uint32_t batches, uint32_t frames) {
    if (runtime == NULL) {
        return -1;
    }
    runtime->default_batches = batches > 0U ? batches : 1U;
    runtime->default_frames = frames;
    return 0;
}

AMP_API void amp_graph_runtime_clear_params(AmpGraphRuntime *runtime) {
    if (runtime == NULL) {
        return;
    }
    for (uint32_t i = 0; i < runtime->node_count; ++i) {
        runtime_node_t *node = &runtime->nodes[i];
        if (node->param_bindings != NULL) {
            for (size_t j = 0; j < node->param_binding_count; ++j) {
                free(node->param_bindings[j].name);
                free(node->param_bindings[j].data);
            }
            free(node->param_bindings);
            node->param_bindings = NULL;
            node->param_binding_count = 0;
        }
    }
}

AMP_API int amp_graph_runtime_set_param(
    AmpGraphRuntime *runtime,
    const char *node_name,
    const char *param_name,
    const double *data,
    uint32_t batches,
    uint32_t channels,
    uint32_t frames
) {
    if (runtime == NULL || node_name == NULL || param_name == NULL || data == NULL) {
        return -1;
    }
    runtime_node_t *node = find_node_by_name(runtime, node_name);
    if (node == NULL) {
        return -1;
    }
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    if (total == 0) {
        return -1;
    }
    double *copy = (double *)malloc(total * sizeof(double));
    if (copy == NULL) {
        return -1;
    }
    memcpy(copy, data, total * sizeof(double));
    param_binding_t *binding = find_param_binding(node, param_name);
    if (binding != NULL) {
        free(binding->data);
        binding->data = copy;
        binding->batches = batches;
        binding->channels = channels;
        binding->frames = frames;
        return 0;
    }
    param_binding_t *new_bindings = (param_binding_t *)realloc(
        node->param_bindings,
        (node->param_binding_count + 1U) * sizeof(param_binding_t)
    );
    if (new_bindings == NULL) {
        free(copy);
        return -1;
    }
    node->param_bindings = new_bindings;
    binding = &node->param_bindings[node->param_binding_count];
    binding->name = dup_string(param_name, strlen(param_name));
    if (binding->name == NULL) {
        free(copy);
        return -1;
    }
    binding->data = copy;
    binding->batches = batches;
    binding->channels = channels;
    binding->frames = frames;
    node->param_binding_count += 1U;
    return 0;
}

AMP_API int amp_graph_runtime_execute(
    AmpGraphRuntime *runtime,
    const uint8_t *control_blob,
    size_t control_len,
    int frames_hint,
    double sample_rate,
    double **out_buffer,
    uint32_t *out_batches,
    uint32_t *out_channels,
    uint32_t *out_frames
) {
    if (runtime == NULL || out_buffer == NULL || out_batches == NULL || out_channels == NULL || out_frames == NULL) {
        return -1;
    }
    EdgeRunnerControlHistory *history = NULL;
    if (control_blob != NULL && control_len > 0U) {
        history = amp_load_control_history(control_blob, control_len, frames_hint);
        if (history == NULL) {
            return -1;
        }
    }
    for (uint32_t i = 0; i < runtime->node_count; ++i) {
        runtime_node_t *node = &runtime->nodes[i];
        if (node->output != NULL) {
            amp_free(node->output);
            node->output = NULL;
        }
        node->batches = 0;
        node->channels = 0;
        node->frames = 0;
    }
    buffer_pool_reset(&runtime->pool);
    int status = 0;
    for (uint32_t order = 0; order < runtime->node_count; ++order) {
        uint32_t node_idx = runtime->execution_order[order];
        runtime_node_t *node = &runtime->nodes[node_idx];
        uint32_t batches = runtime->default_batches > 0U ? runtime->default_batches : 1U;
        uint32_t frames = runtime->default_frames > 0U ? runtime->default_frames : 1U;
        uint32_t input_channels = node->channel_hint > 0U ? node->channel_hint : 1U;
        double **audio_owned = NULL;
        uint32_t audio_owned_count = 0;
        double *audio_data = merge_audio_inputs(runtime, node, &batches, &input_channels, &frames, &audio_owned, &audio_owned_count);
        EdgeRunnerParamView *param_views = NULL;
        uint32_t param_count = 0;
        double **owned_buffers = NULL;
        uint32_t owned_count = 0;
        if (!build_param_views(runtime, node, batches, input_channels, frames, &param_views, &param_count, &owned_buffers, &owned_count)) {
            status = -1;
            if (audio_owned != NULL) {
                for (uint32_t i = 0; i < audio_owned_count; ++i) {
                    buffer_pool_release(&runtime->pool, audio_owned[i]);
                }
                free(audio_owned);
            }
            break;
        }
        EdgeRunnerNodeInputs inputs;
        memset(&inputs, 0, sizeof(inputs));
        if (audio_data != NULL) {
            inputs.audio.has_audio = 1;
            inputs.audio.batches = batches;
            inputs.audio.channels = input_channels;
            inputs.audio.frames = frames;
            inputs.audio.data = audio_data;
        } else {
            inputs.audio.has_audio = 0;
            inputs.audio.batches = batches;
            inputs.audio.channels = 0;
            inputs.audio.frames = frames;
            inputs.audio.data = NULL;
        }
        if (param_count > 0) {
            inputs.params.count = param_count;
            inputs.params.items = param_views;
        } else {
            inputs.params.count = 0;
            inputs.params.items = NULL;
        }
        double *out_ptr = NULL;
        int out_ch = 0;
        void *state = node->state;
        status = amp_run_node(
            &node->descriptor,
            &inputs,
            (int)batches,
            (int)input_channels,
            (int)frames,
            sample_rate,
            &out_ptr,
            &out_ch,
            &state,
            history
        );
        if (status != 0) {
            release_param_views(&runtime->pool, param_views, param_count, owned_buffers, owned_count);
            if (audio_owned != NULL) {
                for (uint32_t i = 0; i < audio_owned_count; ++i) {
                    buffer_pool_release(&runtime->pool, audio_owned[i]);
                }
                free(audio_owned);
            }
            break;
        }
        if (node->state != state) {
            if (node->state != NULL) {
                amp_release_state(node->state);
            }
            node->state = state;
        }
        node->output = out_ptr;
        node->batches = batches;
        node->channels = (uint32_t)out_ch;
        node->frames = frames;
        release_param_views(&runtime->pool, param_views, param_count, owned_buffers, owned_count);
        if (audio_owned != NULL) {
            for (uint32_t i = 0; i < audio_owned_count; ++i) {
                buffer_pool_release(&runtime->pool, audio_owned[i]);
            }
            free(audio_owned);
        }
    }
    if (history != NULL) {
        amp_release_control_history(history);
    }
    if (status != 0) {
        return status;
    }
    runtime_node_t *sink = &runtime->nodes[runtime->sink_index];
    if (sink->output == NULL) {
        return -1;
    }
    *out_buffer = sink->output;
    *out_batches = sink->batches;
    *out_channels = sink->channels;
    *out_frames = sink->frames;
    return 0;
}

AMP_API void amp_graph_runtime_buffer_free(double *buffer) {
    if (buffer != NULL) {
        amp_free(buffer);
    }
}

AMP_API AmpGraphControlHistory *amp_graph_history_load(
    const uint8_t *blob,
    size_t blob_len,
    int frames_hint
) {
    return amp_load_control_history(blob, blob_len, frames_hint);
}

AMP_API void amp_graph_history_destroy(AmpGraphControlHistory *history) {
    amp_release_control_history(history);
}


/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 37), // AmpGraphControlHistory *()(unsigned char const *, size_t, int)
/*  1 */ _CFFI_OP(_CFFI_OP_POINTER, 48), // unsigned char const *
/*  2 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28), // size_t
/*  3 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7), // int
/*  4 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  5 */ _CFFI_OP(_CFFI_OP_FUNCTION, 12), // AmpGraphRuntime *()(unsigned char const *, size_t, unsigned char const *, size_t)
/*  6 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/*  7 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/*  8 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/*  9 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 10 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 11 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3), // int()(AmpGraphRuntime *, char const *, char const *, double const *, unsigned int, unsigned int, unsigned int)
/* 12 */ _CFFI_OP(_CFFI_OP_POINTER, 46), // AmpGraphRuntime *
/* 13 */ _CFFI_OP(_CFFI_OP_POINTER, 47), // char const *
/* 14 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 15 */ _CFFI_OP(_CFFI_OP_POINTER, 25), // double const *
/* 16 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8), // unsigned int
/* 17 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 18 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 19 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 20 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3), // int()(AmpGraphRuntime *, unsigned char const *, size_t, int, double, double * *, unsigned int *, unsigned int *, unsigned int *)
/* 21 */ _CFFI_OP(_CFFI_OP_NOOP, 12),
/* 22 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 23 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 24 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 25 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14), // double
/* 26 */ _CFFI_OP(_CFFI_OP_POINTER, 43), // double * *
/* 27 */ _CFFI_OP(_CFFI_OP_POINTER, 16), // unsigned int *
/* 28 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 29 */ _CFFI_OP(_CFFI_OP_NOOP, 27),
/* 30 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 31 */ _CFFI_OP(_CFFI_OP_FUNCTION, 3), // int()(AmpGraphRuntime *, unsigned int, unsigned int)
/* 32 */ _CFFI_OP(_CFFI_OP_NOOP, 12),
/* 33 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 34 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8),
/* 35 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 36 */ _CFFI_OP(_CFFI_OP_FUNCTION, 49), // void()(AmpGraphControlHistory *)
/* 37 */ _CFFI_OP(_CFFI_OP_POINTER, 45), // AmpGraphControlHistory *
/* 38 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 39 */ _CFFI_OP(_CFFI_OP_FUNCTION, 49), // void()(AmpGraphRuntime *)
/* 40 */ _CFFI_OP(_CFFI_OP_NOOP, 12),
/* 41 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 42 */ _CFFI_OP(_CFFI_OP_FUNCTION, 49), // void()(double *)
/* 43 */ _CFFI_OP(_CFFI_OP_POINTER, 25), // double *
/* 44 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 45 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // AmpGraphControlHistory
/* 46 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // AmpGraphRuntime
/* 47 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
/* 48 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 4), // unsigned char
/* 49 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
};

static void _cffi_d_amp_graph_history_destroy(AmpGraphControlHistory * x0)
{
  amp_graph_history_destroy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_graph_history_destroy(PyObject *self, PyObject *arg0)
{
  AmpGraphControlHistory * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(37), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (AmpGraphControlHistory *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(37), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { amp_graph_history_destroy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_amp_graph_history_destroy _cffi_d_amp_graph_history_destroy
#endif

static AmpGraphControlHistory * _cffi_d_amp_graph_history_load(unsigned char const * x0, size_t x1, int x2)
{
  return amp_graph_history_load(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_graph_history_load(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  size_t x1;
  int x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  AmpGraphControlHistory * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "amp_graph_history_load", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (unsigned char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = amp_graph_history_load(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(37));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_amp_graph_history_load _cffi_d_amp_graph_history_load
#endif

static void _cffi_d_amp_graph_runtime_buffer_free(double * x0)
{
  amp_graph_runtime_buffer_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_graph_runtime_buffer_free(PyObject *self, PyObject *arg0)
{
  double * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(43), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(43), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { amp_graph_runtime_buffer_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_amp_graph_runtime_buffer_free _cffi_d_amp_graph_runtime_buffer_free
#endif

static void _cffi_d_amp_graph_runtime_clear_params(AmpGraphRuntime * x0)
{
  amp_graph_runtime_clear_params(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_graph_runtime_clear_params(PyObject *self, PyObject *arg0)
{
  AmpGraphRuntime * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(12), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (AmpGraphRuntime *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(12), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { amp_graph_runtime_clear_params(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_amp_graph_runtime_clear_params _cffi_d_amp_graph_runtime_clear_params
#endif

static int _cffi_d_amp_graph_runtime_configure(AmpGraphRuntime * x0, unsigned int x1, unsigned int x2)
{
  return amp_graph_runtime_configure(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_graph_runtime_configure(PyObject *self, PyObject *args)
{
  AmpGraphRuntime * x0;
  unsigned int x1;
  unsigned int x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "amp_graph_runtime_configure", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(12), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (AmpGraphRuntime *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(12), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, unsigned int);
  if (x1 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, unsigned int);
  if (x2 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = amp_graph_runtime_configure(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_amp_graph_runtime_configure _cffi_d_amp_graph_runtime_configure
#endif

static AmpGraphRuntime * _cffi_d_amp_graph_runtime_create(unsigned char const * x0, size_t x1, unsigned char const * x2, size_t x3)
{
  return amp_graph_runtime_create(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_graph_runtime_create(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  size_t x1;
  unsigned char const * x2;
  size_t x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  AmpGraphRuntime * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "amp_graph_runtime_create", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (unsigned char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (unsigned char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, size_t);
  if (x3 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = amp_graph_runtime_create(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(12));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_amp_graph_runtime_create _cffi_d_amp_graph_runtime_create
#endif

static void _cffi_d_amp_graph_runtime_destroy(AmpGraphRuntime * x0)
{
  amp_graph_runtime_destroy(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_graph_runtime_destroy(PyObject *self, PyObject *arg0)
{
  AmpGraphRuntime * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(12), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (AmpGraphRuntime *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(12), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { amp_graph_runtime_destroy(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_amp_graph_runtime_destroy _cffi_d_amp_graph_runtime_destroy
#endif

static int _cffi_d_amp_graph_runtime_execute(AmpGraphRuntime * x0, unsigned char const * x1, size_t x2, int x3, double x4, double * * x5, unsigned int * x6, unsigned int * x7, unsigned int * x8)
{
  return amp_graph_runtime_execute(x0, x1, x2, x3, x4, x5, x6, x7, x8);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_graph_runtime_execute(PyObject *self, PyObject *args)
{
  AmpGraphRuntime * x0;
  unsigned char const * x1;
  size_t x2;
  int x3;
  double x4;
  double * * x5;
  unsigned int * x6;
  unsigned int * x7;
  unsigned int * x8;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;

  if (!PyArg_UnpackTuple(args, "amp_graph_runtime_execute", 9, 9, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(12), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (AmpGraphRuntime *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(12), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (unsigned char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = (double)_cffi_to_c_double(arg4);
  if (x4 == (double)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(26), arg5, (char **)&x5);
  if (datasize != 0) {
    x5 = ((size_t)datasize) <= 640 ? (double * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(26), arg5, (char **)&x5,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg6, (char **)&x6);
  if (datasize != 0) {
    x6 = ((size_t)datasize) <= 640 ? (unsigned int *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg6, (char **)&x6,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg7, (char **)&x7);
  if (datasize != 0) {
    x7 = ((size_t)datasize) <= 640 ? (unsigned int *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg7, (char **)&x7,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg8, (char **)&x8);
  if (datasize != 0) {
    x8 = ((size_t)datasize) <= 640 ? (unsigned int *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg8, (char **)&x8,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = amp_graph_runtime_execute(x0, x1, x2, x3, x4, x5, x6, x7, x8); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_amp_graph_runtime_execute _cffi_d_amp_graph_runtime_execute
#endif

static int _cffi_d_amp_graph_runtime_set_param(AmpGraphRuntime * x0, char const * x1, char const * x2, double const * x3, unsigned int x4, unsigned int x5, unsigned int x6)
{
  return amp_graph_runtime_set_param(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_graph_runtime_set_param(PyObject *self, PyObject *args)
{
  AmpGraphRuntime * x0;
  char const * x1;
  char const * x2;
  double const * x3;
  unsigned int x4;
  unsigned int x5;
  unsigned int x6;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "amp_graph_runtime_set_param", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(12), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (AmpGraphRuntime *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(12), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(15), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(15), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, unsigned int);
  if (x4 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, unsigned int);
  if (x5 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, unsigned int);
  if (x6 == (unsigned int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = amp_graph_runtime_set_param(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_amp_graph_runtime_set_param _cffi_d_amp_graph_runtime_set_param
#endif

static const struct _cffi_global_s _cffi_globals[] = {
  { "amp_graph_history_destroy", (void *)_cffi_f_amp_graph_history_destroy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 36), (void *)_cffi_d_amp_graph_history_destroy },
  { "amp_graph_history_load", (void *)_cffi_f_amp_graph_history_load, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 0), (void *)_cffi_d_amp_graph_history_load },
  { "amp_graph_runtime_buffer_free", (void *)_cffi_f_amp_graph_runtime_buffer_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 42), (void *)_cffi_d_amp_graph_runtime_buffer_free },
  { "amp_graph_runtime_clear_params", (void *)_cffi_f_amp_graph_runtime_clear_params, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 39), (void *)_cffi_d_amp_graph_runtime_clear_params },
  { "amp_graph_runtime_configure", (void *)_cffi_f_amp_graph_runtime_configure, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 31), (void *)_cffi_d_amp_graph_runtime_configure },
  { "amp_graph_runtime_create", (void *)_cffi_f_amp_graph_runtime_create, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 5), (void *)_cffi_d_amp_graph_runtime_create },
  { "amp_graph_runtime_destroy", (void *)_cffi_f_amp_graph_runtime_destroy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 39), (void *)_cffi_d_amp_graph_runtime_destroy },
  { "amp_graph_runtime_execute", (void *)_cffi_f_amp_graph_runtime_execute, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 20), (void *)_cffi_d_amp_graph_runtime_execute },
  { "amp_graph_runtime_set_param", (void *)_cffi_f_amp_graph_runtime_set_param, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 11), (void *)_cffi_d_amp_graph_runtime_set_param },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "AmpGraphControlHistory", 45, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "AmpGraphRuntime", 46, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "AmpGraphControlHistory", 45 },
  { "AmpGraphRuntime", 46 },
  { "uint32_t", 16 },
  { "uint8_t", 48 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  NULL,  /* no fields */
  _cffi_struct_unions,
  NULL,  /* no enums */
  _cffi_typenames,
  9,  /* num_globals */
  2,  /* num_struct_unions */
  0,  /* num_enums */
  4,  /* num_typenames */
  NULL,  /* no includes */
  50,  /* num_types */
  0,  /* flags */
};

#ifdef __GNUC__
#  pragma GCC visibility push(default)  /* for -fvisibility= */
#endif

#ifdef PYPY_VERSION
PyMODINIT_FUNC
_cffi_pypyinit__amp_graph_runtime(const void *p[])
{
    p[0] = (const void *)0x2601;
    p[1] = &_cffi_type_context;
#if PY_MAJOR_VERSION >= 3
    return NULL;
#endif
}
#  ifdef _MSC_VER
     PyMODINIT_FUNC
#  if PY_MAJOR_VERSION >= 3
     PyInit__amp_graph_runtime(void) { return NULL; }
#  else
     init_amp_graph_runtime(void) { }
#  endif
#  endif
#elif PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit__amp_graph_runtime(void)
{
  return _cffi_init("_amp_graph_runtime", 0x2601, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
init_amp_graph_runtime(void)
{
  _cffi_init("_amp_graph_runtime", 0x2601, &_cffi_type_context);
}
#endif

#ifdef __GNUC__
#  pragma GCC visibility pop
#endif
