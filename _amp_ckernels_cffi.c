#define _CFFI_

/* We try to define Py_LIMITED_API before including Python.h.

   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
   the same works for the other two macros.  Py_DEBUG implies them,
   but not the other way around.

   The implementation is messy (issue #350): on Windows, with _MSC_VER,
   we have to define Py_LIMITED_API even before including pyconfig.h.
   In that case, we guess what pyconfig.h will do to the macros above,
   and check our guess after the #include.

   Note that on Windows, with CPython 3.x, you need >= 3.5 and virtualenv
   version >= 16.0.0.  With older versions of either, you don't get a
   copy of PYTHON3.DLL in the virtualenv.  We can't check the version of
   CPython *before* we even include pyconfig.h.  ffi.set_source() puts
   a ``#define _CFFI_NO_LIMITED_API'' at the start of this file if it is
   running on Windows < 3.5, as an attempt at fixing it, but that's
   arguably wrong because it may not be the target version of Python.
   Still better than nothing I guess.  As another workaround, you can
   remove the definition of Py_LIMITED_API here.

   See also 'py_limited_api' in cffi/setuptools_ext.py.
*/
#if !defined(_CFFI_USE_EMBEDDING) && !defined(Py_LIMITED_API)
#  ifdef _MSC_VER
#    if !defined(_DEBUG) && !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#    include <pyconfig.h>
     /* sanity-check: Py_LIMITED_API will cause crashes if any of these
        are also defined.  Normally, the Python file PC/pyconfig.h does not
        cause any of these to be defined, with the exception that _DEBUG
        causes Py_DEBUG.  Double-check that. */
#    ifdef Py_LIMITED_API
#      if defined(Py_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_DEBUG, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_TRACE_REFS)
#        error "pyconfig.h unexpectedly defines Py_TRACE_REFS, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_REF_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_REF_DEBUG, but Py_LIMITED_API is set"
#      endif
#    endif
#  else
#    include <pyconfig.h>
#    if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#  endif
#endif

#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47
#define _CFFI_PRIM_FLOATCOMPLEX 48
#define _CFFI_PRIM_DOUBLECOMPLEX 49
#define _CFFI_PRIM_CHAR16       50
#define _CFFI_PRIM_CHAR32       51

#define _CFFI__NUM_PRIM         52
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
# define _cffi_float_complex_t   _Fcomplex    /* include <complex.h> for it */
# define _cffi_double_complex_t  _Dcomplex    /* include <complex.h> for it */
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
# define _cffi_float_complex_t   float _Complex
# define _cffi_double_complex_t  double _Complex
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong
#define _cffi_from_c__Bool PyBool_FromLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((_cffi_wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(_cffi_wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
                    PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _cffi_to_c_wchar3216_t                                           \
    ((int(*)(PyObject *))_cffi_exports[26])
#define _cffi_from_c_wchar3216_t                                         \
    ((PyObject *(*)(int))_cffi_exports[27])
#define _CFFI_NUM_EXPORTS 28

struct _cffi_ctypedescr;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (struct _cffi_ctypedescr *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}


#ifdef HAVE_WCHAR_H
typedef wchar_t _cffi_wchar_t;
#else
typedef uint16_t _cffi_wchar_t;   /* same random pick as _cffi_backend.c */
#endif

_CFFI_UNUSED_FN static uint16_t _cffi_to_c_char16_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return (uint16_t)_cffi_to_c_wchar_t(o);
    else
        return (uint16_t)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char16_t(uint16_t x)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

_CFFI_UNUSED_FN static int _cffi_to_c_char32_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return (int)_cffi_to_c_wchar_t(o);
    else
        return (int)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char32_t(unsigned int x)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

union _cffi_union_alignment_u {
    unsigned char m_char;
    unsigned short m_short;
    unsigned int m_int;
    unsigned long m_long;
    unsigned long long m_longlong;
    float m_float;
    double m_double;
    long double m_longdouble;
};

struct _cffi_freeme_s {
    struct _cffi_freeme_s *next;
    union _cffi_union_alignment_u alignment;
};

_CFFI_UNUSED_FN static int
_cffi_convert_array_argument(struct _cffi_ctypedescr *ctptr, PyObject *arg,
                             char **output_data, Py_ssize_t datasize,
                             struct _cffi_freeme_s **freeme)
{
    char *p;
    if (datasize < 0)
        return -1;

    p = *output_data;
    if (p == NULL) {
        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc(
            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize);
        if (fp == NULL)
            return -1;
        fp->next = *freeme;
        *freeme = fp;
        p = *output_data = (char *)&fp->alignment;
    }
    memset((void *)p, 0, (size_t)datasize);
    return _cffi_convert_array_from_object(p, ctptr, arg);
}

_CFFI_UNUSED_FN static void
_cffi_free_array_arguments(struct _cffi_freeme_s *freeme)
{
    do {
        void *p = (void *)freeme;
        freeme = freeme->next;
        PyObject_Free(p);
    } while (freeme != NULL);
}

/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

/************************************************************/


#include <ctype.h>
#include <float.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(_WIN32) || defined(_WIN64)
#define AMP_CAPI __declspec(dllexport)
#else
#define AMP_CAPI
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

typedef struct {
    int *boundaries;
    int *trig_indices;
    int8_t *gate_bool;
    int8_t *drone_bool;
    size_t boundary_cap;
    size_t trig_cap;
    size_t bool_cap;
} envelope_scratch_t;

static envelope_scratch_t envelope_scratch = { NULL, NULL, NULL, NULL, 0, 0, 0 };

/*
 * Edge runner contract (mirrors `_EDGE_RUNNER_CDEF` in Python).
 *
 * The runtime passes node descriptors/inputs to `amp_run_node`, which may
 * allocate per-node state (returned via `state`) and a heap-owned audio buffer
 * (`out_buffer`).
 *
 * Return codes:
 *   0   -> success
 *  -1   -> allocation failure / invalid contract usage
 *  -3   -> unsupported node kind (caller should fall back to Python)
 */
typedef struct {
    uint32_t has_audio;
    uint32_t batches;
    uint32_t channels;
    uint32_t frames;
    const double *data;
} EdgeRunnerAudioView;

typedef struct {
    const char *name;
    uint32_t batches;
    uint32_t channels;
    uint32_t frames;
    const double *data;
} EdgeRunnerParamView;

typedef struct {
    uint32_t count;
    EdgeRunnerParamView *items;
} EdgeRunnerParamSet;

typedef struct {
    EdgeRunnerAudioView audio;
    EdgeRunnerParamSet params;
} EdgeRunnerNodeInputs;

typedef struct {
    const char *name;
    size_t name_len;
    const char *type_name;
    size_t type_len;
    const char *params_json;
    size_t params_len;
} EdgeRunnerNodeDescriptor;

typedef struct {
    char *name;
    uint32_t name_len;
    uint32_t offset;
    uint32_t span;
} EdgeRunnerCompiledParam;

typedef struct {
    char *name;
    uint32_t name_len;
    uint32_t function_id;
    uint32_t audio_offset;
    uint32_t audio_span;
    uint32_t param_count;
    EdgeRunnerCompiledParam *params;
} EdgeRunnerCompiledNode;

typedef struct {
    uint32_t version;
    uint32_t node_count;
    EdgeRunnerCompiledNode *nodes;
} EdgeRunnerCompiledPlan;

typedef struct {
    char *name;
    uint32_t name_len;
    double *values;
    uint32_t value_count;
    double timestamp;
} EdgeRunnerControlCurve;

typedef struct {
    uint32_t frames_hint;
    uint32_t curve_count;
    EdgeRunnerControlCurve *curves;
} EdgeRunnerControlHistory;

static void destroy_compiled_plan(EdgeRunnerCompiledPlan *plan) {
    if (plan == NULL) {
        return;
    }
    if (plan->nodes != NULL) {
        for (uint32_t i = 0; i < plan->node_count; ++i) {
            EdgeRunnerCompiledNode *node = &plan->nodes[i];
            if (node->params != NULL) {
                for (uint32_t j = 0; j < node->param_count; ++j) {
                    EdgeRunnerCompiledParam *param = &node->params[j];
                    if (param->name != NULL) {
                        free(param->name);
                        param->name = NULL;
                    }
                }
                free(node->params);
                node->params = NULL;
            }
            if (node->name != NULL) {
                free(node->name);
                node->name = NULL;
            }
        }
        free(plan->nodes);
        plan->nodes = NULL;
    }
    free(plan);
}

static int read_u32_le(const uint8_t **cursor, size_t *remaining, uint32_t *out_value) {
    if (cursor == NULL || remaining == NULL || out_value == NULL) {
        return 0;
    }
    if (*remaining < 4) {
        return 0;
    }
    const uint8_t *ptr = *cursor;
    *out_value = (uint32_t)ptr[0]
        | ((uint32_t)ptr[1] << 8)
        | ((uint32_t)ptr[2] << 16)
        | ((uint32_t)ptr[3] << 24);
    *cursor += 4;
    *remaining -= 4;
    return 1;
}

AMP_CAPI EdgeRunnerCompiledPlan *amp_load_compiled_plan(
    const uint8_t *descriptor_blob,
    size_t descriptor_len,
    const uint8_t *plan_blob,
    size_t plan_len
) {
    if (descriptor_blob == NULL || plan_blob == NULL) {
        return NULL;
    }
    if (descriptor_len < 4 || plan_len < 12) {
        return NULL;
    }

    const uint8_t *descriptor_cursor = descriptor_blob;
    size_t descriptor_remaining = descriptor_len;
    uint32_t descriptor_count = 0;
    if (!read_u32_le(&descriptor_cursor, &descriptor_remaining, &descriptor_count)) {
        return NULL;
    }

    const uint8_t *cursor = plan_blob;
    size_t remaining = plan_len;
    if (remaining < 4) {
        return NULL;
    }
    if (cursor[0] != 'A' || cursor[1] != 'M' || cursor[2] != 'P' || cursor[3] != 'L') {
        return NULL;
    }
    cursor += 4;
    remaining -= 4;

    uint32_t version = 0;
    uint32_t node_count = 0;
    if (!read_u32_le(&cursor, &remaining, &version) || !read_u32_le(&cursor, &remaining, &node_count)) {
        return NULL;
    }
    if (descriptor_count != node_count) {
        return NULL;
    }

    EdgeRunnerCompiledPlan *plan = (EdgeRunnerCompiledPlan *)calloc(1, sizeof(EdgeRunnerCompiledPlan));
    if (plan == NULL) {
        return NULL;
    }
    plan->version = version;
    plan->node_count = node_count;

    if (node_count == 0) {
        if (remaining != 0) {
            destroy_compiled_plan(plan);
            return NULL;
        }
        return plan;
    }

    plan->nodes = (EdgeRunnerCompiledNode *)calloc(node_count, sizeof(EdgeRunnerCompiledNode));
    if (plan->nodes == NULL) {
        destroy_compiled_plan(plan);
        return NULL;
    }

    for (uint32_t idx = 0; idx < node_count; ++idx) {
        EdgeRunnerCompiledNode *node = &plan->nodes[idx];
        uint32_t function_id = 0;
        uint32_t name_len = 0;
        uint32_t audio_offset = 0;
        uint32_t audio_span = 0;
        uint32_t param_count = 0;
        if (!read_u32_le(&cursor, &remaining, &function_id)
            || !read_u32_le(&cursor, &remaining, &name_len)
            || !read_u32_le(&cursor, &remaining, &audio_offset)
            || !read_u32_le(&cursor, &remaining, &audio_span)
            || !read_u32_le(&cursor, &remaining, &param_count)) {
            destroy_compiled_plan(plan);
            return NULL;
        }
        if (remaining < name_len) {
            destroy_compiled_plan(plan);
            return NULL;
        }
        node->name = (char *)malloc((size_t)name_len + 1);
        if (node->name == NULL) {
            destroy_compiled_plan(plan);
            return NULL;
        }
        memcpy(node->name, cursor, name_len);
        node->name[name_len] = '\0';
        node->name_len = name_len;
        cursor += name_len;
        remaining -= name_len;
        node->function_id = function_id;
        node->audio_offset = audio_offset;
        node->audio_span = audio_span;
        node->param_count = param_count;
        if (param_count > 0) {
            node->params = (EdgeRunnerCompiledParam *)calloc(param_count, sizeof(EdgeRunnerCompiledParam));
            if (node->params == NULL) {
                destroy_compiled_plan(plan);
                return NULL;
            }
        }
        for (uint32_t param_idx = 0; param_idx < param_count; ++param_idx) {
            EdgeRunnerCompiledParam *param = &node->params[param_idx];
            uint32_t param_name_len = 0;
            uint32_t param_offset = 0;
            uint32_t param_span = 0;
            if (!read_u32_le(&cursor, &remaining, &param_name_len)
                || !read_u32_le(&cursor, &remaining, &param_offset)
                || !read_u32_le(&cursor, &remaining, &param_span)) {
                destroy_compiled_plan(plan);
                return NULL;
            }
            if (remaining < param_name_len) {
                destroy_compiled_plan(plan);
                return NULL;
            }
            param->name = (char *)malloc((size_t)param_name_len + 1);
            if (param->name == NULL) {
                destroy_compiled_plan(plan);
                return NULL;
            }
            memcpy(param->name, cursor, param_name_len);
            param->name[param_name_len] = '\0';
            param->name_len = param_name_len;
            param->offset = param_offset;
            param->span = param_span;
            cursor += param_name_len;
            remaining -= param_name_len;
        }
    }

    if (remaining != 0) {
        destroy_compiled_plan(plan);
        return NULL;
    }

    return plan;
}

AMP_CAPI void amp_release_compiled_plan(EdgeRunnerCompiledPlan *plan) {
    destroy_compiled_plan(plan);
}

static void destroy_control_history(EdgeRunnerControlHistory *history) {
    if (history == NULL) {
        return;
    }
    if (history->curves != NULL) {
        for (uint32_t i = 0; i < history->curve_count; ++i) {
            EdgeRunnerControlCurve *curve = &history->curves[i];
            if (curve->name != NULL) {
                free(curve->name);
                curve->name = NULL;
            }
            if (curve->values != NULL) {
                free(curve->values);
                curve->values = NULL;
            }
            curve->value_count = 0;
        }
        free(history->curves);
        history->curves = NULL;
    }
    free(history);
}

static const EdgeRunnerControlCurve *find_history_curve(
    const EdgeRunnerControlHistory *history,
    const char *name,
    size_t name_len
) {
    if (history == NULL || name == NULL || name_len == 0) {
        return NULL;
    }
    for (uint32_t i = 0; i < history->curve_count; ++i) {
        const EdgeRunnerControlCurve *curve = &history->curves[i];
        if (curve->name_len == name_len && curve->name != NULL && strncmp(curve->name, name, name_len) == 0) {
            return curve;
        }
    }
    return NULL;
}

static void apply_history_curve(
    double *dest,
    int batches,
    int frames,
    const EdgeRunnerControlCurve *curve
) {
    if (dest == NULL || curve == NULL || curve->values == NULL || curve->value_count == 0) {
        return;
    }
    int count = (int)curve->value_count;
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    for (int b = 0; b < batches; ++b) {
        for (int f = 0; f < frames; ++f) {
            double value = 0.0;
            if (count >= frames) {
                if (f < count) {
                    value = curve->values[f];
                } else {
                    value = curve->values[count - 1];
                }
            } else if (count == 1) {
                value = curve->values[0];
            } else {
                if (f < count) {
                    value = curve->values[f];
                } else {
                    value = curve->values[count - 1];
                }
            }
            dest[((size_t)b * (size_t)frames) + (size_t)f] = value;
        }
    }
}

AMP_CAPI EdgeRunnerControlHistory *amp_load_control_history(
    const uint8_t *blob,
    size_t blob_len,
    int frames_hint
) {
    if (blob == NULL || blob_len < 8) {
        return NULL;
    }
    const uint8_t *cursor = blob;
    size_t remaining = blob_len;
    uint32_t event_count = 0;
    uint32_t key_count = 0;
    if (!read_u32_le(&cursor, &remaining, &event_count) || !read_u32_le(&cursor, &remaining, &key_count)) {
        return NULL;
    }
    EdgeRunnerControlHistory *history = (EdgeRunnerControlHistory *)calloc(1, sizeof(EdgeRunnerControlHistory));
    if (history == NULL) {
        return NULL;
    }
    history->frames_hint = frames_hint > 0 ? (uint32_t)frames_hint : 0U;
    history->curve_count = key_count;
    if (key_count > 0) {
        history->curves = (EdgeRunnerControlCurve *)calloc(key_count, sizeof(EdgeRunnerControlCurve));
        if (history->curves == NULL) {
            destroy_control_history(history);
            return NULL;
        }
    }
    if (key_count == 0) {
        return history;
    }
    uint32_t *name_lengths = (uint32_t *)calloc(key_count, sizeof(uint32_t));
    if (name_lengths == NULL) {
        destroy_control_history(history);
        return NULL;
    }
    for (uint32_t i = 0; i < key_count; ++i) {
        if (!read_u32_le(&cursor, &remaining, &name_lengths[i])) {
            free(name_lengths);
            destroy_control_history(history);
            return NULL;
        }
    }
    for (uint32_t i = 0; i < key_count; ++i) {
        uint32_t name_len = name_lengths[i];
        if (remaining < name_len) {
            free(name_lengths);
            destroy_control_history(history);
            return NULL;
        }
        EdgeRunnerControlCurve *curve = &history->curves[i];
        curve->name = (char *)malloc((size_t)name_len + 1);
        if (curve->name == NULL) {
            free(name_lengths);
            destroy_control_history(history);
            return NULL;
        }
        memcpy(curve->name, cursor, name_len);
        curve->name[name_len] = '\0';
        curve->name_len = name_len;
        curve->value_count = 0;
        curve->values = NULL;
        curve->timestamp = -DBL_MAX;
        cursor += name_len;
        remaining -= name_len;
    }
    free(name_lengths);
    for (uint32_t event_idx = 0; event_idx < event_count; ++event_idx) {
        if (remaining < sizeof(double)) {
            destroy_control_history(history);
            return NULL;
        }
        double timestamp = 0.0;
        memcpy(&timestamp, cursor, sizeof(double));
        cursor += sizeof(double);
        remaining -= sizeof(double);
        for (uint32_t key_idx = 0; key_idx < key_count; ++key_idx) {
            uint32_t value_count = 0;
            if (!read_u32_le(&cursor, &remaining, &value_count)) {
                destroy_control_history(history);
                return NULL;
            }
            double *values_copy = NULL;
            if (value_count > 0) {
                size_t bytes = (size_t)value_count * sizeof(double);
                if (remaining < bytes) {
                    destroy_control_history(history);
                    return NULL;
                }
                values_copy = (double *)malloc(bytes);
                if (values_copy == NULL) {
                    destroy_control_history(history);
                    return NULL;
                }
                memcpy(values_copy, cursor, bytes);
                cursor += bytes;
                remaining -= bytes;
            }
            EdgeRunnerControlCurve *curve = &history->curves[key_idx];
            if (value_count > 0 && (curve->values == NULL || timestamp >= curve->timestamp)) {
                if (curve->values != NULL) {
                    free(curve->values);
                }
                curve->values = values_copy;
                curve->value_count = value_count;
                curve->timestamp = timestamp;
                values_copy = NULL;
            }
            if (values_copy != NULL) {
                free(values_copy);
            }
        }
    }
    return history;
}

AMP_CAPI void amp_release_control_history(EdgeRunnerControlHistory *history) {
    destroy_control_history(history);
}

static int envelope_reserve_scratch(int F) {
    size_t needed_boundaries = (size_t)(4 * F + 4);
    size_t needed_trig = (size_t)(F > 0 ? F : 1);
    size_t needed_bool = (size_t)(F > 0 ? F : 1);

    if (envelope_scratch.boundary_cap < needed_boundaries) {
        int *new_boundaries = (int *)realloc(envelope_scratch.boundaries, needed_boundaries * sizeof(int));
        if (new_boundaries == NULL) {
            return 0;
        }
        envelope_scratch.boundaries = new_boundaries;
        envelope_scratch.boundary_cap = needed_boundaries;
    }

    if (envelope_scratch.trig_cap < needed_trig) {
        int *new_trig = (int *)realloc(envelope_scratch.trig_indices, needed_trig * sizeof(int));
        if (new_trig == NULL) {
            return 0;
        }
        envelope_scratch.trig_indices = new_trig;
        envelope_scratch.trig_cap = needed_trig;
    }

    if (envelope_scratch.bool_cap < needed_bool) {
        int8_t *gate_ptr = envelope_scratch.gate_bool;
        int8_t *drone_ptr = envelope_scratch.drone_bool;
        int8_t *new_gate = (int8_t *)realloc(gate_ptr, needed_bool * sizeof(int8_t));
        int8_t *new_drone = (int8_t *)realloc(drone_ptr, needed_bool * sizeof(int8_t));
        if (new_gate == NULL || new_drone == NULL) {
            if (new_gate != NULL) {
                envelope_scratch.gate_bool = new_gate;
            }
            if (new_drone != NULL) {
                envelope_scratch.drone_bool = new_drone;
            }
            return 0;
        }
        envelope_scratch.gate_bool = new_gate;
        envelope_scratch.drone_bool = new_drone;
        envelope_scratch.bool_cap = needed_bool;
    }

    return 1;
}

void lfo_slew(const double* x, double* out, int B, int F, double r, double alpha, double* z0) {
    for (int b = 0; b < B; ++b) {
        double state = 0.0;
        if (z0 != NULL) state = z0[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            double xi = x[base + i];
            state = r * state + alpha * xi;
            out[base + i] = state;
        }
        if (z0 != NULL) z0[b] = state;
    }
}

void safety_filter(const double* x, double* y, int B, int C, int F, double a, double* prev_in, double* prev_dc) {
    for (int b = 0; b < B; ++b) {
        for (int c = 0; c < C; ++c) {
            int chan = b * C + c;
            double pi = 0.0;
            double pd = 0.0;
            if (prev_in != NULL) pi = prev_in[chan];
            if (prev_dc != NULL) pd = prev_dc[chan];
            int base = chan * F;
            for (int i = 0; i < F; ++i) {
                double xin = x[base + i];
                double diff;
                if (i == 0) diff = xin - pi;
                else diff = xin - x[base + i - 1];
                pd = a * pd + diff;
                y[base + i] = pd;
            }
            if (prev_in != NULL) prev_in[chan] = x[base + F - 1];
            if (prev_dc != NULL) prev_dc[chan] = y[base + F - 1];
        }
    }
}

void dc_block(const double* x, double* out, int B, int C, int F, double a, double* state) {
    for (int b = 0; b < B; ++b) {
        for (int c = 0; c < C; ++c) {
            int chan = b * C + c;
            double dc = 0.0;
            if (state != NULL) dc = state[chan];
            int base = chan * F;
            for (int i = 0; i < F; ++i) {
                double xin = x[base + i];
                dc = a * dc + (1.0 - a) * xin;
                out[base + i] = xin - dc;
            }
            if (state != NULL) state[chan] = dc;
        }
    }
}

void subharmonic_process(
    const double* x,
    double* y,
    int B,
    int C,
    int F,
    double a_hp_in,
    double a_lp_in,
    double a_sub2,
    int use_div4,
    double a_sub4,
    double a_env_attack,
    double a_env_release,
    double a_hp_out,
    double drive,
    double mix,
    double* hp_y,
    double* lp_y,
    double* prev,
    int8_t* sign,
    int8_t* ff2,
    int8_t* ff4,
    int32_t* ff4_count,
    double* sub2_lp,
    double* sub4_lp,
    double* env,
    double* hp_out_y,
    double* hp_out_x
) {
    // Layout: arrays are flattened per-channel: index = (b*C + c) * F + t
    for (int t = 0; t < F; ++t) {
        for (int b = 0; b < B; ++b) {
            for (int c = 0; c < C; ++c) {
                int chan = b * C + c;
                int base = chan * F;
                double xt = x[base + t];

                // Bandpass driver: simple HP then LP
                double hp_y_val = hp_y[chan];
                double prev_val = prev[chan];
                double lp_y_val = lp_y[chan];
                double hp_in = a_hp_in * (hp_y_val + xt - prev_val);
                hp_y[chan] = hp_in;
                prev[chan] = xt;
                double bp = lp_y_val + a_lp_in * (hp_in - lp_y_val);
                lp_y[chan] = bp;

                // env
                double abs_bp = fabs(bp);
                double env_val = env[chan];
                if (abs_bp > env_val) env_val = env_val + a_env_attack * (abs_bp - env_val);
                else env_val = env_val + a_env_release * (abs_bp - env_val);
                env[chan] = env_val;

                // sign and flip-flops
                int8_t prev_sign = sign[chan];
                int8_t sign_now = (bp > 0.0) ? 1 : -1;
                int pos_zc = (prev_sign < 0) && (sign_now > 0);
                sign[chan] = sign_now;

                if (pos_zc) ff2[chan] = -ff2[chan];

                if (use_div4) {
                    if (pos_zc) ff4_count[chan] = ff4_count[chan] + 1;
                    int toggle4 = (pos_zc && (ff4_count[chan] >= 2));
                    if (toggle4) ff4[chan] = -ff4[chan];
                    if (toggle4) ff4_count[chan] = 0;
                }

                double sq2 = (double) ff2[chan];
                double sub2_lp_val = sub2_lp[chan];
                sub2_lp_val = sub2_lp_val + a_sub2 * (sq2 - sub2_lp_val);
                sub2_lp[chan] = sub2_lp_val;
                double sub_val = sub2_lp_val;

                if (use_div4) {
                    double sq4 = (double) ff4[chan];
                    double sub4_lp_val = sub4_lp[chan];
                    sub4_lp_val = sub4_lp_val + a_sub4 * (sq4 - sub4_lp_val);
                    sub4_lp[chan] = sub4_lp_val;
                    sub_val = sub_val + 0.6 * sub4_lp_val;
                }

                double sub = tanh(drive * sub_val) * (env_val + 1e-6);

                double dry = xt;
                double wet = sub;
                double out_t = (1.0 - mix) * dry + mix * wet;

                double y_prev = hp_out_y[chan];
                double x_prev = hp_out_x[chan];
                double hp = a_hp_out * (y_prev + out_t - x_prev);
                hp_out_y[chan] = hp;
                hp_out_x[chan] = out_t;
                y[base + t] = hp;
            }
        }
    }
}

static void envelope_start_attack(
    int index,
    const double* velocity,
    int send_resets,
    double* reset_line,
    int* stage,
    double* timer,
    double* value,
    double* vel_state,
    double* release_start,
    int64_t* activations
) {
    double vel = velocity[index];
    if (vel < 0.0) vel = 0.0;
    *stage = 1;
    *timer = 0.0;
    *value = 0.0;
    *vel_state = vel;
    *release_start = vel;
    *activations += 1;
    if (send_resets && reset_line != NULL) {
        reset_line[index] = 1.0;
    }
}

static void envelope_process_simple(
    const double* trigger,
    const double* gate,
    const double* drone,
    const double* velocity,
    int B,
    int F,
    int atk_frames,
    int hold_frames,
    int dec_frames,
    int sus_frames,
    int rel_frames,
    double sustain_level,
    int send_resets,
    int* stage,
    double* value,
    double* timer,
    double* vel_state,
    int64_t* activations,
    double* release_start,
    double* amp_out,
    double* reset_out
) {
    for (int b = 0; b < B; ++b) {
        int st = stage[b];
        double val = value[b];
        double tim = timer[b];
        double vel = vel_state[b];
        int64_t acts = activations[b];
        double rel_start = release_start[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            int idx = base + i;
            int trig = trigger[idx] > 0.5 ? 1 : 0;
            int gate_on = gate[idx] > 0.5 ? 1 : 0;
            int drone_on = drone[idx] > 0.5 ? 1 : 0;

            if (trig) {
                envelope_start_attack(i, velocity + base, send_resets, reset_out != NULL ? reset_out + base : NULL, &st, &tim, &val, &vel, &rel_start, &acts);
            } else if (st == 0 && (gate_on || drone_on)) {
                envelope_start_attack(i, velocity + base, send_resets, reset_out != NULL ? reset_out + base : NULL, &st, &tim, &val, &vel, &rel_start, &acts);
            }

            if (st == 1) {
                if (atk_frames <= 0) {
                    val = vel;
                    if (hold_frames > 0) st = 2;
                    else if (dec_frames > 0) st = 3;
                    else st = 4;
                    tim = 0.0;
                } else {
                    val += vel / (double)(atk_frames > 0 ? atk_frames : 1);
                    if (val > vel) val = vel;
                    tim += 1.0;
                    if (tim >= atk_frames) {
                        val = vel;
                        if (hold_frames > 0) st = 2;
                        else if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                    }
                }
            } else if (st == 2) {
                val = vel;
                if (hold_frames <= 0) {
                    if (dec_frames > 0) st = 3;
                    else st = 4;
                    tim = 0.0;
                } else {
                    tim += 1.0;
                    if (tim >= hold_frames) {
                        if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                    }
                }
            } else if (st == 3) {
                double target = vel * sustain_level;
                if (dec_frames <= 0) {
                    val = target;
                    st = 4;
                    tim = 0.0;
                } else {
                    double delta = (vel - target) / (double)(dec_frames > 0 ? dec_frames : 1);
                    double candidate = val - delta;
                    if (candidate < target) candidate = target;
                    val = candidate;
                    tim += 1.0;
                    if (tim >= dec_frames) {
                        val = target;
                        st = 4;
                        tim = 0.0;
                    }
                }
            } else if (st == 4) {
                val = vel * sustain_level;
                if (sus_frames > 0) {
                    tim += 1.0;
                    if (tim >= sus_frames) {
                        st = 5;
                        rel_start = val;
                        tim = 0.0;
                    }
                } else if (!gate_on && !drone_on) {
                    st = 5;
                    rel_start = val;
                    tim = 0.0;
                }
            } else if (st == 5) {
                if (rel_frames <= 0) {
                    val = 0.0;
                    st = 0;
                    tim = 0.0;
                } else {
                    double step = rel_start / (double)(rel_frames > 0 ? rel_frames : 1);
                    double candidate = val - step;
                    if (candidate < 0.0) candidate = 0.0;
                    val = candidate;
                    tim += 1.0;
                    if (tim >= rel_frames) {
                        val = 0.0;
                        st = 0;
                        tim = 0.0;
                    }
                }
                if (gate_on || drone_on) {
                    envelope_start_attack(i, velocity + base, send_resets, reset_out != NULL ? reset_out + base : NULL, &st, &tim, &val, &vel, &rel_start, &acts);
                }
            }

            if (val < 0.0) val = 0.0;
            amp_out[idx] = val;
        }
        stage[b] = st;
        value[b] = val;
        timer[b] = tim;
        vel_state[b] = vel;
        activations[b] = acts;
        release_start[b] = rel_start;
    }
}

void envelope_process(
    const double* trigger,
    const double* gate,
    const double* drone,
    const double* velocity,
    int B,
    int F,
    int atk_frames,
    int hold_frames,
    int dec_frames,
    int sus_frames,
    int rel_frames,
    double sustain_level,
    int send_resets,
    int* stage,
    double* value,
    double* timer,
    double* vel_state,
    int64_t* activations,
    double* release_start,
    double* amp_out,
    double* reset_out
) {
    if (reset_out != NULL) {
        size_t total = (size_t)B * (size_t)F;
        memset(reset_out, 0, total * sizeof(double));
    }
    if (B <= 0 || F <= 0) {
        return;
    }

    if (!envelope_reserve_scratch(F)) {
        envelope_process_simple(
            trigger,
            gate,
            drone,
            velocity,
            B,
            F,
            atk_frames,
            hold_frames,
            dec_frames,
            sus_frames,
            rel_frames,
            sustain_level,
            send_resets,
            stage,
            value,
            timer,
            vel_state,
            activations,
            release_start,
            amp_out,
            reset_out
        );
        return;
    }

    int* boundaries = envelope_scratch.boundaries;
    int* trig_indices = envelope_scratch.trig_indices;
    int8_t* gate_bool = envelope_scratch.gate_bool;
    int8_t* drone_bool = envelope_scratch.drone_bool;

    for (int b = 0; b < B; ++b) {
        int st = stage[b];
        double val = value[b];
        double tim = timer[b];
        double vel = vel_state[b];
        int64_t acts = activations[b];
        double rel_start = release_start[b];

        const double* trig_line = trigger + b * F;
        const double* gate_line = gate + b * F;
        const double* drone_line = drone + b * F;
        const double* vel_line = velocity + b * F;
        double* amp_line = amp_out + b * F;
        double* reset_line = reset_out != NULL ? reset_out + b * F : NULL;

        int trig_count = 0;
        for (int i = 0; i < F; ++i) {
            if (trig_line[i] > 0.5) {
                trig_indices[trig_count++] = i;
            }
            gate_bool[i] = gate_line[i] > 0.5 ? 1 : 0;
            drone_bool[i] = drone_line[i] > 0.5 ? 1 : 0;
        }

        int boundary_count = 0;
        boundaries[boundary_count++] = 0;
        boundaries[boundary_count++] = F;
        for (int i = 0; i < trig_count; ++i) {
            boundaries[boundary_count++] = trig_indices[i];
        }
        for (int i = 1; i < F; ++i) {
            if (gate_bool[i] != gate_bool[i - 1]) {
                boundaries[boundary_count++] = i;
            }
            if (drone_bool[i] != drone_bool[i - 1]) {
                boundaries[boundary_count++] = i;
            }
        }

        for (int i = 1; i < boundary_count; ++i) {
            int key = boundaries[i];
            int j = i - 1;
            while (j >= 0 && boundaries[j] > key) {
                boundaries[j + 1] = boundaries[j];
                --j;
            }
            boundaries[j + 1] = key;
        }

        int unique_count = 0;
        for (int i = 0; i < boundary_count; ++i) {
            int val_b = boundaries[i];
            if (val_b < 0) val_b = 0;
            if (val_b > F) val_b = F;
            if (unique_count == 0 || boundaries[unique_count - 1] != val_b) {
                boundaries[unique_count++] = val_b;
            }
        }
        if (unique_count < 2) {
            boundaries[0] = 0;
            boundaries[1] = F;
            unique_count = 2;
        }

        int trig_ptr = 0;
        for (int seg = 0; seg < unique_count - 1; ++seg) {
            int start = boundaries[seg];
            int stop = boundaries[seg + 1];
            if (start >= F) {
                break;
            }
            if (stop > F) {
                stop = F;
            }
            if (stop <= start) {
                continue;
            }

            while (trig_ptr < trig_count && trig_indices[trig_ptr] == start) {
                envelope_start_attack(
                    start,
                    vel_line,
                    send_resets,
                    reset_line,
                    &st,
                    &tim,
                    &val,
                    &vel,
                    &rel_start,
                    &acts
                );
                trig_ptr++;
            }

            int t = start;
            while (t < stop) {
                int gate_on = (gate_bool[t] != 0) || (drone_bool[t] != 0);

                int changed = 1;
                while (changed) {
                    changed = 0;
                    if (st == 1 && atk_frames <= 0) {
                        val = vel;
                        if (hold_frames > 0) st = 2;
                        else if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                        changed = 1;
                        continue;
                    }
                    if (st == 2 && hold_frames <= 0) {
                        if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                        changed = 1;
                        continue;
                    }
                    if (st == 3 && dec_frames <= 0) {
                        val = vel * sustain_level;
                        st = 4;
                        tim = 0.0;
                        changed = 1;
                        continue;
                    }
                    if (st == 5 && rel_frames <= 0) {
                        val = 0.0;
                        st = 0;
                        tim = 0.0;
                        changed = 1;
                        continue;
                    }
                }

                if (st == 0) {
                    if (gate_on) {
                        envelope_start_attack(
                            t,
                            vel_line,
                            send_resets,
                            reset_line,
                            &st,
                            &tim,
                            &val,
                            &vel,
                            &rel_start,
                            &acts
                        );
                        continue;
                    }
                    int seg_len = stop - t;
                    for (int k = 0; k < seg_len; ++k) {
                        amp_line[t + k] = 0.0;
                    }
                    val = 0.0;
                    tim = 0.0;
                    t = stop;
                    continue;
                }

                if (st == 1) {
                    if (atk_frames <= 0) {
                        continue;
                    }
                    int remaining = atk_frames - (int)tim;
                    if (remaining <= 0) remaining = 1;
                    int seg_len = stop - t;
                    if (seg_len > remaining) seg_len = remaining;
                    if (seg_len <= 0) {
                        t = stop;
                        continue;
                    }
                    double step = vel / (atk_frames > 0 ? (double)atk_frames : 1.0);
                    for (int k = 0; k < seg_len; ++k) {
                        double sample = val + step * (double)(k + 1);
                        if (vel >= 0.0 && sample > vel) sample = vel;
                        if (sample < 0.0) sample = 0.0;
                        amp_line[t + k] = sample;
                    }
                    val = amp_line[t + seg_len - 1];
                    tim += (double)seg_len;
                    if (atk_frames > 0 && tim >= atk_frames) {
                        val = vel;
                        if (hold_frames > 0) st = 2;
                        else if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                    }
                    t += seg_len;
                    continue;
                }

                if (st == 2) {
                    if (hold_frames <= 0) {
                        continue;
                    }
                    int remaining = hold_frames - (int)tim;
                    if (remaining <= 0) remaining = 1;
                    int seg_len = stop - t;
                    if (seg_len > remaining) seg_len = remaining;
                    if (seg_len <= 0) {
                        t = stop;
                        continue;
                    }
                    for (int k = 0; k < seg_len; ++k) {
                        amp_line[t + k] = vel;
                    }
                    val = vel;
                    tim += (double)seg_len;
                    if (tim >= hold_frames) {
                        if (dec_frames > 0) st = 3;
                        else st = 4;
                        tim = 0.0;
                    }
                    t += seg_len;
                    continue;
                }

                if (st == 3) {
                    if (dec_frames <= 0) {
                        continue;
                    }
                    int remaining = dec_frames - (int)tim;
                    if (remaining <= 0) remaining = 1;
                    int seg_len = stop - t;
                    if (seg_len > remaining) seg_len = remaining;
                    if (seg_len <= 0) {
                        t = stop;
                        continue;
                    }
                    double target = vel * sustain_level;
                    double delta = (vel - target) / (dec_frames > 0 ? (double)dec_frames : 1.0);
                    for (int k = 0; k < seg_len; ++k) {
                        double sample = val - delta * (double)(k + 1);
                        if (sample < target) sample = target;
                        if (sample < 0.0) sample = 0.0;
                        amp_line[t + k] = sample;
                    }
                    val = amp_line[t + seg_len - 1];
                    tim += (double)seg_len;
                    if (tim >= dec_frames) {
                        val = target;
                        st = 4;
                        tim = 0.0;
                    }
                    t += seg_len;
                    continue;
                }

                if (st == 4) {
                    double sustain_val = vel * sustain_level;
                    if (sus_frames > 0) {
                        int remaining = sus_frames - (int)tim;
                        if (remaining <= 0) remaining = 1;
                        int seg_len = stop - t;
                        if (seg_len > remaining) seg_len = remaining;
                        if (seg_len <= 0) {
                            t = stop;
                            continue;
                        }
                        for (int k = 0; k < seg_len; ++k) {
                            amp_line[t + k] = sustain_val;
                        }
                        val = sustain_val;
                        tim += (double)seg_len;
                        if (tim >= sus_frames) {
                            st = 5;
                            rel_start = val;
                            tim = 0.0;
                        }
                        t += seg_len;
                        continue;
                    } else {
                        int seg_len = stop - t;
                        if (!gate_on && seg_len > 1) {
                            seg_len = 1;
                        }
                        if (seg_len <= 0) {
                            seg_len = 1;
                            if (t + seg_len > stop) seg_len = stop - t;
                        }
                        if (seg_len <= 0) {
                            break;
                        }
                        for (int k = 0; k < seg_len; ++k) {
                            amp_line[t + k] = sustain_val;
                        }
                        val = sustain_val;
                        if (!gate_on) {
                            st = 5;
                            rel_start = val;
                            tim = 0.0;
                        } else {
                            tim = 0.0;
                        }
                        t += seg_len;
                        continue;
                    }
                }

                if (st == 5) {
                    if (gate_on) {
                        amp_line[t] = 0.0;
                        envelope_start_attack(
                            t,
                            vel_line,
                            send_resets,
                            reset_line,
                            &st,
                            &tim,
                            &val,
                            &vel,
                            &rel_start,
                            &acts
                        );
                        t += 1;
                        continue;
                    }
                    if (rel_frames <= 0) {
                        continue;
                    }
                    int remaining = rel_frames - (int)tim;
                    if (remaining <= 0) remaining = 1;
                    int seg_len = stop - t;
                    if (seg_len > remaining) seg_len = remaining;
                    if (seg_len <= 0) {
                        seg_len = remaining;
                        if (seg_len <= 0) seg_len = 1;
                        if (t + seg_len > stop) seg_len = stop - t;
                        if (seg_len <= 0) {
                            break;
                        }
                    }
                    double step = rel_start / (rel_frames > 0 ? (double)rel_frames : 1.0);
                    for (int k = 0; k < seg_len; ++k) {
                        double sample = val - step * (double)(k + 1);
                        if (sample < 0.0) sample = 0.0;
                        amp_line[t + k] = sample;
                    }
                    val = amp_line[t + seg_len - 1];
                    tim += (double)seg_len;
                    if (tim >= rel_frames) {
                        val = 0.0;
                        st = 0;
                        tim = 0.0;
                    }
                    t += seg_len;
                    continue;
                }

                // Unknown stage -> silence and exit segment.
                for (int k = t; k < stop; ++k) {
                    amp_line[k] = 0.0;
                }
                val = 0.0;
                tim = 0.0;
                st = 0;
                t = stop;
            }
        }

        if (val < 0.0) val = 0.0;
        stage[b] = st;
        value[b] = val;
        timer[b] = tim;
        vel_state[b] = vel;
        activations[b] = acts;
        release_start[b] = rel_start;
    }
}

// Advance phase per frame with optional reset line. dphi and phase_state are arrays of length B*F and B respectively
void phase_advance(const double* dphi, double* phase_out, int B, int F, double* phase_state, const double* reset) {
    for (int b = 0; b < B; ++b) {
        double cur = 0.0;
        if (phase_state != NULL) cur = phase_state[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            if (reset != NULL && reset[base + i] > 0.5) cur = 0.0;
            cur = cur + dphi[base + i];
            // wrap into [0,1)
            cur = cur - floor(cur);
            phase_out[base + i] = cur;
        }
        if (phase_state != NULL) phase_state[b] = cur;
    }
}

// Portamento smoothing: per-frame smoothing with alpha derived from slide_time and slide_damp
void portamento_smooth(const double* freq_target, const double* port_mask, const double* slide_time, const double* slide_damp, int B, int F, int sr, double* freq_state, double* out) {
    for (int b = 0; b < B; ++b) {
        double cur = 0.0;
        if (freq_state != NULL) cur = freq_state[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            double target = freq_target[base + i];
            int active = port_mask != NULL && port_mask[base + i] > 0.5 ? 1 : 0;
            double frames_const = slide_time != NULL ? slide_time[base + i] * (double)sr : 1.0;
            if (frames_const < 1.0) frames_const = 1.0;
            double alpha = exp(-1.0 / frames_const);
            if (slide_damp != NULL) alpha = pow(alpha, 1.0 + fmax(0.0, slide_damp[base + i]));
            if (active) cur = alpha * cur + (1.0 - alpha) * target;
            else cur = target;
            out[base + i] = cur;
        }
        if (freq_state != NULL) freq_state[b] = cur;
    }
}

// Arp advance: write offsets per frame, update step/timer states
void arp_advance(const double* seq, int seq_len, double* offsets_out, int B, int F, int* step_state, int* timer_state, int fps) {
    for (int b = 0; b < B; ++b) {
        int step = 0;
        int timer = 0;
        if (step_state != NULL) step = step_state[b];
        if (timer_state != NULL) timer = timer_state[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            int idx = step % (seq_len > 0 ? seq_len : 1);
            offsets_out[base + i] = seq[idx];
            timer += 1;
            if (timer >= fps) {
                timer = 0;
                step = (step + 1) % (seq_len > 0 ? seq_len : 1);
            }
        }
        if (step_state != NULL) step_state[b] = step;
        if (timer_state != NULL) timer_state[b] = timer;
    }
}

void polyblep_arr(const double* t, const double* dt, double* out, int N) {
    for (int i = 0; i < N; ++i) {
        out[i] = 0.0;
    }
    for (int i = 0; i < N; ++i) {
        double ti = t[i];
        double dti = dt[i];
        if (ti < dti) {
            double x = ti / (dti > 0.0 ? dti : 1e-20);
            out[i] = x + x - x * x - 1.0;
        } else if (ti > 1.0 - dti) {
            double x = (ti - 1.0) / (dti > 0.0 ? dti : 1e-20);
            out[i] = x * x + x + x + 1.0;
        } else {
            out[i] = 0.0;
        }
    }
}

void osc_saw_blep_c(const double* ph, const double* dphi, double* out, int B, int F) {
    int N = B * F;
    for (int i = 0; i < N; ++i) {
        double t = ph[i];
        double y = 2.0 * t - 1.0;
        double pb = 0.0;
        double dti = dphi[i];
        if (t < dti) {
            double x = t / (dti > 0.0 ? dti : 1e-20);
            pb = x + x - x * x - 1.0;
        } else if (t > 1.0 - dti) {
            double x = (t - 1.0) / (dti > 0.0 ? dti : 1e-20);
            pb = x * x + x + x + 1.0;
        }
        out[i] = y - pb;
    }
}

void osc_square_blep_c(const double* ph, const double* dphi, double pw, double* out, int B, int F) {
    int N = B * F;
    for (int i = 0; i < N; ++i) {
        double t = ph[i];
        double y = (t < pw) ? 1.0 : -1.0;
        // subtract polyblep at rising edge
        double pb1 = 0.0;
        double dti = dphi[i];
        if (t < dti) {
            double x = t / (dti > 0.0 ? dti : 1e-20);
            pb1 = x + x - x * x - 1.0;
        } else if (t > 1.0 - dti) {
            double x = (t - 1.0) / (dti > 0.0 ? dti : 1e-20);
            pb1 = x * x + x + x + 1.0;
        }
        // add polyblep at falling edge (t + (1-pw))%1
        double t2 = t + (1.0 - pw);
        if (t2 >= 1.0) t2 -= 1.0;
        double pb2 = 0.0;
        if (t2 < dti) {
            double x = t2 / (dti > 0.0 ? dti : 1e-20);
            pb2 = x + x - x * x - 1.0;
        } else if (t2 > 1.0 - dti) {
            double x = (t2 - 1.0) / (dti > 0.0 ? dti : 1e-20);
            pb2 = x * x + x + x + 1.0;
        }
        out[i] = y - pb1 + pb2;
    }
}

void osc_triangle_blep_c(const double* ph, const double* dphi, double* out, int B, int F, double* tri_state) {
    int N = B * F;
    // Use square -> leaky integrator per-batch sequence
    for (int b = 0; b < B; ++b) {
        double s = 0.0;
        if (tri_state != NULL) s = tri_state[b];
        int base = b * F;
        for (int i = 0; i < F; ++i) {
            double t = ph[base + i];
            // square
            double y = (t < 0.5) ? 1.0 : -1.0;
            // blep corrections around edges
            double dti = dphi[base + i];
            double pb1 = 0.0;
            if (t < dti) {
                double x = t / (dti > 0.0 ? dti : 1e-20);
                pb1 = x + x - x * x - 1.0;
            } else if (t > 1.0 - dti) {
                double x = (t - 1.0) / (dti > 0.0 ? dti : 1e-20);
                pb1 = x * x + x + x + 1.0;
            }
            double t2 = t + 0.5; if (t2 >= 1.0) t2 -= 1.0;
            double pb2 = 0.0;
            if (t2 < dti) {
                double x = t2 / (dti > 0.0 ? dti : 1e-20);
                pb2 = x + x - x * x - 1.0;
            } else if (t2 > 1.0 - dti) {
                double x = (t2 - 1.0) / (dti > 0.0 ? dti : 1e-20);
                pb2 = x * x + x + x + 1.0;
            }
            double sq = y - pb1 + pb2;
            double leak = 0.9995;
            s = leak * s + (1.0 - leak) * sq;
            out[base + i] = s;
        }
        if (tri_state != NULL) tri_state[b] = s;
    }
}

typedef enum {
    NODE_KIND_UNKNOWN = 0,
    NODE_KIND_CONSTANT,
    NODE_KIND_GAIN,
    NODE_KIND_MIX,
    NODE_KIND_SAFETY,
    NODE_KIND_SINE_OSC,
    NODE_KIND_CONTROLLER,
    NODE_KIND_LFO,
    NODE_KIND_ENVELOPE,
    NODE_KIND_PITCH,
    NODE_KIND_OSC,
    NODE_KIND_SUBHARM,
} node_kind_t;

typedef struct {
    node_kind_t kind;
    union {
        struct {
            double value;
            int channels;
        } constant;
        struct {
            int out_channels;
        } mix;
        struct {
            double *state;
            int batches;
            int channels;
            double alpha;
        } safety;
        struct {
            double *phase;
            int batches;
            int channels;
            double base_phase;
        } sine;
        struct {
            double *phase;
            double *phase_buffer;
            double *wave_buffer;
            double *dphi_buffer;
            double *tri_state;
            int batches;
            int channels;
            double base_phase;
            int stereo;
        } osc;
        struct {
            double *slew_state;
            int batches;
            double phase;
        } lfo;
        struct {
            int *stage;
            double *value;
            double *timer;
            double *velocity;
            int64_t *activations;
            double *release_start;
            int batches;
        } envelope;
        struct {
            double *last_freq;
            int batches;
        } pitch;
        struct {
            double *hp_y;
            double *lp_y;
            double *prev;
            int8_t *sign;
            int8_t *ff2;
            int8_t *ff4;
            int32_t *ff4_count;
            double *sub2_lp;
            double *sub4_lp;
            double *env;
            double *hp_out_y;
            double *hp_out_x;
            int batches;
            int channels;
            int use_div4;
        } subharm;
    } u;
} node_state_t;

static void release_node_state(node_state_t *state) {
    if (state == NULL) {
        return;
    }
    if (state->kind == NODE_KIND_SAFETY && state->u.safety.state != NULL) {
        free(state->u.safety.state);
        state->u.safety.state = NULL;
        state->u.safety.batches = 0;
        state->u.safety.channels = 0;
        state->u.safety.alpha = 0.0;
    }
    if (state->kind == NODE_KIND_SINE_OSC && state->u.sine.phase != NULL) {
        free(state->u.sine.phase);
        state->u.sine.phase = NULL;
        state->u.sine.batches = 0;
        state->u.sine.channels = 0;
        state->u.sine.base_phase = 0.0;
    }
    if (state->kind == NODE_KIND_OSC) {
        free(state->u.osc.phase);
        free(state->u.osc.phase_buffer);
        free(state->u.osc.wave_buffer);
        free(state->u.osc.dphi_buffer);
        free(state->u.osc.tri_state);
        state->u.osc.phase = NULL;
        state->u.osc.phase_buffer = NULL;
        state->u.osc.wave_buffer = NULL;
        state->u.osc.dphi_buffer = NULL;
        state->u.osc.tri_state = NULL;
        state->u.osc.batches = 0;
        state->u.osc.channels = 0;
        state->u.osc.stereo = 0;
    }
    if (state->kind == NODE_KIND_LFO) {
        free(state->u.lfo.slew_state);
        state->u.lfo.slew_state = NULL;
        state->u.lfo.batches = 0;
        state->u.lfo.phase = 0.0;
    }
    if (state->kind == NODE_KIND_ENVELOPE) {
        free(state->u.envelope.stage);
        free(state->u.envelope.value);
        free(state->u.envelope.timer);
        free(state->u.envelope.velocity);
        free(state->u.envelope.activations);
        free(state->u.envelope.release_start);
        state->u.envelope.stage = NULL;
        state->u.envelope.value = NULL;
        state->u.envelope.timer = NULL;
        state->u.envelope.velocity = NULL;
        state->u.envelope.activations = NULL;
        state->u.envelope.release_start = NULL;
        state->u.envelope.batches = 0;
    }
    if (state->kind == NODE_KIND_PITCH) {
        free(state->u.pitch.last_freq);
        state->u.pitch.last_freq = NULL;
        state->u.pitch.batches = 0;
    }
    if (state->kind == NODE_KIND_SUBHARM) {
        free(state->u.subharm.hp_y);
        free(state->u.subharm.lp_y);
        free(state->u.subharm.prev);
        free(state->u.subharm.sign);
        free(state->u.subharm.ff2);
        free(state->u.subharm.ff4);
        free(state->u.subharm.ff4_count);
        free(state->u.subharm.sub2_lp);
        free(state->u.subharm.sub4_lp);
        free(state->u.subharm.env);
        free(state->u.subharm.hp_out_y);
        free(state->u.subharm.hp_out_x);
        state->u.subharm.hp_y = NULL;
        state->u.subharm.lp_y = NULL;
        state->u.subharm.prev = NULL;
        state->u.subharm.sign = NULL;
        state->u.subharm.ff2 = NULL;
        state->u.subharm.ff4 = NULL;
        state->u.subharm.ff4_count = NULL;
        state->u.subharm.sub2_lp = NULL;
        state->u.subharm.sub4_lp = NULL;
        state->u.subharm.env = NULL;
        state->u.subharm.hp_out_y = NULL;
        state->u.subharm.hp_out_x = NULL;
        state->u.subharm.batches = 0;
        state->u.subharm.channels = 0;
        state->u.subharm.use_div4 = 0;
    }
    free(state);
}

static node_kind_t determine_node_kind(const EdgeRunnerNodeDescriptor *descriptor) {
    if (descriptor == NULL || descriptor->type_name == NULL) {
        return NODE_KIND_UNKNOWN;
    }
    if (strcmp(descriptor->type_name, "ConstantNode") == 0) {
        return NODE_KIND_CONSTANT;
    }
    if (strcmp(descriptor->type_name, "GainNode") == 0) {
        return NODE_KIND_GAIN;
    }
    if (strcmp(descriptor->type_name, "MixNode") == 0) {
        return NODE_KIND_MIX;
    }
    if (strcmp(descriptor->type_name, "SafetyNode") == 0) {
        return NODE_KIND_SAFETY;
    }
    if (strcmp(descriptor->type_name, "SineOscillatorNode") == 0) {
        return NODE_KIND_SINE_OSC;
    }
    if (strcmp(descriptor->type_name, "ControllerNode") == 0) {
        return NODE_KIND_CONTROLLER;
    }
    if (strcmp(descriptor->type_name, "LFONode") == 0) {
        return NODE_KIND_LFO;
    }
    if (strcmp(descriptor->type_name, "EnvelopeModulatorNode") == 0) {
        return NODE_KIND_ENVELOPE;
    }
    if (strcmp(descriptor->type_name, "PitchQuantizerNode") == 0) {
        return NODE_KIND_PITCH;
    }
    if (strcmp(descriptor->type_name, "OscNode") == 0) {
        return NODE_KIND_OSC;
    }
    if (strcmp(descriptor->type_name, "SubharmonicLowLifterNode") == 0) {
        return NODE_KIND_SUBHARM;
    }
    return NODE_KIND_UNKNOWN;
}

static double json_get_double(const char *json, size_t json_len, const char *key, double default_value) {
    (void)json_len;
    if (json == NULL || key == NULL) {
        return default_value;
    }
    size_t key_len = strlen(key);
    if (key_len == 0) {
        return default_value;
    }
    char pattern[128];
    if (key_len + 3 >= sizeof(pattern)) {
        return default_value;
    }
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    const char *cursor = json;
    size_t pattern_len = strlen(pattern);
    while ((cursor = strstr(cursor, pattern)) != NULL) {
        cursor += pattern_len;
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\r' || *cursor == '\n') {
            cursor++;
        }
        if (*cursor != ':') {
            continue;
        }
        cursor++;
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\r' || *cursor == '\n') {
            cursor++;
        }
        if (*cursor == '\0') {
            break;
        }
        char *endptr = NULL;
        double value = strtod(cursor, &endptr);
        if (endptr == cursor) {
            cursor = endptr;
            continue;
        }
        return value;
    }
    return default_value;
}

static int json_get_int(const char *json, size_t json_len, const char *key, int default_value) {
    double value = json_get_double(json, json_len, key, (double)default_value);
    if (value >= 0.0) {
        return (int)(value + 0.5);
    }
    return (int)(value - 0.5);
}

static int json_get_bool(const char *json, size_t json_len, const char *key, int default_value) {
    double value = json_get_double(json, json_len, key, default_value ? 1.0 : 0.0);
    return value >= 0.5 ? 1 : 0;
}

static int json_copy_string(const char *json, size_t json_len, const char *key, char *out, size_t out_len) {
    (void)json_len;
    if (out == NULL || out_len == 0) {
        return 0;
    }
    out[0] = '\0';
    if (json == NULL || key == NULL) {
        return 0;
    }
    size_t key_len = strlen(key);
    if (key_len == 0) {
        return 0;
    }
    char pattern[128];
    if (key_len + 3 >= sizeof(pattern)) {
        return 0;
    }
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    const char *cursor = json;
    size_t pattern_len = strlen(pattern);
    while ((cursor = strstr(cursor, pattern)) != NULL) {
        cursor += pattern_len;
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\r' || *cursor == '\n') {
            cursor++;
        }
        if (*cursor != ':') {
            continue;
        }
        cursor++;
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\r' || *cursor == '\n') {
            cursor++;
        }
        if (*cursor != '"') {
            continue;
        }
        cursor++;
        const char *start = cursor;
        while (*cursor != '\0' && *cursor != '"') {
            cursor++;
        }
        size_t length = (size_t)(cursor - start);
        if (length >= out_len) {
            length = out_len - 1;
        }
        memcpy(out, start, length);
        out[length] = '\0';
        return 1;
    }
    return 0;
}

static const EdgeRunnerParamView *find_param(const EdgeRunnerNodeInputs *inputs, const char *name) {
    if (inputs == NULL || name == NULL) {
        return NULL;
    }
    uint32_t count = inputs->params.count;
    EdgeRunnerParamView *items = inputs->params.items;
    for (uint32_t i = 0; i < count; ++i) {
        const EdgeRunnerParamView *view = &items[i];
        if (view->name != NULL && strcmp(view->name, name) == 0) {
            return view;
        }
    }
    return NULL;
}

typedef struct {
    char output[64];
    char source[64];
} controller_source_t;

static int parse_csv_tokens(const char *csv, char tokens[][64], int max_tokens) {
    if (csv == NULL || tokens == NULL || max_tokens <= 0) {
        return 0;
    }
    int count = 0;
    const char *cursor = csv;
    while (*cursor != '\0' && count < max_tokens) {
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\n' || *cursor == ',') {
            cursor++;
        }
        if (*cursor == '\0') {
            break;
        }
        const char *start = cursor;
        while (*cursor != '\0' && *cursor != ',') {
            cursor++;
        }
        size_t len = (size_t)(cursor - start);
        if (len >= 63) {
            len = 63;
        }
        memcpy(tokens[count], start, len);
        tokens[count][len] = '\0';
        count++;
    }
    return count;
}

static int parse_controller_sources(const char *csv, controller_source_t *items, int max_items) {
    if (csv == NULL || items == NULL || max_items <= 0) {
        return 0;
    }
    int count = 0;
    const char *cursor = csv;
    while (*cursor != '\0' && count < max_items) {
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\n' || *cursor == ',') {
            cursor++;
        }
        if (*cursor == '\0') {
            break;
        }
        const char *eq = strchr(cursor, '=');
        if (eq == NULL) {
            break;
        }
        size_t key_len = (size_t)(eq - cursor);
        if (key_len >= sizeof(items[count].output)) {
            key_len = sizeof(items[count].output) - 1;
        }
        memcpy(items[count].output, cursor, key_len);
        items[count].output[key_len] = '\0';
        cursor = eq + 1;
        const char *end = strchr(cursor, ',');
        if (end == NULL) {
            end = cursor + strlen(cursor);
        }
        size_t value_len = (size_t)(end - cursor);
        if (value_len >= sizeof(items[count].source)) {
            value_len = sizeof(items[count].source) - 1;
        }
        memcpy(items[count].source, cursor, value_len);
        items[count].source[value_len] = '\0';
        cursor = end;
        count++;
    }
    return count;
}

static int parse_csv_doubles(const char *csv, double *values, int max_values) {
    if (csv == NULL || values == NULL || max_values <= 0) {
        return 0;
    }
    int count = 0;
    const char *cursor = csv;
    while (*cursor != '\0' && count < max_values) {
        while (*cursor == ' ' || *cursor == '\t' || *cursor == '\n' || *cursor == ',') {
            cursor++;
        }
        if (*cursor == '\0') {
            break;
        }
        char *endptr = NULL;
        double value = strtod(cursor, &endptr);
        if (endptr == cursor) {
            break;
        }
        values[count++] = value;
        cursor = endptr;
    }
    return count;
}

static const double *ensure_param_plane(
    const EdgeRunnerParamView *view,
    int batches,
    int frames,
    double default_value,
    double **owned_out
) {
    if (owned_out != NULL) {
        *owned_out = NULL;
    }
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    size_t total = (size_t)batches * (size_t)frames;
    if (view == NULL || view->data == NULL) {
        if (owned_out == NULL) {
            return NULL;
        }
        double *buf = (double *)malloc(total * sizeof(double));
        if (buf == NULL) {
            return NULL;
        }
        for (size_t i = 0; i < total; ++i) {
            buf[i] = default_value;
        }
        *owned_out = buf;
        return buf;
    }
    int vb = view->batches > 0 ? (int)view->batches : batches;
    int vc = view->channels > 0 ? (int)view->channels : 1;
    int vf = view->frames > 0 ? (int)view->frames : frames;
    if (vb == batches && vc == 1 && vf == frames) {
        return view->data;
    }
    if (owned_out == NULL) {
        return NULL;
    }
    double *buf = (double *)malloc(total * sizeof(double));
    if (buf == NULL) {
        return NULL;
    }
    for (int b = 0; b < batches; ++b) {
        for (int f = 0; f < frames; ++f) {
            size_t idx = (size_t)b * (size_t)frames + (size_t)f;
            double value = default_value;
            if (b < vb && f < vf) {
                size_t src_idx = ((size_t)b * (size_t)vc) * (size_t)vf + (size_t)f;
                if (vc > 0) {
                    src_idx = ((size_t)b * (size_t)vc + 0) * (size_t)vf + (size_t)f;
                }
                size_t span = (size_t)vb * (size_t)vc * (size_t)vf;
                if (src_idx < span) {
                    value = view->data[src_idx];
                }
            }
            buf[idx] = value;
        }
    }
    *owned_out = buf;
    return buf;
}

static double read_scalar_param(const EdgeRunnerParamView *view, double default_value) {
    if (view == NULL || view->data == NULL) {
        return default_value;
    }
    size_t total = (size_t)(view->batches ? view->batches : 1)
        * (size_t)(view->channels ? view->channels : 1)
        * (size_t)(view->frames ? view->frames : 1);
    if (total == 0) {
        return default_value;
    }
    return view->data[total - 1];
}

static int compare_double(const void *a, const void *b) {
    double da = *(const double *)a;
    double db = *(const double *)b;
    if (da < db) {
        return -1;
    }
    if (da > db) {
        return 1;
    }
    return 0;
}

static int build_sorted_grid(const double *values, int count, double *sorted, double *ext) {
    if (values == NULL || sorted == NULL || ext == NULL || count <= 0) {
        return 0;
    }
    int n = count;
    if (n < 2) {
        n = 12;
        for (int i = 0; i < n; ++i) {
            sorted[i] = (double)i * 100.0;
        }
    } else {
        memcpy(sorted, values, (size_t)n * sizeof(double));
        qsort(sorted, (size_t)n, sizeof(double), compare_double);
    }
    for (int i = 0; i < n; ++i) {
        ext[i] = sorted[i];
    }
    ext[n] = sorted[0] + 1200.0;
    return n;
}

static double grid_warp_forward_value(double cents, const double *grid, const double *grid_ext, int N) {
    double octs = floor(cents / 1200.0);
    double c_mod = fmod(cents, 1200.0);
    if (c_mod < 0.0) {
        c_mod += 1200.0;
    }
    int idx = 0;
    for (int i = 0; i < N; ++i) {
        if (c_mod >= grid_ext[i] && c_mod < grid_ext[i + 1]) {
            idx = i;
            break;
        }
        if (i == N - 1) {
            idx = N - 1;
        }
    }
    double lower = grid_ext[idx];
    double upper = grid_ext[idx + 1];
    double denom = upper - lower;
    if (fabs(denom) < 1e-9) {
        denom = 1e-9;
    }
    double t = (c_mod - lower) / denom;
    double u_mod = (double)idx + t;
    return octs * (double)N + u_mod;
}

static double grid_warp_inverse_value(double u, const double *grid, const double *grid_ext, int N) {
    double octs = floor(u / (double)N);
    double u_mod = u - octs * (double)N;
    int idx = (int)floor(u_mod);
    if (idx < 0) {
        idx = 0;
    }
    if (idx >= N) {
        idx = N - 1;
    }
    double frac = u_mod - (double)idx;
    double lower = grid_ext[idx];
    double upper = grid_ext[idx + 1];
    double cents = lower + frac * (upper - lower);
    return octs * 1200.0 + cents;
}

static int run_constant_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    int batches,
    int frames,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    int channels = json_get_int(descriptor->params_json, descriptor->params_len, "channels", 1);
    if (channels <= 0) {
        channels = 1;
    }
    double value = json_get_double(descriptor->params_json, descriptor->params_len, "value", 0.0);
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    for (size_t i = 0; i < total; ++i) {
        buffer[i] = value;
    }
    if (state != NULL) {
        state->u.constant.value = value;
        state->u.constant.channels = channels;
    }
    *out_buffer = buffer;
    *out_channels = channels;
    return 0;
}

static double render_lfo_wave(const char *wave, double phase) {
    if (wave != NULL) {
        if (strcmp(wave, "square") == 0) {
            return phase < 0.5 ? 1.0 : -1.0;
        }
        if (strcmp(wave, "saw") == 0) {
            double t = phase - floor(phase);
            return 2.0 * t - 1.0;
        }
        if (strcmp(wave, "triangle") == 0) {
            double t = phase - floor(phase);
            return 2.0 * fabs(2.0 * t - 1.0) - 1.0;
        }
    }
    return sin(phase * 2.0 * M_PI);
}

static int run_controller_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double **out_buffer,
    int *out_channels,
    const EdgeRunnerControlHistory *history
) {
    if (out_buffer == NULL || out_channels == NULL) {
        return -1;
    }
    char outputs_csv[256];
    char sources_csv[512];
    char output_names[32][64];
    controller_source_t mappings[32];
    int output_count = 0;
    if (json_copy_string(descriptor->params_json, descriptor->params_len, "__controller_outputs__", outputs_csv, sizeof(outputs_csv))) {
        output_count = parse_csv_tokens(outputs_csv, output_names, 32);
    }
    if (output_count <= 0 && inputs != NULL) {
        uint32_t count = inputs->params.count;
        EdgeRunnerParamView *items = inputs->params.items;
        for (uint32_t i = 0; i < count && i < 32U; ++i) {
            if (items[i].name != NULL) {
                strncpy(output_names[output_count], items[i].name, sizeof(output_names[output_count]) - 1);
                output_names[output_count][sizeof(output_names[output_count]) - 1] = '\0';
                output_count++;
            }
        }
    }
    if (output_count <= 0) {
        return -1;
    }
    int mapping_count = 0;
    if (json_copy_string(descriptor->params_json, descriptor->params_len, "__controller_sources__", sources_csv, sizeof(sources_csv))) {
        mapping_count = parse_controller_sources(sources_csv, mappings, 32);
    }
    int resolved_channels = output_count;
    if (inputs != NULL && inputs->params.count > 0) {
        const EdgeRunnerParamView *view = &inputs->params.items[0];
        if (batches <= 0 && view->batches > 0) {
            batches = (int)view->batches;
        }
        if (frames <= 0 && view->frames > 0) {
            frames = (int)view->frames;
        }
    }
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    size_t total = (size_t)batches * (size_t)resolved_channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    for (int c = 0; c < resolved_channels; ++c) {
        const char *source_name = output_names[c];
        for (int m = 0; m < mapping_count; ++m) {
            if (strcmp(mappings[m].output, output_names[c]) == 0) {
                source_name = mappings[m].source;
                break;
            }
        }
        const EdgeRunnerParamView *view = find_param(inputs, source_name);
        int view_missing = (view == NULL || view->data == NULL);
        double *owned = NULL;
        const double *data = ensure_param_plane(view, batches, frames, 0.0, &owned);
        if (data == NULL) {
            free(buffer);
            return -1;
        }
        if (view_missing && owned != NULL && history != NULL) {
            const EdgeRunnerControlCurve *curve = find_history_curve(history, source_name, strlen(source_name));
            if (curve != NULL) {
                apply_history_curve(owned, batches, frames, curve);
            }
            data = owned;
        }
        for (int b = 0; b < batches; ++b) {
            for (int f = 0; f < frames; ++f) {
                size_t src_idx = (size_t)b * (size_t)frames + (size_t)f;
                size_t dst_idx = ((size_t)b * (size_t)resolved_channels + (size_t)c) * (size_t)frames + (size_t)f;
                buffer[dst_idx] = data[src_idx];
            }
        }
        if (owned != NULL) {
            free(owned);
        }
    }
    *out_buffer = buffer;
    *out_channels = resolved_channels;
    return 0;
}

static int run_lfo_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (out_buffer == NULL || out_channels == NULL) {
        return -1;
    }
    char wave_buf[32];
    if (!json_copy_string(descriptor->params_json, descriptor->params_len, "wave", wave_buf, sizeof(wave_buf))) {
        strcpy(wave_buf, "sine");
    }
    double rate_hz = json_get_double(descriptor->params_json, descriptor->params_len, "rate_hz", 1.0);
    double depth = json_get_double(descriptor->params_json, descriptor->params_len, "depth", 0.5);
    double slew_ms = json_get_double(descriptor->params_json, descriptor->params_len, "slew_ms", 0.0);
    int use_input = json_get_bool(descriptor->params_json, descriptor->params_len, "use_input", 0);
    int B = batches > 0 ? batches : 1;
    int F = frames > 0 ? frames : 1;
    int audio_channels = 0;
    const double *audio_data = NULL;
    if (use_input && inputs != NULL && inputs->audio.has_audio && inputs->audio.data != NULL) {
        B = inputs->audio.batches > 0 ? (int)inputs->audio.batches : B;
        F = inputs->audio.frames > 0 ? (int)inputs->audio.frames : F;
        audio_channels = inputs->audio.channels > 0 ? (int)inputs->audio.channels : 1;
        audio_data = inputs->audio.data;
    }
    size_t total = (size_t)B * (size_t)F;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    if (use_input && audio_data != NULL) {
        for (int b = 0; b < B; ++b) {
            double max_abs = 0.0;
            for (int c = 0; c < audio_channels; ++c) {
                for (int f = 0; f < F; ++f) {
                    size_t idx = ((size_t)b * (size_t)audio_channels + (size_t)c) * (size_t)F + (size_t)f;
                    double val = fabs(audio_data[idx]);
                    if (val > max_abs) {
                        max_abs = val;
                    }
                }
            }
            if (max_abs < 1e-12) {
                max_abs = 1.0;
            }
            for (int f = 0; f < F; ++f) {
                size_t src_idx = ((size_t)b * (size_t)audio_channels) * (size_t)F + (size_t)f;
                double sample = audio_data[src_idx];
                buffer[(size_t)b * (size_t)F + (size_t)f] = (sample / max_abs) * depth;
            }
        }
    } else {
        if (sample_rate <= 0.0) {
            sample_rate = 48000.0;
        }
        double step = rate_hz / sample_rate;
        double phase = 0.0;
        if (state != NULL) {
            phase = state->u.lfo.phase;
        }
        for (int b = 0; b < B; ++b) {
            double local_phase = phase;
            for (int f = 0; f < F; ++f) {
                double value = render_lfo_wave(wave_buf, local_phase) * depth;
                buffer[(size_t)b * (size_t)F + (size_t)f] = value;
                local_phase += step;
                local_phase -= floor(local_phase);
            }
            if (state != NULL) {
                phase = local_phase;
            }
        }
        if (state != NULL) {
            state->u.lfo.phase = phase;
        }
    }
    if (slew_ms > 0.0 && state != NULL) {
        if (sample_rate <= 0.0) {
            sample_rate = 48000.0;
        }
        double alpha = 1.0 - exp(-1.0 / (sample_rate * (slew_ms / 1000.0)));
        if (alpha < 1.0 - 1e-15) {
            double r = 1.0 - alpha;
            if (state->u.lfo.slew_state == NULL || state->u.lfo.batches != B) {
                free(state->u.lfo.slew_state);
                state->u.lfo.slew_state = (double *)calloc((size_t)B, sizeof(double));
                state->u.lfo.batches = B;
            }
            if (state->u.lfo.slew_state != NULL) {
                lfo_slew(buffer, buffer, B, F, r, alpha, state->u.lfo.slew_state);
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = 1;
    return 0;
}

static int run_envelope_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (out_buffer == NULL || out_channels == NULL) {
        return -1;
    }
    if (sample_rate <= 0.0) {
        sample_rate = 48000.0;
    }
    int B = batches > 0 ? batches : 1;
    int F = frames > 0 ? frames : 1;
    const EdgeRunnerParamView *trigger_view = find_param(inputs, "trigger");
    const EdgeRunnerParamView *gate_view = find_param(inputs, "gate");
    const EdgeRunnerParamView *drone_view = find_param(inputs, "drone");
    const EdgeRunnerParamView *velocity_view = find_param(inputs, "velocity");
    const EdgeRunnerParamView *send_reset_view = find_param(inputs, "send_reset");
    if (trigger_view != NULL && trigger_view->batches > 0) {
        B = (int)trigger_view->batches;
    }
    if (trigger_view != NULL && trigger_view->frames > 0) {
        F = (int)trigger_view->frames;
    }
    if (B <= 0) {
        B = 1;
    }
    if (F <= 0) {
        F = 1;
    }
    double attack_ms = json_get_double(descriptor->params_json, descriptor->params_len, "attack_ms", 12.0);
    double hold_ms = json_get_double(descriptor->params_json, descriptor->params_len, "hold_ms", 8.0);
    double decay_ms = json_get_double(descriptor->params_json, descriptor->params_len, "decay_ms", 90.0);
    double sustain_level = json_get_double(descriptor->params_json, descriptor->params_len, "sustain_level", 0.7);
    double sustain_ms = json_get_double(descriptor->params_json, descriptor->params_len, "sustain_ms", 0.0);
    double release_ms = json_get_double(descriptor->params_json, descriptor->params_len, "release_ms", 220.0);
    int send_resets_default = json_get_bool(descriptor->params_json, descriptor->params_len, "send_resets", 1);
    int atk_frames = (int)lrint((attack_ms / 1000.0) * sample_rate);
    int hold_frames = (int)lrint((hold_ms / 1000.0) * sample_rate);
    int dec_frames = (int)lrint((decay_ms / 1000.0) * sample_rate);
    int sus_frames = (int)lrint((sustain_ms / 1000.0) * sample_rate);
    int rel_frames = (int)lrint((release_ms / 1000.0) * sample_rate);
    if (atk_frames < 0) atk_frames = 0;
    if (hold_frames < 0) hold_frames = 0;
    if (dec_frames < 0) dec_frames = 0;
    if (sus_frames < 0) sus_frames = 0;
    if (rel_frames < 0) rel_frames = 0;
    double *owned_trigger = NULL;
    double *owned_gate = NULL;
    double *owned_drone = NULL;
    double *owned_velocity = NULL;
    const double *trigger = ensure_param_plane(trigger_view, B, F, 0.0, &owned_trigger);
    const double *gate = ensure_param_plane(gate_view, B, F, 0.0, &owned_gate);
    const double *drone = ensure_param_plane(drone_view, B, F, 0.0, &owned_drone);
    const double *velocity = ensure_param_plane(velocity_view, B, F, 1.0, &owned_velocity);
    if (trigger == NULL || gate == NULL || drone == NULL || velocity == NULL) {
        free(owned_trigger);
        free(owned_gate);
        free(owned_drone);
        free(owned_velocity);
        return -1;
    }
    double send_reset_value = read_scalar_param(send_reset_view, (double)send_resets_default);
    int send_reset_flag = send_reset_value >= 0.5 ? 1 : 0;
    size_t total = (size_t)B * (size_t)F * 2;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        free(owned_trigger);
        free(owned_gate);
        free(owned_drone);
        free(owned_velocity);
        return -1;
    }
    double *amp_plane = buffer;
    double *reset_plane = buffer + (size_t)B * (size_t)F;
    if (state == NULL) {
        free(buffer);
        free(owned_trigger);
        free(owned_gate);
        free(owned_drone);
        free(owned_velocity);
        return -1;
    }
    if (state->u.envelope.stage == NULL || state->u.envelope.batches != B) {
        free(state->u.envelope.stage);
        free(state->u.envelope.value);
        free(state->u.envelope.timer);
        free(state->u.envelope.velocity);
        free(state->u.envelope.activations);
        free(state->u.envelope.release_start);
        state->u.envelope.stage = (int *)calloc((size_t)B, sizeof(int));
        state->u.envelope.value = (double *)calloc((size_t)B, sizeof(double));
        state->u.envelope.timer = (double *)calloc((size_t)B, sizeof(double));
        state->u.envelope.velocity = (double *)calloc((size_t)B, sizeof(double));
        state->u.envelope.activations = (int64_t *)calloc((size_t)B, sizeof(int64_t));
        state->u.envelope.release_start = (double *)calloc((size_t)B, sizeof(double));
        state->u.envelope.batches = B;
    }
    if (state->u.envelope.stage == NULL || state->u.envelope.value == NULL || state->u.envelope.timer == NULL) {
        free(buffer);
        free(owned_trigger);
        free(owned_gate);
        free(owned_drone);
        free(owned_velocity);
        return -1;
    }
    envelope_process(
        trigger,
        gate,
        drone,
        velocity,
        B,
        F,
        atk_frames,
        hold_frames,
        dec_frames,
        sus_frames,
        rel_frames,
        sustain_level,
        send_reset_flag,
        state->u.envelope.stage,
        state->u.envelope.value,
        state->u.envelope.timer,
        state->u.envelope.velocity,
        state->u.envelope.activations,
        state->u.envelope.release_start,
        amp_plane,
        reset_plane
    );
    free(owned_trigger);
    free(owned_gate);
    free(owned_drone);
    free(owned_velocity);
    *out_buffer = buffer;
    *out_channels = 2;
    return 0;
}

static int run_pitch_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    (void)sample_rate;
    if (out_buffer == NULL || out_channels == NULL || state == NULL) {
        return -1;
    }
    char grid_csv[1024];
    double grid_values[256];
    double grid_sorted_vals[256];
    double grid_ext[257];
    int grid_count = 0;
    if (json_copy_string(descriptor->params_json, descriptor->params_len, "grid_cents", grid_csv, sizeof(grid_csv))) {
        grid_count = parse_csv_doubles(grid_csv, grid_values, 256);
    }
    if (grid_count <= 0) {
        for (int i = 0; i < 12; ++i) {
            grid_values[i] = (double)i * 100.0;
        }
        grid_count = 12;
    }
    int grid_size = build_sorted_grid(grid_values, grid_count, grid_sorted_vals, grid_ext);
    int is_free_mode = json_get_bool(descriptor->params_json, descriptor->params_len, "is_free_mode", 0);
    char variant_buf[32];
    if (!json_copy_string(descriptor->params_json, descriptor->params_len, "free_variant", variant_buf, sizeof(variant_buf))) {
        strcpy(variant_buf, "continuous");
    }
    double span_default = json_get_double(descriptor->params_json, descriptor->params_len, "span_default", 2.0);
    int slew_enabled = json_get_bool(descriptor->params_json, descriptor->params_len, "slew", 1);
    const EdgeRunnerParamView *input_view = find_param(inputs, "input");
    const EdgeRunnerParamView *root_view = find_param(inputs, "root_midi");
    const EdgeRunnerParamView *span_view = find_param(inputs, "span_oct");
    int B = batches > 0 ? batches : 1;
    int F = frames > 0 ? frames : 1;
    if (input_view != NULL && input_view->batches > 0) {
        B = (int)input_view->batches;
    }
    if (input_view != NULL && input_view->frames > 0) {
        F = (int)input_view->frames;
    }
    if (B <= 0) B = 1;
    if (F <= 0) F = 1;
    double *owned_input = NULL;
    double *owned_root = NULL;
    double *owned_span = NULL;
    const double *ctrl = ensure_param_plane(input_view, B, F, 0.0, &owned_input);
    const double *root = ensure_param_plane(root_view, B, F, 60.0, &owned_root);
    const double *span = ensure_param_plane(span_view, B, F, span_default, &owned_span);
    if (ctrl == NULL || root == NULL || span == NULL) {
        free(owned_input);
        free(owned_root);
        free(owned_span);
        return -1;
    }
    size_t total = (size_t)B * (size_t)F;
    double *freq_target = (double *)malloc(total * sizeof(double));
    if (freq_target == NULL) {
        free(owned_input);
        free(owned_root);
        free(owned_span);
        return -1;
    }
    for (int b = 0; b < B; ++b) {
        for (int f = 0; f < F; ++f) {
            size_t idx = (size_t)b * (size_t)F + (size_t)f;
            double ctrl_scaled = ctrl[idx] * span[idx];
            double root_midi = root[idx];
            double root_freq = 440.0 * pow(2.0, (root_midi - 69.0) / 12.0);
            double cents = 0.0;
            if (is_free_mode) {
                if (strcmp(variant_buf, "weighted") == 0) {
                    double u = ctrl_scaled * (double)grid_size;
                    cents = grid_warp_inverse_value(u, grid_sorted_vals, grid_ext, grid_size);
                } else if (strcmp(variant_buf, "stepped") == 0) {
                    double u = round(ctrl_scaled * (double)grid_size);
                    cents = grid_warp_inverse_value(u, grid_sorted_vals, grid_ext, grid_size);
                } else {
                    cents = ctrl_scaled * 1200.0;
                }
            } else {
                double cents_unq = ctrl_scaled * 1200.0;
                double u = grid_warp_forward_value(cents_unq, grid_sorted_vals, grid_ext, grid_size);
                double u_round = round(u);
                cents = grid_warp_inverse_value(u_round, grid_sorted_vals, grid_ext, grid_size);
            }
            freq_target[idx] = root_freq * pow(2.0, cents / 1200.0);
        }
    }
    free(owned_input);
    free(owned_root);
    free(owned_span);
    double *output = (double *)malloc(total * sizeof(double));
    if (output == NULL) {
        free(freq_target);
        return -1;
    }
    if (slew_enabled) {
        if (state->u.pitch.last_freq == NULL || state->u.pitch.batches != B) {
            free(state->u.pitch.last_freq);
            state->u.pitch.last_freq = (double *)calloc((size_t)B, sizeof(double));
            state->u.pitch.batches = B;
        }
        if (state->u.pitch.last_freq == NULL) {
            free(freq_target);
            free(output);
            return -1;
        }
        for (int b = 0; b < B; ++b) {
            double y0 = state->u.pitch.last_freq[b];
            double y1 = freq_target[(size_t)b * (size_t)F + (size_t)(F - 1)];
            for (int f = 0; f < F; ++f) {
                double t = (double)f / (double)F;
                double ramp = 3.0 * t * t - 2.0 * t * t * t;
                output[(size_t)b * (size_t)F + (size_t)f] = y0 + (y1 - y0) * ramp;
            }
            state->u.pitch.last_freq[b] = y1;
        }
    } else {
        memcpy(output, freq_target, total * sizeof(double));
    }
    free(freq_target);
    *out_buffer = output;
    *out_channels = 1;
    return 0;
}

static double alpha_lp(double fc, double sr) {
    if (fc < 1.0) {
        fc = 1.0;
    }
    return 1.0 - exp(-2.0 * M_PI * fc / sr);
}

static double alpha_hp(double fc, double sr) {
    if (fc < 1.0) {
        fc = 1.0;
    }
    double rc = 1.0 / (2.0 * M_PI * fc);
    return rc / (rc + 1.0 / sr);
}

static int run_subharm_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (out_buffer == NULL || out_channels == NULL || state == NULL) {
        return -1;
    }
    if (inputs == NULL || !inputs->audio.has_audio || inputs->audio.data == NULL) {
        return -1;
    }
    int B = inputs->audio.batches > 0 ? (int)inputs->audio.batches : (batches > 0 ? batches : 1);
    int C = inputs->audio.channels > 0 ? (int)inputs->audio.channels : 1;
    int F = inputs->audio.frames > 0 ? (int)inputs->audio.frames : (frames > 0 ? frames : 1);
    if (sample_rate <= 0.0) {
        sample_rate = 48000.0;
    }
    const double *audio = inputs->audio.data;
    double band_lo = json_get_double(descriptor->params_json, descriptor->params_len, "band_lo", 70.0);
    double band_hi = json_get_double(descriptor->params_json, descriptor->params_len, "band_hi", 160.0);
    double mix = json_get_double(descriptor->params_json, descriptor->params_len, "mix", 0.5);
    double drive = json_get_double(descriptor->params_json, descriptor->params_len, "drive", 1.0);
    double out_hp = json_get_double(descriptor->params_json, descriptor->params_len, "out_hp", 25.0);
    int use_div4 = json_get_bool(descriptor->params_json, descriptor->params_len, "use_div4", 0);
    double a_hp_in = alpha_hp(band_lo, sample_rate);
    double a_lp_in = alpha_lp(band_hi, sample_rate);
    double a_sub2 = alpha_lp(fmax(band_hi / 3.0, 30.0), sample_rate);
    double a_sub4 = use_div4 ? alpha_lp(fmax(band_hi / 5.0, 20.0), sample_rate) : 0.0;
    double a_env_attack = alpha_lp(100.0, sample_rate);
    double a_env_release = alpha_lp(5.0, sample_rate);
    double a_hp_out = alpha_hp(out_hp, sample_rate);
    size_t total = (size_t)B * (size_t)C * (size_t)F;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    int need_resize = state->u.subharm.batches != B || state->u.subharm.channels != C || state->u.subharm.use_div4 != use_div4;
    if (need_resize) {
        free(state->u.subharm.hp_y);
        free(state->u.subharm.lp_y);
        free(state->u.subharm.prev);
        free(state->u.subharm.sign);
        free(state->u.subharm.ff2);
        free(state->u.subharm.ff4);
        free(state->u.subharm.ff4_count);
        free(state->u.subharm.sub2_lp);
        free(state->u.subharm.sub4_lp);
        free(state->u.subharm.env);
        free(state->u.subharm.hp_out_y);
        free(state->u.subharm.hp_out_x);
        state->u.subharm.hp_y = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.lp_y = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.prev = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.sign = (int8_t *)calloc((size_t)B * (size_t)C, sizeof(int8_t));
        state->u.subharm.ff2 = (int8_t *)calloc((size_t)B * (size_t)C, sizeof(int8_t));
        state->u.subharm.sub2_lp = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.env = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.hp_out_y = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        state->u.subharm.hp_out_x = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        if (use_div4) {
            state->u.subharm.ff4 = (int8_t *)calloc((size_t)B * (size_t)C, sizeof(int8_t));
            state->u.subharm.ff4_count = (int32_t *)calloc((size_t)B * (size_t)C, sizeof(int32_t));
            state->u.subharm.sub4_lp = (double *)calloc((size_t)B * (size_t)C, sizeof(double));
        } else {
            free(state->u.subharm.ff4);
            free(state->u.subharm.ff4_count);
            free(state->u.subharm.sub4_lp);
            state->u.subharm.ff4 = NULL;
            state->u.subharm.ff4_count = NULL;
            state->u.subharm.sub4_lp = NULL;
        }
        state->u.subharm.batches = B;
        state->u.subharm.channels = C;
        state->u.subharm.use_div4 = use_div4;
    }
    if (state->u.subharm.hp_y == NULL || state->u.subharm.lp_y == NULL || state->u.subharm.prev == NULL || state->u.subharm.sign == NULL || state->u.subharm.ff2 == NULL || state->u.subharm.sub2_lp == NULL || state->u.subharm.env == NULL || state->u.subharm.hp_out_y == NULL || state->u.subharm.hp_out_x == NULL) {
        free(buffer);
        return -1;
    }
    subharmonic_process(
        audio,
        buffer,
        B,
        C,
        F,
        a_hp_in,
        a_lp_in,
        a_sub2,
        use_div4,
        a_sub4,
        a_env_attack,
        a_env_release,
        a_hp_out,
        drive,
        mix,
        state->u.subharm.hp_y,
        state->u.subharm.lp_y,
        state->u.subharm.prev,
        state->u.subharm.sign,
        state->u.subharm.ff2,
        state->u.subharm.ff4,
        state->u.subharm.ff4_count,
        state->u.subharm.sub2_lp,
        state->u.subharm.sub4_lp,
        state->u.subharm.env,
        state->u.subharm.hp_out_y,
        state->u.subharm.hp_out_x
    );
    *out_buffer = buffer;
    *out_channels = C;
    return 0;
}

static int run_osc_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (out_buffer == NULL || out_channels == NULL || state == NULL) {
        return -1;
    }
    if (sample_rate <= 0.0) {
        sample_rate = 48000.0;
    }
    char wave_buf[32];
    if (!json_copy_string(descriptor->params_json, descriptor->params_len, "wave", wave_buf, sizeof(wave_buf))) {
        strcpy(wave_buf, "sine");
    }
    int accept_reset = json_get_bool(descriptor->params_json, descriptor->params_len, "accept_reset", 1);
    const EdgeRunnerParamView *freq_view = find_param(inputs, "freq");
    const EdgeRunnerParamView *amp_view = find_param(inputs, "amp");
    const EdgeRunnerParamView *pan_view = find_param(inputs, "pan");
    const EdgeRunnerParamView *reset_view = accept_reset ? find_param(inputs, "reset") : NULL;
    int B = batches > 0 ? batches : 1;
    int F = frames > 0 ? frames : 1;
    if (freq_view != NULL && freq_view->batches > 0) {
        B = (int)freq_view->batches;
    }
    if (freq_view != NULL && freq_view->frames > 0) {
        F = (int)freq_view->frames;
    }
    if (B <= 0) B = 1;
    if (F <= 0) F = 1;
    double *owned_freq = NULL;
    double *owned_amp = NULL;
    double *owned_pan = NULL;
    double *owned_reset = NULL;
    const double *freq = ensure_param_plane(freq_view, B, F, 0.0, &owned_freq);
    const double *amp = ensure_param_plane(amp_view, B, F, 1.0, &owned_amp);
    const double *pan = ensure_param_plane(pan_view, B, F, 0.0, &owned_pan);
    const double *reset = ensure_param_plane(reset_view, B, F, 0.0, &owned_reset);
    if (freq == NULL || amp == NULL) {
        free(owned_freq);
        free(owned_amp);
        free(owned_pan);
        free(owned_reset);
        return -1;
    }
    size_t total = (size_t)B * (size_t)F;
    if (state->u.osc.phase == NULL || state->u.osc.batches != B) {
        free(state->u.osc.phase);
        state->u.osc.phase = (double *)calloc((size_t)B, sizeof(double));
        state->u.osc.batches = B;
    }
    if (state->u.osc.phase_buffer == NULL || state->u.osc.batches != B || state->u.osc.channels != 1) {
        free(state->u.osc.phase_buffer);
        state->u.osc.phase_buffer = (double *)malloc(total * sizeof(double));
    }
    if (state->u.osc.wave_buffer == NULL || state->u.osc.batches != B || state->u.osc.channels != 1) {
        free(state->u.osc.wave_buffer);
        state->u.osc.wave_buffer = (double *)malloc(total * sizeof(double));
    }
    if (state->u.osc.dphi_buffer == NULL || state->u.osc.batches != B || state->u.osc.channels != 1) {
        free(state->u.osc.dphi_buffer);
        state->u.osc.dphi_buffer = (double *)malloc(total * sizeof(double));
    }
    if (strcmp(wave_buf, "triangle") == 0) {
        if (state->u.osc.tri_state == NULL || state->u.osc.batches != B) {
            free(state->u.osc.tri_state);
            state->u.osc.tri_state = (double *)calloc((size_t)B, sizeof(double));
        }
    }
    if (state->u.osc.phase == NULL || state->u.osc.phase_buffer == NULL || state->u.osc.wave_buffer == NULL || state->u.osc.dphi_buffer == NULL) {
        free(owned_freq);
        free(owned_amp);
        free(owned_pan);
        free(owned_reset);
        return -1;
    }
    for (int b = 0; b < B; ++b) {
        for (int f = 0; f < F; ++f) {
            size_t idx = (size_t)b * (size_t)F + (size_t)f;
            state->u.osc.dphi_buffer[idx] = freq[idx] / sample_rate;
        }
    }
    const double *reset_ptr = accept_reset ? reset : NULL;
    phase_advance(state->u.osc.dphi_buffer, state->u.osc.phase_buffer, B, F, state->u.osc.phase, reset_ptr);
    if (strcmp(wave_buf, "saw") == 0) {
        osc_saw_blep_c(state->u.osc.phase_buffer, state->u.osc.dphi_buffer, state->u.osc.wave_buffer, B, F);
    } else if (strcmp(wave_buf, "square") == 0) {
        osc_square_blep_c(state->u.osc.phase_buffer, state->u.osc.dphi_buffer, 0.5, state->u.osc.wave_buffer, B, F);
    } else if (strcmp(wave_buf, "triangle") == 0) {
        osc_triangle_blep_c(state->u.osc.phase_buffer, state->u.osc.dphi_buffer, state->u.osc.wave_buffer, B, F, state->u.osc.tri_state);
    } else {
        for (int b = 0; b < B; ++b) {
            for (int f = 0; f < F; ++f) {
                size_t idx = (size_t)b * (size_t)F + (size_t)f;
                state->u.osc.wave_buffer[idx] = sin(state->u.osc.phase_buffer[idx] * 2.0 * M_PI);
            }
        }
    }
    int stereo = (pan_view != NULL && pan_view->data != NULL) ? 1 : 0;
    int channels = stereo ? 2 : 1;
    size_t total_out = (size_t)B * (size_t)channels * (size_t)F;
    double *buffer = (double *)malloc(total_out * sizeof(double));
    if (buffer == NULL) {
        free(owned_freq);
        free(owned_amp);
        free(owned_pan);
        free(owned_reset);
        return -1;
    }
    for (int b = 0; b < B; ++b) {
        for (int f = 0; f < F; ++f) {
            size_t idx = (size_t)b * (size_t)F + (size_t)f;
            double sample = state->u.osc.wave_buffer[idx] * amp[idx];
            if (stereo) {
                double pan_val = pan[idx];
                if (pan_val < -1.0) pan_val = -1.0;
                if (pan_val > 1.0) pan_val = 1.0;
                double angle = (pan_val + 1.0) * (M_PI / 4.0);
                double left = sample * cos(angle);
                double right = sample * sin(angle);
                buffer[((size_t)b * 2) * (size_t)F + (size_t)f] = left;
                buffer[((size_t)b * 2 + 1) * (size_t)F + (size_t)f] = right;
            } else {
                buffer[(size_t)b * (size_t)F + (size_t)f] = sample;
            }
        }
    }
    free(owned_freq);
    free(owned_amp);
    free(owned_pan);
    free(owned_reset);
    state->u.osc.channels = 1;
    state->u.osc.stereo = stereo;
    *out_buffer = buffer;
    *out_channels = stereo ? 2 : 1;
    return 0;
}

static int run_gain_node(
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double **out_buffer,
    int *out_channels
) {
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    int channels = (int)inputs->audio.channels;
    if (!inputs->audio.has_audio || inputs->audio.data == NULL || channels <= 0) {
        channels = channels > 0 ? channels : 1;
        size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
        double *buffer = (double *)calloc(total, sizeof(double));
        if (buffer == NULL) {
            return -1;
        }
        *out_buffer = buffer;
        *out_channels = channels;
        return 0;
    }
    if (channels <= 0) {
        channels = 1;
    }
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    const double *audio = inputs->audio.data;
    const EdgeRunnerParamView *gain_view = find_param(inputs, "gain");
    const double *gain = (gain_view != NULL) ? gain_view->data : NULL;
    for (int b = 0; b < batches; ++b) {
        for (int c = 0; c < channels; ++c) {
            size_t base = ((size_t)b * (size_t)channels + (size_t)c) * (size_t)frames;
            for (int f = 0; f < frames; ++f) {
                double sample = audio[base + (size_t)f];
                double g = gain != NULL ? gain[base + (size_t)f] : 1.0;
                buffer[base + (size_t)f] = sample * g;
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = channels;
    return 0;
}

static int run_mix_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double **out_buffer,
    int *out_channels
) {
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    int target_channels = json_get_int(descriptor->params_json, descriptor->params_len, "channels", 1);
    if (target_channels <= 0) {
        target_channels = 1;
    }
    size_t total = (size_t)batches * (size_t)target_channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    if (!inputs->audio.has_audio || inputs->audio.data == NULL || inputs->audio.channels == 0) {
        memset(buffer, 0, total * sizeof(double));
        *out_buffer = buffer;
        *out_channels = target_channels;
        return 0;
    }
    int in_channels = (int)inputs->audio.channels;
    const double *audio = inputs->audio.data;
    for (int b = 0; b < batches; ++b) {
        for (int f = 0; f < frames; ++f) {
            double sum = 0.0;
            for (int c = 0; c < in_channels; ++c) {
                size_t idx = ((size_t)b * (size_t)in_channels + (size_t)c) * (size_t)frames + (size_t)f;
                sum += audio[idx];
            }
            for (int oc = 0; oc < target_channels; ++oc) {
                size_t out_idx = ((size_t)b * (size_t)target_channels + (size_t)oc) * (size_t)frames + (size_t)f;
                buffer[out_idx] = sum;
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = target_channels;
    return 0;
}

static int run_sine_osc_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    if (sample_rate <= 0.0) {
        sample_rate = 48000.0;
    }
    int channels = json_get_int(descriptor->params_json, descriptor->params_len, "channels", 1);
    if (channels <= 0) {
        channels = 1;
    }
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    double initial_phase = json_get_double(descriptor->params_json, descriptor->params_len, "phase", 0.0);
    double normalized_phase = initial_phase - floor(initial_phase);
    if (state != NULL) {
        if (state->u.sine.phase == NULL || state->u.sine.batches != batches || state->u.sine.channels != channels) {
            free(state->u.sine.phase);
            state->u.sine.phase = (double *)calloc((size_t)batches * (size_t)channels, sizeof(double));
            if (state->u.sine.phase == NULL) {
                free(buffer);
                state->u.sine.batches = 0;
                state->u.sine.channels = 0;
                return -1;
            }
            state->u.sine.batches = batches;
            state->u.sine.channels = channels;
            state->u.sine.base_phase = normalized_phase;
            for (size_t idx = 0; idx < (size_t)batches * (size_t)channels; ++idx) {
                state->u.sine.phase[idx] = normalized_phase;
            }
        }
    }
    double *phase = state != NULL ? state->u.sine.phase : NULL;
    double base_freq = json_get_double(descriptor->params_json, descriptor->params_len, "frequency", 440.0);
    double base_amp = json_get_double(descriptor->params_json, descriptor->params_len, "amplitude", 0.5);
    const EdgeRunnerParamView *freq_view = find_param(inputs, "frequency");
    const EdgeRunnerParamView *amp_view = find_param(inputs, "amplitude");
    const double *freq_data = freq_view != NULL ? freq_view->data : NULL;
    const double *amp_data = amp_view != NULL ? amp_view->data : NULL;
    for (int b = 0; b < batches; ++b) {
        for (int c = 0; c < channels; ++c) {
            size_t bc = (size_t)b * (size_t)channels + (size_t)c;
            double phase_acc = phase != NULL ? phase[bc] : normalized_phase;
            for (int f = 0; f < frames; ++f) {
                size_t idx = bc * (size_t)frames + (size_t)f;
                double freq = freq_data != NULL ? freq_data[idx] : base_freq;
                double amp = amp_data != NULL ? amp_data[idx] : base_amp;
                double step = freq / sample_rate;
                phase_acc += step;
                phase_acc -= floor(phase_acc);
                buffer[idx] = sin(phase_acc * 2.0 * M_PI) * amp;
            }
            if (phase != NULL) {
                phase[bc] = phase_acc;
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = channels;
    return 0;
}

static int run_safety_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    node_state_t *state
) {
    (void)sample_rate;
    if (batches <= 0) {
        batches = 1;
    }
    if (frames <= 0) {
        frames = 1;
    }
    int channels = json_get_int(descriptor->params_json, descriptor->params_len, "channels", (int)inputs->audio.channels);
    if (channels <= 0) {
        channels = (int)inputs->audio.channels;
    }
    if (channels <= 0) {
        channels = 1;
    }
    double alpha = json_get_double(descriptor->params_json, descriptor->params_len, "dc_alpha", 0.995);
    size_t total = (size_t)batches * (size_t)channels * (size_t)frames;
    double *buffer = (double *)malloc(total * sizeof(double));
    if (buffer == NULL) {
        return -1;
    }
    if (state != NULL) {
        if (state->u.safety.state == NULL || state->u.safety.batches != batches || state->u.safety.channels != channels) {
            free(state->u.safety.state);
            state->u.safety.state = (double *)calloc((size_t)batches * (size_t)channels, sizeof(double));
            if (state->u.safety.state == NULL) {
                free(buffer);
                state->u.safety.batches = 0;
                state->u.safety.channels = 0;
                return -1;
            }
            state->u.safety.batches = batches;
            state->u.safety.channels = channels;
        }
        state->u.safety.alpha = alpha;
    }
    if (!inputs->audio.has_audio || inputs->audio.data == NULL) {
        memset(buffer, 0, total * sizeof(double));
    } else {
        double *dc_state = NULL;
        if (state != NULL) {
            dc_state = state->u.safety.state;
        }
        if (dc_state == NULL) {
            dc_state = (double *)calloc((size_t)batches * (size_t)channels, sizeof(double));
            if (dc_state == NULL) {
                free(buffer);
                return -1;
            }
            if (state != NULL) {
                state->u.safety.state = dc_state;
                state->u.safety.batches = batches;
                state->u.safety.channels = channels;
            }
        }
        dc_block(inputs->audio.data, buffer, batches, channels, frames, alpha, dc_state);
        for (size_t i = 0; i < total; ++i) {
            double v = buffer[i];
            if (v > 1.0) {
                buffer[i] = 1.0;
            } else if (v < -1.0) {
                buffer[i] = -1.0;
            }
        }
    }
    *out_buffer = buffer;
    *out_channels = channels;
    return 0;
}

AMP_CAPI int amp_run_node(
    const EdgeRunnerNodeDescriptor *descriptor,
    const EdgeRunnerNodeInputs *inputs,
    int batches,
    int channels,
    int frames,
    double sample_rate,
    double **out_buffer,
    int *out_channels,
    void **state,
    const EdgeRunnerControlHistory *history
) {
    (void)channels;
    if (out_buffer == NULL || out_channels == NULL) {
        return -1;
    }
    node_kind_t kind = determine_node_kind(descriptor);
    if (kind == NODE_KIND_UNKNOWN) {
        return -3;
    }
    node_state_t *node_state = NULL;
    if (state != NULL && *state != NULL) {
        node_state = (node_state_t *)(*state);
    }
    if (node_state != NULL && node_state->kind != kind) {
        release_node_state(node_state);
        node_state = NULL;
        if (state != NULL) {
            *state = NULL;
        }
    }
    if (node_state == NULL) {
        node_state = (node_state_t *)calloc(1, sizeof(node_state_t));
        if (node_state == NULL) {
            return -1;
        }
        node_state->kind = kind;
        if (state != NULL) {
            *state = node_state;
        }
    }

    int rc = 0;
    switch (kind) {
        case NODE_KIND_CONSTANT:
            rc = run_constant_node(descriptor, batches, frames, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_GAIN:
            rc = run_gain_node(inputs, batches, frames, out_buffer, out_channels);
            break;
        case NODE_KIND_MIX:
            rc = run_mix_node(descriptor, inputs, batches, frames, out_buffer, out_channels);
            break;
        case NODE_KIND_SAFETY:
            rc = run_safety_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_SINE_OSC:
            rc = run_sine_osc_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_CONTROLLER:
            rc = run_controller_node(descriptor, inputs, batches, frames, out_buffer, out_channels, history);
            break;
        case NODE_KIND_LFO:
            rc = run_lfo_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_ENVELOPE:
            rc = run_envelope_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_PITCH:
            rc = run_pitch_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_OSC:
            rc = run_osc_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        case NODE_KIND_SUBHARM:
            rc = run_subharm_node(descriptor, inputs, batches, frames, sample_rate, out_buffer, out_channels, node_state);
            break;
        default:
            rc = -3;
            break;
    }
    return rc;
}

AMP_CAPI void amp_free(double *buffer) {
    if (buffer != NULL) {
        free(buffer);
    }
}

AMP_CAPI void amp_release_state(void *state_ptr) {
    if (state_ptr == NULL) {
        return;
    }
    node_state_t *node_state = (node_state_t *)state_ptr;
    release_node_state(node_state);
}


/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 24), // EdgeRunnerCompiledPlan *()(unsigned char const *, size_t, unsigned char const *, size_t)
/*  1 */ _CFFI_OP(_CFFI_OP_POINTER, 193), // unsigned char const *
/*  2 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28), // size_t
/*  3 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/*  4 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/*  5 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  6 */ _CFFI_OP(_CFFI_OP_FUNCTION, 27), // EdgeRunnerControlHistory *()(unsigned char const *, size_t, int)
/*  7 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/*  8 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/*  9 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7), // int
/* 10 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 11 */ _CFFI_OP(_CFFI_OP_FUNCTION, 9), // int()(EdgeRunnerNodeDescriptor const *, EdgeRunnerNodeInputs const *, int, int, int, double, double * *, int *, void * *, EdgeRunnerControlHistory const *)
/* 12 */ _CFFI_OP(_CFFI_OP_POINTER, 182), // EdgeRunnerNodeDescriptor const *
/* 13 */ _CFFI_OP(_CFFI_OP_POINTER, 183), // EdgeRunnerNodeInputs const *
/* 14 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 15 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 16 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 17 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14), // double
/* 18 */ _CFFI_OP(_CFFI_OP_POINTER, 30), // double * *
/* 19 */ _CFFI_OP(_CFFI_OP_POINTER, 9), // int *
/* 20 */ _CFFI_OP(_CFFI_OP_POINTER, 171), // void * *
/* 21 */ _CFFI_OP(_CFFI_OP_POINTER, 181), // EdgeRunnerControlHistory const *
/* 22 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 23 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(EdgeRunnerCompiledPlan *)
/* 24 */ _CFFI_OP(_CFFI_OP_POINTER, 178), // EdgeRunnerCompiledPlan *
/* 25 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 26 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(EdgeRunnerControlHistory *)
/* 27 */ _CFFI_OP(_CFFI_OP_POINTER, 181), // EdgeRunnerControlHistory *
/* 28 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 29 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double *)
/* 30 */ _CFFI_OP(_CFFI_OP_POINTER, 17), // double *
/* 31 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 32 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double *, int, int, double *, double const *)
/* 33 */ _CFFI_OP(_CFFI_OP_POINTER, 17), // double const *
/* 34 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 35 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 36 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 37 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 38 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 39 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 40 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double *, int, int, double, double, double *)
/* 41 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 42 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 43 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 44 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 45 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 46 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 47 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 48 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 49 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double *, int, int, int, double, double *)
/* 50 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 51 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 52 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 53 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 54 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 55 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 56 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 57 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 58 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double *, int, int, int, double, double *, double *)
/* 59 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 60 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 61 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 62 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 63 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 64 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 65 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 66 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 67 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 68 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double *, int, int, int, double, double, double, int, double, double, double, double, double, double, double *, double *, double *, int8_t *, int8_t *, int8_t *, int32_t *, double *, double *, double *, double *, double *)
/* 69 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 70 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 71 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 72 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 73 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 74 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 75 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 76 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 77 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 78 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 79 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 80 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 81 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 82 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 83 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 84 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 85 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 86 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 87 */ _CFFI_OP(_CFFI_OP_POINTER, 192), // int8_t *
/* 88 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 89 */ _CFFI_OP(_CFFI_OP_NOOP, 87),
/* 90 */ _CFFI_OP(_CFFI_OP_POINTER, 190), // int32_t *
/* 91 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 92 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 93 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 94 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 95 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 96 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 97 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double const *, double *, int)
/* 98 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 99 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 100 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 101 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 102 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 103 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double const *, double *, int, int)
/* 104 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 105 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 106 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 107 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 108 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 109 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 110 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double const *, double *, int, int, double *)
/* 111 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 112 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 113 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 114 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 115 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 116 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 117 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 118 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double const *, double const *, double const *, int, int, int, double *, double *)
/* 119 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 120 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 121 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 122 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 123 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 124 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 125 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 126 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 127 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 128 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 129 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double const *, double const *, double const *, int, int, int, int, int, int, int, double, int, int *, double *, double *, double *, int64_t *, double *, double *, double *)
/* 130 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 131 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 132 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 133 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 134 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 135 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 136 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 137 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 138 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 139 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 140 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 141 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 142 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 143 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
/* 144 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 145 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 146 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 147 */ _CFFI_OP(_CFFI_OP_POINTER, 191), // int64_t *
/* 148 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 149 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 150 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 151 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 152 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, double const *, double, double *, int, int)
/* 153 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 154 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 155 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14),
/* 156 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 157 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 158 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 159 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 160 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(double const *, int, double *, int, int, int *, int *, int)
/* 161 */ _CFFI_OP(_CFFI_OP_NOOP, 33),
/* 162 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 163 */ _CFFI_OP(_CFFI_OP_NOOP, 30),
/* 164 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 165 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 166 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
/* 167 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
/* 168 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 169 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 170 */ _CFFI_OP(_CFFI_OP_FUNCTION, 195), // void()(void *)
/* 171 */ _CFFI_OP(_CFFI_OP_POINTER, 195), // void *
/* 172 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 173 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // EdgeRunnerAudioView
/* 174 */ _CFFI_OP(_CFFI_OP_POINTER, 175), // EdgeRunnerCompiledNode *
/* 175 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // EdgeRunnerCompiledNode
/* 176 */ _CFFI_OP(_CFFI_OP_POINTER, 177), // EdgeRunnerCompiledParam *
/* 177 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 2), // EdgeRunnerCompiledParam
/* 178 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 3), // EdgeRunnerCompiledPlan
/* 179 */ _CFFI_OP(_CFFI_OP_POINTER, 180), // EdgeRunnerControlCurve *
/* 180 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 4), // EdgeRunnerControlCurve
/* 181 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 5), // EdgeRunnerControlHistory
/* 182 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 6), // EdgeRunnerNodeDescriptor
/* 183 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 7), // EdgeRunnerNodeInputs
/* 184 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 8), // EdgeRunnerParamSet
/* 185 */ _CFFI_OP(_CFFI_OP_POINTER, 186), // EdgeRunnerParamView *
/* 186 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 9), // EdgeRunnerParamView
/* 187 */ _CFFI_OP(_CFFI_OP_POINTER, 189), // char *
/* 188 */ _CFFI_OP(_CFFI_OP_POINTER, 189), // char const *
/* 189 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
/* 190 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 21), // int32_t
/* 191 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 23), // int64_t
/* 192 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 17), // int8_t
/* 193 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 4), // unsigned char
/* 194 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 8), // unsigned int
/* 195 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
};

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerAudioView(EdgeRunnerAudioView *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->has_audio) | 0);  /* check that 'EdgeRunnerAudioView.has_audio' is an integer */
  (void)((p->batches) | 0);  /* check that 'EdgeRunnerAudioView.batches' is an integer */
  (void)((p->channels) | 0);  /* check that 'EdgeRunnerAudioView.channels' is an integer */
  (void)((p->frames) | 0);  /* check that 'EdgeRunnerAudioView.frames' is an integer */
  { double const * *tmp = &p->data; (void)tmp; }
}
struct _cffi_align_typedef_EdgeRunnerAudioView { char x; EdgeRunnerAudioView y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerCompiledNode(EdgeRunnerCompiledNode *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { char * *tmp = &p->name; (void)tmp; }
  (void)((p->name_len) | 0);  /* check that 'EdgeRunnerCompiledNode.name_len' is an integer */
  (void)((p->function_id) | 0);  /* check that 'EdgeRunnerCompiledNode.function_id' is an integer */
  (void)((p->audio_offset) | 0);  /* check that 'EdgeRunnerCompiledNode.audio_offset' is an integer */
  (void)((p->audio_span) | 0);  /* check that 'EdgeRunnerCompiledNode.audio_span' is an integer */
  (void)((p->param_count) | 0);  /* check that 'EdgeRunnerCompiledNode.param_count' is an integer */
  { EdgeRunnerCompiledParam * *tmp = &p->params; (void)tmp; }
}
struct _cffi_align_typedef_EdgeRunnerCompiledNode { char x; EdgeRunnerCompiledNode y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerCompiledParam(EdgeRunnerCompiledParam *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { char * *tmp = &p->name; (void)tmp; }
  (void)((p->name_len) | 0);  /* check that 'EdgeRunnerCompiledParam.name_len' is an integer */
  (void)((p->offset) | 0);  /* check that 'EdgeRunnerCompiledParam.offset' is an integer */
  (void)((p->span) | 0);  /* check that 'EdgeRunnerCompiledParam.span' is an integer */
}
struct _cffi_align_typedef_EdgeRunnerCompiledParam { char x; EdgeRunnerCompiledParam y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerCompiledPlan(EdgeRunnerCompiledPlan *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->version) | 0);  /* check that 'EdgeRunnerCompiledPlan.version' is an integer */
  (void)((p->node_count) | 0);  /* check that 'EdgeRunnerCompiledPlan.node_count' is an integer */
  { EdgeRunnerCompiledNode * *tmp = &p->nodes; (void)tmp; }
}
struct _cffi_align_typedef_EdgeRunnerCompiledPlan { char x; EdgeRunnerCompiledPlan y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerControlCurve(EdgeRunnerControlCurve *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { char * *tmp = &p->name; (void)tmp; }
  (void)((p->name_len) | 0);  /* check that 'EdgeRunnerControlCurve.name_len' is an integer */
  { double * *tmp = &p->values; (void)tmp; }
  (void)((p->value_count) | 0);  /* check that 'EdgeRunnerControlCurve.value_count' is an integer */
  { double *tmp = &p->timestamp; (void)tmp; }
}
struct _cffi_align_typedef_EdgeRunnerControlCurve { char x; EdgeRunnerControlCurve y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerControlHistory(EdgeRunnerControlHistory *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->frames_hint) | 0);  /* check that 'EdgeRunnerControlHistory.frames_hint' is an integer */
  (void)((p->curve_count) | 0);  /* check that 'EdgeRunnerControlHistory.curve_count' is an integer */
  { EdgeRunnerControlCurve * *tmp = &p->curves; (void)tmp; }
}
struct _cffi_align_typedef_EdgeRunnerControlHistory { char x; EdgeRunnerControlHistory y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerNodeDescriptor(EdgeRunnerNodeDescriptor *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { char const * *tmp = &p->name; (void)tmp; }
  (void)((p->name_len) | 0);  /* check that 'EdgeRunnerNodeDescriptor.name_len' is an integer */
  { char const * *tmp = &p->type_name; (void)tmp; }
  (void)((p->type_len) | 0);  /* check that 'EdgeRunnerNodeDescriptor.type_len' is an integer */
  { char const * *tmp = &p->params_json; (void)tmp; }
  (void)((p->params_len) | 0);  /* check that 'EdgeRunnerNodeDescriptor.params_len' is an integer */
}
struct _cffi_align_typedef_EdgeRunnerNodeDescriptor { char x; EdgeRunnerNodeDescriptor y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerNodeInputs(EdgeRunnerNodeInputs *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { EdgeRunnerAudioView *tmp = &p->audio; (void)tmp; }
  { EdgeRunnerParamSet *tmp = &p->params; (void)tmp; }
}
struct _cffi_align_typedef_EdgeRunnerNodeInputs { char x; EdgeRunnerNodeInputs y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerParamSet(EdgeRunnerParamSet *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->count) | 0);  /* check that 'EdgeRunnerParamSet.count' is an integer */
  { EdgeRunnerParamView * *tmp = &p->items; (void)tmp; }
}
struct _cffi_align_typedef_EdgeRunnerParamSet { char x; EdgeRunnerParamSet y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_EdgeRunnerParamView(EdgeRunnerParamView *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { char const * *tmp = &p->name; (void)tmp; }
  (void)((p->batches) | 0);  /* check that 'EdgeRunnerParamView.batches' is an integer */
  (void)((p->channels) | 0);  /* check that 'EdgeRunnerParamView.channels' is an integer */
  (void)((p->frames) | 0);  /* check that 'EdgeRunnerParamView.frames' is an integer */
  { double const * *tmp = &p->data; (void)tmp; }
}
struct _cffi_align_typedef_EdgeRunnerParamView { char x; EdgeRunnerParamView y; };

static void _cffi_d_amp_free(double * x0)
{
  amp_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_free(PyObject *self, PyObject *arg0)
{
  double * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { amp_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_amp_free _cffi_d_amp_free
#endif

static EdgeRunnerCompiledPlan * _cffi_d_amp_load_compiled_plan(unsigned char const * x0, size_t x1, unsigned char const * x2, size_t x3)
{
  return amp_load_compiled_plan(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_load_compiled_plan(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  size_t x1;
  unsigned char const * x2;
  size_t x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  EdgeRunnerCompiledPlan * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "amp_load_compiled_plan", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (unsigned char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (unsigned char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, size_t);
  if (x3 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = amp_load_compiled_plan(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(24));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_amp_load_compiled_plan _cffi_d_amp_load_compiled_plan
#endif

static EdgeRunnerControlHistory * _cffi_d_amp_load_control_history(unsigned char const * x0, size_t x1, int x2)
{
  return amp_load_control_history(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_load_control_history(PyObject *self, PyObject *args)
{
  unsigned char const * x0;
  size_t x1;
  int x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  EdgeRunnerControlHistory * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "amp_load_control_history", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (unsigned char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = amp_load_control_history(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(27));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_amp_load_control_history _cffi_d_amp_load_control_history
#endif

static void _cffi_d_amp_release_compiled_plan(EdgeRunnerCompiledPlan * x0)
{
  amp_release_compiled_plan(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_release_compiled_plan(PyObject *self, PyObject *arg0)
{
  EdgeRunnerCompiledPlan * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(24), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (EdgeRunnerCompiledPlan *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(24), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { amp_release_compiled_plan(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_amp_release_compiled_plan _cffi_d_amp_release_compiled_plan
#endif

static void _cffi_d_amp_release_control_history(EdgeRunnerControlHistory * x0)
{
  amp_release_control_history(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_release_control_history(PyObject *self, PyObject *arg0)
{
  EdgeRunnerControlHistory * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(27), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (EdgeRunnerControlHistory *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(27), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { amp_release_control_history(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_amp_release_control_history _cffi_d_amp_release_control_history
#endif

static void _cffi_d_amp_release_state(void * x0)
{
  amp_release_state(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_release_state(PyObject *self, PyObject *arg0)
{
  void * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(171), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (void *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(171), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { amp_release_state(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_amp_release_state _cffi_d_amp_release_state
#endif

static int _cffi_d_amp_run_node(EdgeRunnerNodeDescriptor const * x0, EdgeRunnerNodeInputs const * x1, int x2, int x3, int x4, double x5, double * * x6, int * x7, void * * x8, EdgeRunnerControlHistory const * x9)
{
  return amp_run_node(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_amp_run_node(PyObject *self, PyObject *args)
{
  EdgeRunnerNodeDescriptor const * x0;
  EdgeRunnerNodeInputs const * x1;
  int x2;
  int x3;
  int x4;
  double x5;
  double * * x6;
  int * x7;
  void * * x8;
  EdgeRunnerControlHistory const * x9;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  int result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;

  if (!PyArg_UnpackTuple(args, "amp_run_node", 10, 10, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(12), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (EdgeRunnerNodeDescriptor const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(12), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (EdgeRunnerNodeInputs const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (double)_cffi_to_c_double(arg5);
  if (x5 == (double)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(18), arg6, (char **)&x6);
  if (datasize != 0) {
    x6 = ((size_t)datasize) <= 640 ? (double * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(18), arg6, (char **)&x6,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg7, (char **)&x7);
  if (datasize != 0) {
    x7 = ((size_t)datasize) <= 640 ? (int *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(19), arg7, (char **)&x7,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg8, (char **)&x8);
  if (datasize != 0) {
    x8 = ((size_t)datasize) <= 640 ? (void * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(20), arg8, (char **)&x8,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(21), arg9, (char **)&x9);
  if (datasize != 0) {
    x9 = ((size_t)datasize) <= 640 ? (EdgeRunnerControlHistory const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(21), arg9, (char **)&x9,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = amp_run_node(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, int);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_amp_run_node _cffi_d_amp_run_node
#endif

static void _cffi_d_arp_advance(double const * x0, int x1, double * x2, int x3, int x4, int * x5, int * x6, int x7)
{
  arp_advance(x0, x1, x2, x3, x4, x5, x6, x7);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_arp_advance(PyObject *self, PyObject *args)
{
  double const * x0;
  int x1;
  double * x2;
  int x3;
  int x4;
  int * x5;
  int * x6;
  int x7;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;

  if (!PyArg_UnpackTuple(args, "arp_advance", 8, 8, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg5, (char **)&x5);
  if (datasize != 0) {
    x5 = ((size_t)datasize) <= 640 ? (int *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(19), arg5, (char **)&x5,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg6, (char **)&x6);
  if (datasize != 0) {
    x6 = ((size_t)datasize) <= 640 ? (int *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(19), arg6, (char **)&x6,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x7 = _cffi_to_c_int(arg7, int);
  if (x7 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { arp_advance(x0, x1, x2, x3, x4, x5, x6, x7); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_arp_advance _cffi_d_arp_advance
#endif

static void _cffi_d_dc_block(double const * x0, double * x1, int x2, int x3, int x4, double x5, double * x6)
{
  dc_block(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_dc_block(PyObject *self, PyObject *args)
{
  double const * x0;
  double * x1;
  int x2;
  int x3;
  int x4;
  double x5;
  double * x6;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "dc_block", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (double)_cffi_to_c_double(arg5);
  if (x5 == (double)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg6, (char **)&x6);
  if (datasize != 0) {
    x6 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg6, (char **)&x6,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { dc_block(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_dc_block _cffi_d_dc_block
#endif

static void _cffi_d_envelope_process(double const * x0, double const * x1, double const * x2, double const * x3, int x4, int x5, int x6, int x7, int x8, int x9, int x10, double x11, int x12, int * x13, double * x14, double * x15, double * x16, int64_t * x17, double * x18, double * x19, double * x20)
{
  envelope_process(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_envelope_process(PyObject *self, PyObject *args)
{
  double const * x0;
  double const * x1;
  double const * x2;
  double const * x3;
  int x4;
  int x5;
  int x6;
  int x7;
  int x8;
  int x9;
  int x10;
  double x11;
  int x12;
  int * x13;
  double * x14;
  double * x15;
  double * x16;
  int64_t * x17;
  double * x18;
  double * x19;
  double * x20;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;
  PyObject *arg10;
  PyObject *arg11;
  PyObject *arg12;
  PyObject *arg13;
  PyObject *arg14;
  PyObject *arg15;
  PyObject *arg16;
  PyObject *arg17;
  PyObject *arg18;
  PyObject *arg19;
  PyObject *arg20;

  if (!PyArg_UnpackTuple(args, "envelope_process", 21, 21, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12, &arg13, &arg14, &arg15, &arg16, &arg17, &arg18, &arg19, &arg20))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, int);
  if (x6 == (int)-1 && PyErr_Occurred())
    return NULL;

  x7 = _cffi_to_c_int(arg7, int);
  if (x7 == (int)-1 && PyErr_Occurred())
    return NULL;

  x8 = _cffi_to_c_int(arg8, int);
  if (x8 == (int)-1 && PyErr_Occurred())
    return NULL;

  x9 = _cffi_to_c_int(arg9, int);
  if (x9 == (int)-1 && PyErr_Occurred())
    return NULL;

  x10 = _cffi_to_c_int(arg10, int);
  if (x10 == (int)-1 && PyErr_Occurred())
    return NULL;

  x11 = (double)_cffi_to_c_double(arg11);
  if (x11 == (double)-1 && PyErr_Occurred())
    return NULL;

  x12 = _cffi_to_c_int(arg12, int);
  if (x12 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg13, (char **)&x13);
  if (datasize != 0) {
    x13 = ((size_t)datasize) <= 640 ? (int *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(19), arg13, (char **)&x13,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg14, (char **)&x14);
  if (datasize != 0) {
    x14 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg14, (char **)&x14,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg15, (char **)&x15);
  if (datasize != 0) {
    x15 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg15, (char **)&x15,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg16, (char **)&x16);
  if (datasize != 0) {
    x16 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg16, (char **)&x16,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(147), arg17, (char **)&x17);
  if (datasize != 0) {
    x17 = ((size_t)datasize) <= 640 ? (int64_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(147), arg17, (char **)&x17,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg18, (char **)&x18);
  if (datasize != 0) {
    x18 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg18, (char **)&x18,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg19, (char **)&x19);
  if (datasize != 0) {
    x19 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg19, (char **)&x19,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg20, (char **)&x20);
  if (datasize != 0) {
    x20 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg20, (char **)&x20,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { envelope_process(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_envelope_process _cffi_d_envelope_process
#endif

static void _cffi_d_lfo_slew(double const * x0, double * x1, int x2, int x3, double x4, double x5, double * x6)
{
  lfo_slew(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_lfo_slew(PyObject *self, PyObject *args)
{
  double const * x0;
  double * x1;
  int x2;
  int x3;
  double x4;
  double x5;
  double * x6;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;

  if (!PyArg_UnpackTuple(args, "lfo_slew", 7, 7, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = (double)_cffi_to_c_double(arg4);
  if (x4 == (double)-1 && PyErr_Occurred())
    return NULL;

  x5 = (double)_cffi_to_c_double(arg5);
  if (x5 == (double)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg6, (char **)&x6);
  if (datasize != 0) {
    x6 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg6, (char **)&x6,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { lfo_slew(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_lfo_slew _cffi_d_lfo_slew
#endif

static void _cffi_d_osc_saw_blep_c(double const * x0, double const * x1, double * x2, int x3, int x4)
{
  osc_saw_blep_c(x0, x1, x2, x3, x4);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_osc_saw_blep_c(PyObject *self, PyObject *args)
{
  double const * x0;
  double const * x1;
  double * x2;
  int x3;
  int x4;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;

  if (!PyArg_UnpackTuple(args, "osc_saw_blep_c", 5, 5, &arg0, &arg1, &arg2, &arg3, &arg4))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { osc_saw_blep_c(x0, x1, x2, x3, x4); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_osc_saw_blep_c _cffi_d_osc_saw_blep_c
#endif

static void _cffi_d_osc_square_blep_c(double const * x0, double const * x1, double x2, double * x3, int x4, int x5)
{
  osc_square_blep_c(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_osc_square_blep_c(PyObject *self, PyObject *args)
{
  double const * x0;
  double const * x1;
  double x2;
  double * x3;
  int x4;
  int x5;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "osc_square_blep_c", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = (double)_cffi_to_c_double(arg2);
  if (x2 == (double)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { osc_square_blep_c(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_osc_square_blep_c _cffi_d_osc_square_blep_c
#endif

static void _cffi_d_osc_triangle_blep_c(double const * x0, double const * x1, double * x2, int x3, int x4, double * x5)
{
  osc_triangle_blep_c(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_osc_triangle_blep_c(PyObject *self, PyObject *args)
{
  double const * x0;
  double const * x1;
  double * x2;
  int x3;
  int x4;
  double * x5;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "osc_triangle_blep_c", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg5, (char **)&x5);
  if (datasize != 0) {
    x5 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg5, (char **)&x5,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { osc_triangle_blep_c(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_osc_triangle_blep_c _cffi_d_osc_triangle_blep_c
#endif

static void _cffi_d_phase_advance(double const * x0, double * x1, int x2, int x3, double * x4, double const * x5)
{
  phase_advance(x0, x1, x2, x3, x4, x5);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_phase_advance(PyObject *self, PyObject *args)
{
  double const * x0;
  double * x1;
  int x2;
  int x3;
  double * x4;
  double const * x5;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;

  if (!PyArg_UnpackTuple(args, "phase_advance", 6, 6, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg4, (char **)&x4);
  if (datasize != 0) {
    x4 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg4, (char **)&x4,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg5, (char **)&x5);
  if (datasize != 0) {
    x5 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg5, (char **)&x5,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { phase_advance(x0, x1, x2, x3, x4, x5); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_phase_advance _cffi_d_phase_advance
#endif

static void _cffi_d_polyblep_arr(double const * x0, double const * x1, double * x2, int x3)
{
  polyblep_arr(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_polyblep_arr(PyObject *self, PyObject *args)
{
  double const * x0;
  double const * x1;
  double * x2;
  int x3;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;

  if (!PyArg_UnpackTuple(args, "polyblep_arr", 4, 4, &arg0, &arg1, &arg2, &arg3))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { polyblep_arr(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_polyblep_arr _cffi_d_polyblep_arr
#endif

static void _cffi_d_portamento_smooth(double const * x0, double const * x1, double const * x2, double const * x3, int x4, int x5, int x6, double * x7, double * x8)
{
  portamento_smooth(x0, x1, x2, x3, x4, x5, x6, x7, x8);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_portamento_smooth(PyObject *self, PyObject *args)
{
  double const * x0;
  double const * x1;
  double const * x2;
  double const * x3;
  int x4;
  int x5;
  int x6;
  double * x7;
  double * x8;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;

  if (!PyArg_UnpackTuple(args, "portamento_smooth", 9, 9, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg2, (char **)&x2);
  if (datasize != 0) {
    x2 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg2, (char **)&x2,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg3, (char **)&x3);
  if (datasize != 0) {
    x3 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg3, (char **)&x3,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = _cffi_to_c_int(arg5, int);
  if (x5 == (int)-1 && PyErr_Occurred())
    return NULL;

  x6 = _cffi_to_c_int(arg6, int);
  if (x6 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg7, (char **)&x7);
  if (datasize != 0) {
    x7 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg7, (char **)&x7,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg8, (char **)&x8);
  if (datasize != 0) {
    x8 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg8, (char **)&x8,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { portamento_smooth(x0, x1, x2, x3, x4, x5, x6, x7, x8); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_portamento_smooth _cffi_d_portamento_smooth
#endif

static void _cffi_d_safety_filter(double const * x0, double * x1, int x2, int x3, int x4, double x5, double * x6, double * x7)
{
  safety_filter(x0, x1, x2, x3, x4, x5, x6, x7);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_safety_filter(PyObject *self, PyObject *args)
{
  double const * x0;
  double * x1;
  int x2;
  int x3;
  int x4;
  double x5;
  double * x6;
  double * x7;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;

  if (!PyArg_UnpackTuple(args, "safety_filter", 8, 8, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (double)_cffi_to_c_double(arg5);
  if (x5 == (double)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg6, (char **)&x6);
  if (datasize != 0) {
    x6 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg6, (char **)&x6,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg7, (char **)&x7);
  if (datasize != 0) {
    x7 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg7, (char **)&x7,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { safety_filter(x0, x1, x2, x3, x4, x5, x6, x7); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_safety_filter _cffi_d_safety_filter
#endif

static void _cffi_d_subharmonic_process(double const * x0, double * x1, int x2, int x3, int x4, double x5, double x6, double x7, int x8, double x9, double x10, double x11, double x12, double x13, double x14, double * x15, double * x16, double * x17, int8_t * x18, int8_t * x19, int8_t * x20, int32_t * x21, double * x22, double * x23, double * x24, double * x25, double * x26)
{
  subharmonic_process(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_subharmonic_process(PyObject *self, PyObject *args)
{
  double const * x0;
  double * x1;
  int x2;
  int x3;
  int x4;
  double x5;
  double x6;
  double x7;
  int x8;
  double x9;
  double x10;
  double x11;
  double x12;
  double x13;
  double x14;
  double * x15;
  double * x16;
  double * x17;
  int8_t * x18;
  int8_t * x19;
  int8_t * x20;
  int32_t * x21;
  double * x22;
  double * x23;
  double * x24;
  double * x25;
  double * x26;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;
  PyObject *arg10;
  PyObject *arg11;
  PyObject *arg12;
  PyObject *arg13;
  PyObject *arg14;
  PyObject *arg15;
  PyObject *arg16;
  PyObject *arg17;
  PyObject *arg18;
  PyObject *arg19;
  PyObject *arg20;
  PyObject *arg21;
  PyObject *arg22;
  PyObject *arg23;
  PyObject *arg24;
  PyObject *arg25;
  PyObject *arg26;

  if (!PyArg_UnpackTuple(args, "subharmonic_process", 27, 27, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6, &arg7, &arg8, &arg9, &arg10, &arg11, &arg12, &arg13, &arg14, &arg15, &arg16, &arg17, &arg18, &arg19, &arg20, &arg21, &arg22, &arg23, &arg24, &arg25, &arg26))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(33), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (double const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(33), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  x3 = _cffi_to_c_int(arg3, int);
  if (x3 == (int)-1 && PyErr_Occurred())
    return NULL;

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  x5 = (double)_cffi_to_c_double(arg5);
  if (x5 == (double)-1 && PyErr_Occurred())
    return NULL;

  x6 = (double)_cffi_to_c_double(arg6);
  if (x6 == (double)-1 && PyErr_Occurred())
    return NULL;

  x7 = (double)_cffi_to_c_double(arg7);
  if (x7 == (double)-1 && PyErr_Occurred())
    return NULL;

  x8 = _cffi_to_c_int(arg8, int);
  if (x8 == (int)-1 && PyErr_Occurred())
    return NULL;

  x9 = (double)_cffi_to_c_double(arg9);
  if (x9 == (double)-1 && PyErr_Occurred())
    return NULL;

  x10 = (double)_cffi_to_c_double(arg10);
  if (x10 == (double)-1 && PyErr_Occurred())
    return NULL;

  x11 = (double)_cffi_to_c_double(arg11);
  if (x11 == (double)-1 && PyErr_Occurred())
    return NULL;

  x12 = (double)_cffi_to_c_double(arg12);
  if (x12 == (double)-1 && PyErr_Occurred())
    return NULL;

  x13 = (double)_cffi_to_c_double(arg13);
  if (x13 == (double)-1 && PyErr_Occurred())
    return NULL;

  x14 = (double)_cffi_to_c_double(arg14);
  if (x14 == (double)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg15, (char **)&x15);
  if (datasize != 0) {
    x15 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg15, (char **)&x15,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg16, (char **)&x16);
  if (datasize != 0) {
    x16 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg16, (char **)&x16,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg17, (char **)&x17);
  if (datasize != 0) {
    x17 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg17, (char **)&x17,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg18, (char **)&x18);
  if (datasize != 0) {
    x18 = ((size_t)datasize) <= 640 ? (int8_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(87), arg18, (char **)&x18,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg19, (char **)&x19);
  if (datasize != 0) {
    x19 = ((size_t)datasize) <= 640 ? (int8_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(87), arg19, (char **)&x19,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(87), arg20, (char **)&x20);
  if (datasize != 0) {
    x20 = ((size_t)datasize) <= 640 ? (int8_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(87), arg20, (char **)&x20,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(90), arg21, (char **)&x21);
  if (datasize != 0) {
    x21 = ((size_t)datasize) <= 640 ? (int32_t *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(90), arg21, (char **)&x21,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg22, (char **)&x22);
  if (datasize != 0) {
    x22 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg22, (char **)&x22,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg23, (char **)&x23);
  if (datasize != 0) {
    x23 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg23, (char **)&x23,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg24, (char **)&x24);
  if (datasize != 0) {
    x24 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg24, (char **)&x24,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg25, (char **)&x25);
  if (datasize != 0) {
    x25 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg25, (char **)&x25,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(30), arg26, (char **)&x26);
  if (datasize != 0) {
    x26 = ((size_t)datasize) <= 640 ? (double *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(30), arg26, (char **)&x26,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { subharmonic_process(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_subharmonic_process _cffi_d_subharmonic_process
#endif

static const struct _cffi_global_s _cffi_globals[] = {
  { "amp_free", (void *)_cffi_f_amp_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 29), (void *)_cffi_d_amp_free },
  { "amp_load_compiled_plan", (void *)_cffi_f_amp_load_compiled_plan, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 0), (void *)_cffi_d_amp_load_compiled_plan },
  { "amp_load_control_history", (void *)_cffi_f_amp_load_control_history, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 6), (void *)_cffi_d_amp_load_control_history },
  { "amp_release_compiled_plan", (void *)_cffi_f_amp_release_compiled_plan, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 23), (void *)_cffi_d_amp_release_compiled_plan },
  { "amp_release_control_history", (void *)_cffi_f_amp_release_control_history, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 26), (void *)_cffi_d_amp_release_control_history },
  { "amp_release_state", (void *)_cffi_f_amp_release_state, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 170), (void *)_cffi_d_amp_release_state },
  { "amp_run_node", (void *)_cffi_f_amp_run_node, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 11), (void *)_cffi_d_amp_run_node },
  { "arp_advance", (void *)_cffi_f_arp_advance, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 160), (void *)_cffi_d_arp_advance },
  { "dc_block", (void *)_cffi_f_dc_block, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 49), (void *)_cffi_d_dc_block },
  { "envelope_process", (void *)_cffi_f_envelope_process, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 129), (void *)_cffi_d_envelope_process },
  { "lfo_slew", (void *)_cffi_f_lfo_slew, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 40), (void *)_cffi_d_lfo_slew },
  { "osc_saw_blep_c", (void *)_cffi_f_osc_saw_blep_c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 103), (void *)_cffi_d_osc_saw_blep_c },
  { "osc_square_blep_c", (void *)_cffi_f_osc_square_blep_c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 152), (void *)_cffi_d_osc_square_blep_c },
  { "osc_triangle_blep_c", (void *)_cffi_f_osc_triangle_blep_c, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 110), (void *)_cffi_d_osc_triangle_blep_c },
  { "phase_advance", (void *)_cffi_f_phase_advance, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 32), (void *)_cffi_d_phase_advance },
  { "polyblep_arr", (void *)_cffi_f_polyblep_arr, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 97), (void *)_cffi_d_polyblep_arr },
  { "portamento_smooth", (void *)_cffi_f_portamento_smooth, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 118), (void *)_cffi_d_portamento_smooth },
  { "safety_filter", (void *)_cffi_f_safety_filter, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 58), (void *)_cffi_d_safety_filter },
  { "subharmonic_process", (void *)_cffi_f_subharmonic_process, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 68), (void *)_cffi_d_subharmonic_process },
};

static const struct _cffi_field_s _cffi_fields[] = {
  { "has_audio", offsetof(EdgeRunnerAudioView, has_audio),
                 sizeof(((EdgeRunnerAudioView *)0)->has_audio),
                 _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "batches", offsetof(EdgeRunnerAudioView, batches),
               sizeof(((EdgeRunnerAudioView *)0)->batches),
               _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "channels", offsetof(EdgeRunnerAudioView, channels),
                sizeof(((EdgeRunnerAudioView *)0)->channels),
                _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "frames", offsetof(EdgeRunnerAudioView, frames),
              sizeof(((EdgeRunnerAudioView *)0)->frames),
              _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "data", offsetof(EdgeRunnerAudioView, data),
            sizeof(((EdgeRunnerAudioView *)0)->data),
            _CFFI_OP(_CFFI_OP_NOOP, 33) },
  { "name", offsetof(EdgeRunnerCompiledNode, name),
            sizeof(((EdgeRunnerCompiledNode *)0)->name),
            _CFFI_OP(_CFFI_OP_NOOP, 187) },
  { "name_len", offsetof(EdgeRunnerCompiledNode, name_len),
                sizeof(((EdgeRunnerCompiledNode *)0)->name_len),
                _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "function_id", offsetof(EdgeRunnerCompiledNode, function_id),
                   sizeof(((EdgeRunnerCompiledNode *)0)->function_id),
                   _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "audio_offset", offsetof(EdgeRunnerCompiledNode, audio_offset),
                    sizeof(((EdgeRunnerCompiledNode *)0)->audio_offset),
                    _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "audio_span", offsetof(EdgeRunnerCompiledNode, audio_span),
                  sizeof(((EdgeRunnerCompiledNode *)0)->audio_span),
                  _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "param_count", offsetof(EdgeRunnerCompiledNode, param_count),
                   sizeof(((EdgeRunnerCompiledNode *)0)->param_count),
                   _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "params", offsetof(EdgeRunnerCompiledNode, params),
              sizeof(((EdgeRunnerCompiledNode *)0)->params),
              _CFFI_OP(_CFFI_OP_NOOP, 176) },
  { "name", offsetof(EdgeRunnerCompiledParam, name),
            sizeof(((EdgeRunnerCompiledParam *)0)->name),
            _CFFI_OP(_CFFI_OP_NOOP, 187) },
  { "name_len", offsetof(EdgeRunnerCompiledParam, name_len),
                sizeof(((EdgeRunnerCompiledParam *)0)->name_len),
                _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "offset", offsetof(EdgeRunnerCompiledParam, offset),
              sizeof(((EdgeRunnerCompiledParam *)0)->offset),
              _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "span", offsetof(EdgeRunnerCompiledParam, span),
            sizeof(((EdgeRunnerCompiledParam *)0)->span),
            _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "version", offsetof(EdgeRunnerCompiledPlan, version),
               sizeof(((EdgeRunnerCompiledPlan *)0)->version),
               _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "node_count", offsetof(EdgeRunnerCompiledPlan, node_count),
                  sizeof(((EdgeRunnerCompiledPlan *)0)->node_count),
                  _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "nodes", offsetof(EdgeRunnerCompiledPlan, nodes),
             sizeof(((EdgeRunnerCompiledPlan *)0)->nodes),
             _CFFI_OP(_CFFI_OP_NOOP, 174) },
  { "name", offsetof(EdgeRunnerControlCurve, name),
            sizeof(((EdgeRunnerControlCurve *)0)->name),
            _CFFI_OP(_CFFI_OP_NOOP, 187) },
  { "name_len", offsetof(EdgeRunnerControlCurve, name_len),
                sizeof(((EdgeRunnerControlCurve *)0)->name_len),
                _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "values", offsetof(EdgeRunnerControlCurve, values),
              sizeof(((EdgeRunnerControlCurve *)0)->values),
              _CFFI_OP(_CFFI_OP_NOOP, 30) },
  { "value_count", offsetof(EdgeRunnerControlCurve, value_count),
                   sizeof(((EdgeRunnerControlCurve *)0)->value_count),
                   _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "timestamp", offsetof(EdgeRunnerControlCurve, timestamp),
                 sizeof(((EdgeRunnerControlCurve *)0)->timestamp),
                 _CFFI_OP(_CFFI_OP_NOOP, 17) },
  { "frames_hint", offsetof(EdgeRunnerControlHistory, frames_hint),
                   sizeof(((EdgeRunnerControlHistory *)0)->frames_hint),
                   _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "curve_count", offsetof(EdgeRunnerControlHistory, curve_count),
                   sizeof(((EdgeRunnerControlHistory *)0)->curve_count),
                   _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "curves", offsetof(EdgeRunnerControlHistory, curves),
              sizeof(((EdgeRunnerControlHistory *)0)->curves),
              _CFFI_OP(_CFFI_OP_NOOP, 179) },
  { "name", offsetof(EdgeRunnerNodeDescriptor, name),
            sizeof(((EdgeRunnerNodeDescriptor *)0)->name),
            _CFFI_OP(_CFFI_OP_NOOP, 188) },
  { "name_len", offsetof(EdgeRunnerNodeDescriptor, name_len),
                sizeof(((EdgeRunnerNodeDescriptor *)0)->name_len),
                _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "type_name", offsetof(EdgeRunnerNodeDescriptor, type_name),
                 sizeof(((EdgeRunnerNodeDescriptor *)0)->type_name),
                 _CFFI_OP(_CFFI_OP_NOOP, 188) },
  { "type_len", offsetof(EdgeRunnerNodeDescriptor, type_len),
                sizeof(((EdgeRunnerNodeDescriptor *)0)->type_len),
                _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "params_json", offsetof(EdgeRunnerNodeDescriptor, params_json),
                   sizeof(((EdgeRunnerNodeDescriptor *)0)->params_json),
                   _CFFI_OP(_CFFI_OP_NOOP, 188) },
  { "params_len", offsetof(EdgeRunnerNodeDescriptor, params_len),
                  sizeof(((EdgeRunnerNodeDescriptor *)0)->params_len),
                  _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "audio", offsetof(EdgeRunnerNodeInputs, audio),
             sizeof(((EdgeRunnerNodeInputs *)0)->audio),
             _CFFI_OP(_CFFI_OP_NOOP, 173) },
  { "params", offsetof(EdgeRunnerNodeInputs, params),
              sizeof(((EdgeRunnerNodeInputs *)0)->params),
              _CFFI_OP(_CFFI_OP_NOOP, 184) },
  { "count", offsetof(EdgeRunnerParamSet, count),
             sizeof(((EdgeRunnerParamSet *)0)->count),
             _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "items", offsetof(EdgeRunnerParamSet, items),
             sizeof(((EdgeRunnerParamSet *)0)->items),
             _CFFI_OP(_CFFI_OP_NOOP, 185) },
  { "name", offsetof(EdgeRunnerParamView, name),
            sizeof(((EdgeRunnerParamView *)0)->name),
            _CFFI_OP(_CFFI_OP_NOOP, 188) },
  { "batches", offsetof(EdgeRunnerParamView, batches),
               sizeof(((EdgeRunnerParamView *)0)->batches),
               _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "channels", offsetof(EdgeRunnerParamView, channels),
                sizeof(((EdgeRunnerParamView *)0)->channels),
                _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "frames", offsetof(EdgeRunnerParamView, frames),
              sizeof(((EdgeRunnerParamView *)0)->frames),
              _CFFI_OP(_CFFI_OP_NOOP, 194) },
  { "data", offsetof(EdgeRunnerParamView, data),
            sizeof(((EdgeRunnerParamView *)0)->data),
            _CFFI_OP(_CFFI_OP_NOOP, 33) },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "$EdgeRunnerAudioView", 173, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerAudioView), offsetof(struct _cffi_align_typedef_EdgeRunnerAudioView, y), 0, 5 },
  { "$EdgeRunnerCompiledNode", 175, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerCompiledNode), offsetof(struct _cffi_align_typedef_EdgeRunnerCompiledNode, y), 5, 7 },
  { "$EdgeRunnerCompiledParam", 177, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerCompiledParam), offsetof(struct _cffi_align_typedef_EdgeRunnerCompiledParam, y), 12, 4 },
  { "$EdgeRunnerCompiledPlan", 178, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerCompiledPlan), offsetof(struct _cffi_align_typedef_EdgeRunnerCompiledPlan, y), 16, 3 },
  { "$EdgeRunnerControlCurve", 180, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerControlCurve), offsetof(struct _cffi_align_typedef_EdgeRunnerControlCurve, y), 19, 5 },
  { "$EdgeRunnerControlHistory", 181, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerControlHistory), offsetof(struct _cffi_align_typedef_EdgeRunnerControlHistory, y), 24, 3 },
  { "$EdgeRunnerNodeDescriptor", 182, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerNodeDescriptor), offsetof(struct _cffi_align_typedef_EdgeRunnerNodeDescriptor, y), 27, 6 },
  { "$EdgeRunnerNodeInputs", 183, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerNodeInputs), offsetof(struct _cffi_align_typedef_EdgeRunnerNodeInputs, y), 33, 2 },
  { "$EdgeRunnerParamSet", 184, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerParamSet), offsetof(struct _cffi_align_typedef_EdgeRunnerParamSet, y), 35, 2 },
  { "$EdgeRunnerParamView", 186, _CFFI_F_CHECK_FIELDS,
    sizeof(EdgeRunnerParamView), offsetof(struct _cffi_align_typedef_EdgeRunnerParamView, y), 37, 5 },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "EdgeRunnerAudioView", 173 },
  { "EdgeRunnerCompiledNode", 175 },
  { "EdgeRunnerCompiledParam", 177 },
  { "EdgeRunnerCompiledPlan", 178 },
  { "EdgeRunnerControlCurve", 180 },
  { "EdgeRunnerControlHistory", 181 },
  { "EdgeRunnerNodeDescriptor", 182 },
  { "EdgeRunnerNodeInputs", 183 },
  { "EdgeRunnerParamSet", 184 },
  { "EdgeRunnerParamView", 186 },
  { "uint32_t", 194 },
  { "uint8_t", 193 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  _cffi_fields,
  _cffi_struct_unions,
  NULL,  /* no enums */
  _cffi_typenames,
  19,  /* num_globals */
  10,  /* num_struct_unions */
  0,  /* num_enums */
  12,  /* num_typenames */
  NULL,  /* no includes */
  196,  /* num_types */
  0,  /* flags */
};

#ifdef __GNUC__
#  pragma GCC visibility push(default)  /* for -fvisibility= */
#endif

#ifdef PYPY_VERSION
PyMODINIT_FUNC
_cffi_pypyinit__amp_ckernels_cffi(const void *p[])
{
    p[0] = (const void *)0x2601;
    p[1] = &_cffi_type_context;
#if PY_MAJOR_VERSION >= 3
    return NULL;
#endif
}
#  ifdef _MSC_VER
     PyMODINIT_FUNC
#  if PY_MAJOR_VERSION >= 3
     PyInit__amp_ckernels_cffi(void) { return NULL; }
#  else
     init_amp_ckernels_cffi(void) { }
#  endif
#  endif
#elif PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit__amp_ckernels_cffi(void)
{
  return _cffi_init("_amp_ckernels_cffi", 0x2601, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
init_amp_ckernels_cffi(void)
{
  _cffi_init("_amp_ckernels_cffi", 0x2601, &_cffi_type_context);
}
#endif

#ifdef __GNUC__
#  pragma GCC visibility pop
#endif
